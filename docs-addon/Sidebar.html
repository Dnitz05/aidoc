<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
      <?!= include("Styles") ?>
    </style>
  </head>
  <body>

    <!-- Conversations Drawer (v5.0) -->
    <div class="conversations-drawer-backdrop" id="drawerBackdrop" onclick="closeConversationsDrawer()"></div>
    <div class="conversations-drawer" id="conversationsDrawer">
      <div class="drawer-header">
        <span class="drawer-title">
          <span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg></span>
          Historial
        </span>
        <button class="drawer-close-btn" onclick="closeConversationsDrawer()">
          <span class="i i--sm"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span>
        </button>
      </div>

      <button class="new-conversation-btn" onclick="createNewConversation()">
        <span class="i i--sm"><svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></span>
        Nova conversa
      </button>

      <div class="conversations-search">
        <div class="conversations-search-wrapper">
          <span class="conversations-search-icon"><span class="i i--sm"><svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></span></span>
          <input type="text" id="conversationsSearchInput" placeholder="Cerca converses..." oninput="filterConversations()">
        </div>
      </div>

      <div class="conversations-list" id="conversationsList">
        <!-- Conversations will be rendered here -->
        <div class="conversations-empty" id="conversationsEmpty">
          <div class="conversations-empty-icon"><span class="i i--xl i--muted"><svg viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg></span></div>
          <div class="conversations-empty-text">Cap conversa encara</div>
          <div class="conversations-empty-hint">Escriu un missatge per crear la primera conversa</div>
        </div>
      </div>
    </div>

    <!-- Navigation -->
    <nav class="nav">
      <div class="nav-tabs">
        <div class="nav-pill" id="navPill"></div>
        <button class="tab active" data-tab="chat" onclick="switchTab('chat')" title="Xat">
          <svg viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
          <span class="tab-label">Xat</span>
        </button>
        <button class="tab" data-tab="structure" onclick="switchTab('structure')" title="Estructura">
          <svg viewBox="0 0 24 24"><line x1="3" y1="6" x2="3" y2="6"/><line x1="7" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="3" y2="12"/><line x1="7" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="3" y2="18"/><line x1="7" y1="18" x2="21" y2="18"/><circle cx="3" cy="6" r="1"/><circle cx="3" cy="12" r="1"/><circle cx="3" cy="18" r="1"/></svg>
          <span class="tab-label">Estructura</span>
        </button>
        <button class="tab" data-tab="docs" onclick="switchTab('docs')" title="Coneixement">
          <svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
          <span class="tab-label">Coneixement</span>
        </button>
        <button class="tab" data-tab="timeline" onclick="switchTab('timeline')" title="Timeline">
          <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
          <span class="tab-label">Timeline</span>
        </button>
        <button class="tab" data-tab="tables" onclick="switchTab('tables')" title="Taules">
          <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg>
          <span class="tab-label">Taules</span>
        </button>
        <button class="tab" data-tab="brain" onclick="switchTab('brain')" title="Configuració">
          <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
          <span class="tab-label">Config</span>
        </button>
      </div>
    </nav>

    <!-- Chat Panel -->
    <div id="chatPanel" class="panel active">
      <!-- Chat Header with History Button -->
      <div class="chat-header">
        <div class="chat-header-left">
          <span class="chat-current-title" id="chatCurrentTitle" onclick="editCurrentTitle()" title="Clic per editar">Nova conversa</span>
          <span class="save-indicator" id="saveIndicator"></span>
        </div>
        <div class="chat-header-right">
          <button class="chat-history-btn" onclick="switchTab('recipes')" title="Receptes">Receptes</button>
          <button class="chat-history-btn" onclick="openConversationsDrawer()" title="Historial de converses">Xats</button>
          <button class="chat-new-btn" onclick="createNewConversation()" title="Nova conversa">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
          </button>
        </div>
      </div>
      <div class="chat-messages" id="chatHistory">
        <div class="msg system">Hola! Soc Docmile, el teu assistent d'escriptura.</div>
      </div>
    </div>

    <!-- Structure Panel (v3.9 - Document Structure) -->
    <div id="structurePanel" class="panel">
      <!-- Stats Overview -->
      <div class="structure-overview">
        <div class="structure-stats">
          <div class="stat-card">
            <div class="stat-value" id="statChars">--</div>
            <div class="stat-label">caràcters</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statParagraphs">--</div>
            <div class="stat-label">paràgrafs</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statHeadings">--</div>
            <div class="stat-label">headings</div>
          </div>
        </div>
        <div class="structure-meta" id="structureMeta">
          <span class="meta-item">Últim escaneig: mai</span>
        </div>
      </div>

      <!-- Document Outline -->
      <div class="structure-section">
        <div class="structure-section-header">
          <span class="section-title-icon i i--accent"><svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg></span>
          <span class="section-title-text">Document Outline</span>
        </div>
        <div class="structure-search">
          <span class="search-icon i i--muted"><svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></span>
          <input type="text" class="structure-search-input" id="structureSearch" placeholder="Cerca al document..." oninput="filterOutline()">
        </div>
        <div class="outline-tree" id="outlineTree">
          <div class="outline-empty">
            <span class="outline-empty-icon i i--muted"><svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg></span>
            <span>Clica "Escanejar" per veure l'estructura</span>
          </div>
        </div>
      </div>

      <!-- Entities Detected -->
      <div class="structure-section" id="entitiesSection">
        <div class="structure-section-header">
          <span class="section-title-icon i i--accent"><svg viewBox="0 0 24 24"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg></span>
          <span class="section-title-text">Entitats Detectades</span>
        </div>
        <div class="entities-grid" id="entitiesGrid">
          <!-- Dynamic entities -->
        </div>
      </div>

      <!-- Suggestion Card -->
      <div id="structureSuggestion" class="structure-suggestion hidden">
        <div class="suggestion-icon i i--warning i--lg"><svg viewBox="0 0 24 24"><line x1="9" y1="18" x2="15" y2="18"/><line x1="10" y1="22" x2="14" y2="22"/><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"/></svg></div>
        <div class="suggestion-content">
          <div class="suggestion-text" id="suggestionText"></div>
          <div class="suggestion-actions">
            <button class="suggestion-btn apply" onclick="applySuggestion()">Aplicar</button>
            <button class="suggestion-btn dismiss" onclick="dismissSuggestion()">Ignorar</button>
          </div>
        </div>
      </div>

      <!-- Quick Actions -->
      <div class="structure-actions">
        <button class="btn btn-secondary" onclick="refreshStructure()">
          <span class="i i--default"><svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg></span> Escanejar
        </button>
        <button class="btn btn-primary" onclick="runAutoStructure()">
          <span class="i i--default"><svg viewBox="0 0 24 24"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h.01"/><path d="M17.8 6.2 19 5"/><path d="m3 21 9-9"/><path d="M12.2 6.2 11 5"/></svg></span> Auto-Structure
        </button>
      </div>
    </div>

    <!-- Docs Panel (Knowledge) v5.1 - Library System -->
    <div id="docsPanel" class="panel">
      <div class="knowledge-panel-content">
        <!-- Active Files Section (v6.0 - Multiple Files) -->
        <div class="settings-card" id="activeFileSection">
          <div class="settings-card-header">
            <span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg></span>
            <div>
              <div class="title">Fitxers Actius</div>
              <div class="subtitle" id="activeFileStatus">Cap fitxer seleccionat</div>
            </div>
            <!-- Strict Mode Toggle (compact) -->
            <div class="strict-mode-wrapper">
              <label class="strict-mode-toggle">
                <span class="strict-mode-icon"><svg viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg></span>
                <input type="checkbox" id="strictMode">
                <span class="strict-mode-slider"></span>
              </label>
              <button class="strict-mode-info" onclick="toggleStrictModeInfo(event)">?</button>
              <div class="strict-mode-popup" id="strictModePopup">
                <div class="strict-mode-popup-title">Mode Estricte</div>
                <div class="strict-mode-popup-text">Quan està activat, la IA només utilitza la informació dels fitxers actius i el context del document. No afegeix coneixement extern.</div>
              </div>
            </div>
          </div>
          <div id="activeFileDisplay" class="knowledge-active-file hidden">
            <!-- v6.0: Multiple file chips will be rendered here dynamically -->
          </div>
        </div>

        <!-- Library Section -->
        <div class="settings-card knowledge-library-card">
          <div class="settings-card-header">
            <span class="i i--default"><svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg></span>
            <div>
              <div class="title">Biblioteca</div>
              <div class="subtitle">Fitxers pujats anteriorment</div>
            </div>
            <button class="knowledge-refresh-btn" onclick="refreshKnowledgeLibrary(true)" title="Actualitzar">
              <span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg></span>
            </button>
          </div>
          <div id="knowledgeLibraryList" class="knowledge-library-list">
            <div class="knowledge-empty">
              <span class="i i--muted"><svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg></span>
              <span>Cap fitxer a la biblioteca</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Sticky Bottom Bar -->
      <div class="knowledge-bottom-bar">
        <button class="knowledge-add-btn" onclick="showNewKnowledgeFolderModal()">
          <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg></span>
          Nova carpeta
        </button>
        <label class="knowledge-add-btn" id="uploadBtn">
          <input type="file" id="fileInput" accept=".pdf,.txt,.csv,.md" onchange="handleFileSelect()">
          <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></span>
          Pujar fitxer
        </label>
      </div>
      <div id="uploadProgress" class="upload-progress hidden">
        <div class="upload-progress-inner">
          <span class="upload-spinner"></span>
          <span class="upload-status">Processant fitxer...</span>
        </div>
        <div class="upload-progress-bar">
          <div class="upload-progress-fill"></div>
        </div>
      </div>
    </div>

    <!-- New Knowledge Folder Modal -->
    <div id="newKnowledgeFolderModal" class="modal hidden">
      <div class="modal-backdrop" onclick="hideNewKnowledgeFolderModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <span class="modal-title"><span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span> Nova Carpeta</span>
          <button class="modal-close" onclick="hideNewKnowledgeFolderModal()"><span class="i"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label class="form-label">Nom de la carpeta</label>
            <input type="text" class="form-input" id="newKnowledgeFolderName" placeholder="Ex: Documentació projecte" maxlength="30">
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" onclick="hideNewKnowledgeFolderModal()">Cancel·lar</button>
          <button class="btn btn-primary" onclick="saveNewKnowledgeFolder()">Crear Carpeta</button>
        </div>
      </div>
    </div>

    <!-- Move File Modal -->
    <div id="moveFileModal" class="modal hidden">
      <div class="modal-backdrop" onclick="hideMoveFileModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <span class="modal-title"><span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><path d="M12 11v6"/><path d="M9 14l3-3 3 3"/></svg></span> Moure fitxer</span>
          <button class="modal-close" onclick="hideMoveFileModal()"><span class="i"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>
        </div>
        <div class="modal-body">
          <div class="move-file-name" id="moveFileName"></div>
          <div class="move-folder-list" id="moveFolderList">
            <!-- Folders rendered dynamically -->
          </div>
          <div class="move-new-folder">
            <input type="text" class="form-input" id="moveNewFolderName" placeholder="O crea una nova carpeta...">
            <button class="btn btn-secondary btn-sm" onclick="moveToNewFolder()">
              <span class="i i--sm"><svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Recipes Panel (v3.6 - Folder System) -->
    <div id="recipesPanel" class="panel">
      <div class="recipes-panel-content">
        <!-- Search Bar with View Toggle -->
        <div class="recipes-toolbar">
          <button class="recipes-back-btn" onclick="goBackFromRecipes()" title="Tornar enrere">
            <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg></span>
          </button>
          <div class="recipes-search-wrapper">
            <span class="recipes-search-icon"><span class="i i--sm i--default"><svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></span></span>
            <input type="text" class="recipes-search" id="recipesSearch" placeholder="Cerca receptes..." oninput="filterRecipes()">
          </div>
          <button class="recipes-view-toggle" id="recipesViewToggle" onclick="cycleRecipesView()" title="Canviar visualització">
            <span class="i i--sm" id="recipesViewIcon"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg></span>
          </button>
        </div>

        <!-- Folders Container -->
        <div id="recipesContainer" class="folders-container">
          <!-- Dynamic folders will be loaded here -->
        </div>

        <!-- Empty State -->
        <div id="recipesEmptyState" class="recipes-empty hidden">
          <div class="recipes-empty-icon"><span class="i i--xl i--accent"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span></div>
          <div class="recipes-empty-title">No tens cap recepta</div>
          <div class="recipes-empty-subtitle">Crea carpetes i receptes per automatitzar tasques</div>
        </div>

        <!-- No Results State -->
        <div id="recipesNoResults" class="recipes-no-results hidden">
          <div class="recipes-no-results-icon"><span class="i i--xl i--accent"><svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></span></div>
          <div>Cap recepta coincideix amb la cerca</div>
        </div>
      </div>

      <!-- v6.9: Selection indicator for recipes (shows where prompt applies) -->
      <div class="selection-indicator recipes-selection" id="recipesSelectionIndicator">
        <div class="selection-scope">
          <span class="scope-icon-wrapper">
            <span class="i i--xs i--accent"><svg viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg></span>
            <span class="polling-indicator" id="recipesPollingIndicator"></span>
          </span>
          <span class="scope-label">Abast:
            <span class="scope-tooltip">
              <span class="scope-tooltip-line"></span>
              <span class="scope-tooltip-bubble">Pots actuar sobre parts seleccionades o sobre tot el document</span>
            </span>
          </span>
          <span class="scope-text" id="recipesSelectionPreview">Tot el document</span>
          <span class="selection-word-count" id="recipesSelectionWordCount"></span>
        </div>
        <div class="mode-selector" id="recipesModeSelector">
          <button class="mode-btn" onclick="toggleModeDropdown('recipes')" type="button">
            <span id="recipesModeLabel">Mode Edit</span>
            <svg class="mode-arrow" viewBox="0 0 24 24"><path d="M6 9l6 6 6-6"/></svg>
            <span class="mode-tooltip">
              <span class="mode-tooltip-line"></span>
              <span class="mode-tooltip-bubble"><b>Edit</b>: la IA pot modificar el document<br><b>Xat</b>: només respon, mai edita</span>
            </span>
          </button>
          <div class="mode-dropdown">
            <button class="mode-option selected" data-mode="edit" onclick="selectMode('edit')">
              <span class="i"><svg viewBox="0 0 24 24"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></span>
              <div class="details">
                <div class="name">Mode Edit</div>
                <div class="desc">La IA pot editar el document</div>
              </div>
            </button>
            <button class="mode-option" data-mode="chat" onclick="selectMode('chat')">
              <span class="i"><svg viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/></svg></span>
              <div class="details">
                <div class="name">Mode Xat</div>
                <div class="desc">Només conversa, mai edita</div>
              </div>
            </button>
          </div>
        </div>
      </div>

      <!-- Sticky Bottom Buttons -->
      <div class="recipes-bottom-bar">
        <button class="recipes-add-btn" onclick="showNewFolderModal()">
          <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg></span>
          Nova carpeta
        </button>
        <button class="recipes-add-btn" onclick="showNewRecipeModal()">
          <span class="i i--sm"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>
          Nova recepta
        </button>
      </div>
    </div>

    <!-- New Folder Modal (v3.6) -->
    <div id="newFolderModal" class="modal hidden">
      <div class="modal-backdrop" onclick="hideNewFolderModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <span class="modal-title"><span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span> Nova Carpeta</span>
          <button class="modal-close" onclick="hideNewFolderModal()"><span class="i"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label class="form-label">Icona</label>
            <div class="icon-selector" id="folderIconSelector">
              <!-- Icons rendered by JS -->
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">Nom</label>
            <input type="text" class="form-input" id="newFolderName" placeholder="Ex: Les meves receptes" maxlength="30">
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" onclick="hideNewFolderModal()">Cancel·lar</button>
          <button class="btn btn-primary" onclick="saveNewFolder()">Crear Carpeta</button>
        </div>
      </div>
    </div>

    <!-- Edit Folder Modal -->
    <div id="editFolderModal" class="modal hidden">
      <div class="modal-backdrop" onclick="hideEditFolderModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <span class="modal-title"><span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg></span> Editar Carpeta</span>
          <button class="modal-close" onclick="hideEditFolderModal()"><span class="i"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="editFolderIndex">
          <div class="form-group">
            <label class="form-label">Icona</label>
            <div class="icon-selector" id="editFolderIconSelector">
              <!-- Icons rendered by JS -->
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">Nom</label>
            <input type="text" class="form-input" id="editFolderName" placeholder="Ex: Les meves receptes" maxlength="30">
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" onclick="hideEditFolderModal()">Cancel·lar</button>
          <button class="btn btn-primary" onclick="saveEditFolder()">Desar Canvis</button>
        </div>
      </div>
    </div>

    <!-- New Recipe Modal (v3.6 - Folder System) -->
    <div id="newRecipeModal" class="modal hidden">
      <div class="modal-backdrop" onclick="hideNewRecipeModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <span class="modal-title"><span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h.01"/><path d="M17.8 6.2 19 5"/><path d="m3 21 9-9"/><path d="M12.2 6.2 11 5"/></svg></span> Nova Recepta</span>
          <button class="modal-close" onclick="hideNewRecipeModal()"><span class="i"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label class="form-label">Icona</label>
            <div class="icon-selector" id="recipeIconSelector">
              <!-- Icons rendered by JS -->
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">Nom</label>
            <input type="text" class="form-input" id="newRecipeName" placeholder="Ex: Fer més formal" maxlength="30">
          </div>
          <div class="form-group">
            <label class="form-label">Instrucció per la IA</label>
            <textarea class="form-input" id="newRecipeInstruction" placeholder="Què vols que faci la IA amb el text?" rows="3"></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" onclick="hideNewRecipeModal()">Cancel·lar</button>
          <button class="btn btn-primary" onclick="saveNewRecipe()">Crear Recepta</button>
        </div>
      </div>
    </div>

    <!-- Edit Recipe Modal -->
    <div id="editRecipeModal" class="modal hidden">
      <div class="modal-backdrop" onclick="hideEditRecipeModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <span class="modal-title"><span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg></span> Editar Recepta</span>
          <button class="modal-close" onclick="hideEditRecipeModal()"><span class="i"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="editRecipeFolderIndex">
          <input type="hidden" id="editRecipeIndex">
          <div class="form-group">
            <label class="form-label">Icona</label>
            <div class="icon-selector" id="editRecipeIconSelector">
              <!-- Icons rendered by JS -->
            </div>
          </div>
          <div class="form-group">
            <label class="form-label">Nom</label>
            <input type="text" class="form-input" id="editRecipeName" placeholder="Ex: Fer més formal" maxlength="30">
          </div>
          <div class="form-group">
            <label class="form-label">Instrucció per la IA</label>
            <textarea class="form-input" id="editRecipeInstruction" placeholder="Què vols que faci la IA amb el text?" rows="3"></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" onclick="hideEditRecipeModal()">Cancel·lar</button>
          <button class="btn btn-primary" onclick="saveEditRecipe()">Desar Canvis</button>
        </div>
      </div>
    </div>

    <!-- Timeline Panel (v4.0 - Forensic Timeline) -->
    <div id="timelinePanel" class="panel">
      <div class="timeline-header">
        <div class="timeline-title">
          <span class="i i--accent"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg></span>
          <span>Timeline d'Edicions</span>
        </div>
        <button class="btn-icon" onclick="loadTimeline(true)" title="Actualitzar">
          <span class="i i--sm i--muted"><svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg></span>
        </button>
      </div>
      <div class="timeline-content" id="timelineContent">
        <div class="timeline-empty">
          <span class="i i--muted"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg></span>
          <span>No hi ha edicions registrades</span>
          <span class="timeline-empty-hint">Les edicions apareixeran aquí automàticament</span>
        </div>
      </div>
    </div>

    <!-- Tables Panel (v6.0 - Table Management) -->
    <div id="tablesPanel" class="panel">
      <!-- Tables Overview Stats -->
      <div class="tables-overview">
        <div class="tables-stats">
          <div class="stat-card">
            <div class="stat-value" id="statTables">--</div>
            <div class="stat-label">taules</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statTableRows">--</div>
            <div class="stat-label">files totals</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="statTableCols">--</div>
            <div class="stat-label">columnes màx</div>
          </div>
        </div>
        <div class="tables-meta" id="tablesMeta">
          <span class="meta-item">Últim escaneig: mai</span>
        </div>
      </div>

      <!-- Tables List Section -->
      <div class="tables-section">
        <div class="tables-section-header">
          <span class="section-title-icon i i--accent"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/></svg></span>
          <span class="section-title-text">Taules del Document</span>
        </div>
        <div class="tables-list" id="tablesList">
          <div class="tables-empty">
            <span class="tables-empty-icon i i--xl i--muted"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/></svg></span>
            <span>Cap taula detectada</span>
            <span class="tables-empty-hint">Clica "Escanejar" per cercar taules</span>
          </div>
        </div>
      </div>

      <!-- AI Generation Section -->
      <div class="tables-ai-section">
        <div class="tables-section-header">
          <span class="section-title-icon i i--accent"><svg viewBox="0 0 24 24"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h.01"/><path d="M17.8 6.2 19 5"/><path d="m3 21 9-9"/><path d="M12.2 6.2 11 5"/></svg></span>
          <span class="section-title-text">Generació amb IA</span>
        </div>
        <div class="tables-ai-content">
          <textarea class="tables-ai-input" id="tablesAiInput" placeholder="Descriu la taula que vols crear...&#10;Ex: Una taula comparativa de 3 productes amb preu, característiques i valoració"></textarea>
          <div class="tables-ai-options">
            <label class="tables-option">
              <input type="checkbox" id="tablesAiHeaders" checked>
              <span>Incloure capçaleres</span>
            </label>
            <label class="tables-option">
              <input type="number" id="tablesAiRows" value="5" min="1" max="20">
              <span>files</span>
            </label>
          </div>
          <button class="btn btn-primary tables-ai-btn" onclick="generateTableWithAI()">
            <span class="i i--default"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>
            Generar Taula
          </button>
        </div>
      </div>

      <!-- Quick Actions -->
      <div class="tables-actions">
        <button class="btn btn-secondary" onclick="scanDocumentTables()">
          <span class="i i--default"><svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg></span> Escanejar
        </button>
        <button class="btn btn-secondary" onclick="insertEmptyTable()">
          <span class="i i--default"><svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></span> Nova Taula
        </button>
      </div>
    </div>

    <!-- Brain Panel (Settings) -->
    <div id="brainPanel" class="panel">
      <!-- Credits Widget v5.1 -->
      <div class="settings-card credits-card" id="creditsCard">
        <div class="credits-widget">
          <div class="credits-info">
            <span class="i i--accent"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>
            <div class="credits-text">
              <div class="credits-label">Crèdits disponibles</div>
              <div class="credits-value" id="creditsValue">--/--</div>
            </div>
          </div>
          <div class="credits-bar">
            <div class="credits-bar-fill" id="creditsBarFill" style="width: 0%"></div>
          </div>
        </div>
      </div>

      <div class="settings-card">
        <div class="settings-card-header">
          <span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg></span>
          <div>
            <div class="title">Llicencia API</div>
            <div class="subtitle">La teva clau d'accés a Docmile</div>
          </div>
        </div>
        <input type="text" class="form-input" id="licenseKey" placeholder="DOCMILE-XXXX-XXXX">
      </div>

      <!-- v12.4: BYOK Settings -->
      <div class="settings-card byok-card">
        <div class="settings-card-header">
          <span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg></span>
          <div>
            <div class="title">API Pròpia (BYOK)</div>
            <div class="subtitle">Usa la teva pròpia clau d'IA</div>
          </div>
          <label class="toggle-switch toggle-sm">
            <input type="checkbox" id="byokEnabled" onchange="toggleByokMode()">
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="byok-content" id="byokContent" style="display: none;">
          <!-- Provider selector -->
          <div class="byok-provider-selector">
            <label class="form-label">Proveïdor d'IA</label>
            <select class="form-input" id="byokProvider" onchange="onByokProviderChange()">
              <option value="">Selecciona...</option>
              <option value="gemini">Google Gemini</option>
              <option value="openai">OpenAI (ChatGPT)</option>
              <option value="claude">Anthropic Claude</option>
              <option value="mistral">Mistral AI</option>
              <option value="groq">Groq</option>
            </select>
          </div>
          <!-- Model selector -->
          <div class="byok-model-selector" id="byokModelSection" style="display: none;">
            <label class="form-label">Model</label>
            <select class="form-input" id="byokModel"></select>
          </div>
          <!-- API Key input -->
          <div class="byok-key-section" id="byokKeySection" style="display: none;">
            <label class="form-label">API Key</label>
            <div class="byok-key-row">
              <input type="password" class="form-input" id="byokApiKey" placeholder="Enganxa la teva API key...">
              <button class="byok-btn byok-toggle-visibility" onclick="toggleApiKeyVisibility()" title="Mostra/amaga">
                <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg></span>
              </button>
            </div>
            <div class="byok-key-status" id="byokKeyStatus"></div>
            <button class="byok-btn byok-save-key" id="byokSaveKeyBtn" onclick="saveByokApiKey()">
              <span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg></span>
              Guardar API Key
            </button>
          </div>
          <!-- Configured keys status -->
          <div class="byok-configured" id="byokConfigured" style="display: none;">
            <div class="byok-configured-header">Claus configurades:</div>
            <div class="byok-configured-list" id="byokConfiguredList"></div>
          </div>
        </div>
      </div>

      <div class="settings-card">
        <div class="settings-card-header">
          <span class="i i--accent"><svg viewBox="0 0 24 24"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg></span>
          <div>
            <div class="title">Guia d'Estil</div>
            <div class="subtitle">Personalitza com escriu la IA</div>
          </div>
        </div>
        <textarea class="form-input" id="styleGuide" rows="3" placeholder="Ex: Sigues formal, utilitza catala correcte..."></textarea>
      </div>

      <div class="toggle-row">
        <div class="toggle-label">
          <span class="i i--default"><svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg></span>
          <div>
            <div class="text">Mode Fosc</div>
            <div class="hint">Canvia l'aparença de la barra lateral</div>
          </div>
        </div>
        <label class="toggle-switch">
          <input type="checkbox" id="darkMode" onchange="toggleTheme()">
          <span class="toggle-slider"></span>
        </label>
      </div>

      <button class="save-btn" id="saveBtn" onclick="saveSettings()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
          <polyline points="17 21 17 13 7 13 7 21"/>
          <polyline points="7 3 7 8 15 8"/>
        </svg>
        Desar Configuracio
      </button>
      <div id="saveStatus" class="save-status">Guardat correctament!</div>
    </div>

    <!-- In-Document Preview Bar - v3.8 -->
    <div id="inDocPreviewBar" class="in-doc-preview-bar hidden">
      <div class="preview-bar-header">
        <div class="preview-bar-status">
          <span class="i i--accent"><svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></span>
          <span>Revisa els canvis al document</span>
          <span class="count" id="previewCount">1</span>
        </div>
      </div>
      <div class="preview-bar-hint">
        He marcat els canvis directament al text
        <span class="preview-legend">
          <span class="legend-item delete"><span class="i i--error i--sm"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span> Eliminar</span>
          <span class="legend-item add"><span class="i i--success i--sm"><svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg></span> Afegir</span>
        </span>
      </div>
      <div class="preview-bar-actions">
        <button class="preview-bar-btn commit" onclick="commitInDocPreview()">
          <span class="i i--success i--sm"><svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg></span> Aplicar canvis
        </button>
        <button class="preview-bar-btn cancel" onclick="cancelInDocPreview()">
          <span class="i i--error i--sm"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span> Cancel·lar
        </button>
        <button class="preview-bar-btn force-clean" onclick="forceCleanPreview()" title="Força neteja si el preview queda trabat">
          <span class="i i--warning i--sm"><svg viewBox="0 0 24 24"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></span>
        </button>
      </div>
    </div>

    <!-- v5.3: Selection preview + Mode selector -->
    <div class="selection-indicator" id="selectionIndicator">
      <div class="selection-scope">
        <span class="scope-icon-wrapper">
          <span class="i i--xs i--accent"><svg viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg></span>
          <span class="polling-indicator" id="pollingIndicator"></span>
        </span>
        <span class="scope-label" id="scopeLabel">Abast:
          <span class="scope-tooltip">
            <span class="scope-tooltip-line"></span>
            <span class="scope-tooltip-bubble">Pots actuar sobre parts seleccionades o sobre tot el document</span>
          </span>
        </span>
        <span class="scope-text" id="selectionPreview">Tot el document</span>
        <span class="selection-word-count" id="selectionWordCount"></span>
      </div>
      <div class="mode-selector" id="modeSelector">
        <button class="mode-btn" onclick="toggleModeDropdown()" type="button">
          <span id="modeLabel">Mode Edit</span>
          <svg class="mode-arrow" viewBox="0 0 24 24"><path d="M6 9l6 6 6-6"/></svg>
          <span class="mode-tooltip">
            <span class="mode-tooltip-line"></span>
            <span class="mode-tooltip-bubble"><b>Edit</b>: la IA pot modificar el document<br><b>Xat</b>: només respon, mai edita</span>
          </span>
        </button>
        <div class="mode-dropdown">
          <button class="mode-option selected" data-mode="edit" onclick="selectMode('edit')">
            <span class="i"><svg viewBox="0 0 24 24"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></span>
            <div class="details">
              <div class="name">Mode Edit</div>
              <div class="desc">La IA pot editar el document</div>
            </div>
          </button>
          <button class="mode-option" data-mode="chat" onclick="selectMode('chat')">
            <span class="i"><svg viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/></svg></span>
            <div class="details">
              <div class="name">Mode Xat</div>
              <div class="desc">Només conversa, mai edita</div>
            </div>
          </button>
        </div>
      </div>
    </div>

    <!-- Input Area (Footer) - v3.2 Redesign -->
    <div id="inputArea" class="input-area">

      <!-- v4.0: Banned Words Chips (visible constraints) -->
      <div class="constraints-area hidden" id="constraintsArea">
        <div class="constraints-chips" id="constraintsChips"></div>
        <div class="constraint-input-wrapper" id="constraintInputWrapper">
          <input type="text" class="constraint-input" id="constraintInput" placeholder="Afegir paraula..." onkeydown="handleConstraintInputKey(event)">
          <button class="constraint-input-confirm" onclick="addConstraintFromInput()"><span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg></span></button>
        </div>
      </div>

      <!-- Input wrapper amb textarea i send button flotant -->
      <div class="input-wrapper">
        <!-- v8.0: Chat attachment preview (fitxers temporals) -->
        <div class="chat-attachment-preview hidden" id="chatAttachmentPreview">
          <div class="attachment-preview-icon">
            <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
          </div>
          <div class="attachment-preview-info">
            <span class="attachment-preview-name" id="chatAttachmentName"></span>
            <span class="attachment-preview-size" id="chatAttachmentSize"></span>
          </div>
          <button class="attachment-preview-remove" onclick="removeChatAttachment()" title="Treure">×</button>
        </div>
        <!-- v8.0: Session files bar (persistent files) -->
        <div class="session-files-bar hidden" id="sessionFilesBar">
          <div class="session-files-label">
            <svg viewBox="0 0 24 24" width="12" height="12"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
            <span>Fitxers de sessió:</span>
          </div>
          <div class="session-files-list" id="sessionFilesList"></div>
          <button class="session-files-clear" onclick="clearSessionFiles()" title="Esborrar tots">×</button>
        </div>
        <div class="input-row">
          <textarea id="userInput" placeholder="Escriu la teva instrucció..." rows="1"></textarea>
          <div class="input-buttons">
            <button class="send-btn" id="sendBtn" onclick="sendMessage()" title="Enviar">
              <svg viewBox="0 0 24 24"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
            </button>
            <button class="attach-btn" id="attachBtn" onclick="triggerChatAttachment()" title="Adjuntar fitxer">
              <svg viewBox="0 0 24 24"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
            </button>
            <button class="ban-btn" id="banBtn" onclick="toggleAvoidWords()" title="Paraules a evitar">
              <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg>
            </button>
          </div>
        </div>
        <input type="file" id="chatFileInput" accept=".pdf,.txt,.csv,.md" onchange="handleChatFileSelect()" style="display: none;">
      </div>
    </div>

    <script>
      // ═══════════════════════════════════════════════════════════
      // ICON SYSTEM (v4.1) - SVG Icon Library
      // ═══════════════════════════════════════════════════════════

      const ICONS = {
        // Actions
        ban: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg>',
        check: '<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg>',
        checkCircle: '<svg viewBox="0 0 24 24"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
        x: '<svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>',
        xCircle: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>',
        plus: '<svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>',
        minus: '<svg viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"/></svg>',
        edit: '<svg viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
        trash: '<svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>',

        // Navigation
        chevronDown: '<svg viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>',
        chevronRight: '<svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"/></svg>',
        chevronUp: '<svg viewBox="0 0 24 24"><polyline points="18 15 12 9 6 15"/></svg>',

        // Content
        file: '<svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>',
        fileText: '<svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>',
        folder: '<svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
        folderOpen: '<svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><path d="M2 10h20"/></svg>',
        tag: '<svg viewBox="0 0 24 24"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>',

        // UI
        search: '<svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
        settings: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>',
        key: '<svg viewBox="0 0 24 24"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>',
        eye: '<svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>',
        eyeOff: '<svg viewBox="0 0 24 24"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>',

        // Alerts
        alertCircle: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>',
        alertTriangle: '<svg viewBox="0 0 24 24"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>',
        info: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>',

        // Actions
        play: '<svg viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>',
        zap: '<svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>',
        lightbulb: '<svg viewBox="0 0 24 24"><path d="M9 18h6M10 22h4M12 2a7 7 0 0 0-4 12.9V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.1A7 7 0 0 0 12 2z"/></svg>',
        book: '<svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>',
        list: '<svg viewBox="0 0 24 24"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
        layout: '<svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>',
        messageSquare: '<svg viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>',
        send: '<svg viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>',
        undo: '<svg viewBox="0 0 24 24"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>',
        refresh: '<svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>',
        // Additional icons for recipes and entities
        wand: '<svg viewBox="0 0 24 24"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h.01"/><path d="M17.8 6.2 19 5"/><path d="m3 21 9-9"/><path d="M12.2 6.2 11 5"/></svg>',
        star: '<svg viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
        globe: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>',
        table: '<svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg>',
        ruler: '<svg viewBox="0 0 24 24"><path d="M22 8.5V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v2.5"/><path d="M22 15.5V18a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-2.5"/><path d="M6 4v4"/><path d="M10 4v2"/><path d="M14 4v2"/><path d="M18 4v4"/></svg>',
        target: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>',
        briefcase: '<svg viewBox="0 0 24 24"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"/><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/></svg>',
        clipboard: '<svg viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>',
        rocket: '<svg viewBox="0 0 24 24"><path d="M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z"/><path d="M12 15l-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z"/></svg>',
        pin: '<svg viewBox="0 0 24 24"><path d="M12 17v5"/><path d="M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H8a2 2 0 0 0 0 4 1 1 0 0 1 1 1z"/></svg>',
        circle: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>',
        messageCircle: '<svg viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/></svg>',
        type: '<svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>',
        minimize: '<svg viewBox="0 0 24 24"><path d="M8 3v3a2 2 0 0 1-2 2H3"/><path d="M21 8h-3a2 2 0 0 1-2-2V3"/><path d="M3 16h3a2 2 0 0 1 2 2v3"/><path d="M16 21v-3a2 2 0 0 1 2-2h3"/></svg>',
        maximize: '<svg viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>',
        clock: '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>',
        calendar: '<svg viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>',
        dollarSign: '<svg viewBox="0 0 24 24"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>',
        percent: '<svg viewBox="0 0 24 24"><line x1="19" y1="5" x2="5" y2="19"/><circle cx="6.5" cy="6.5" r="2.5"/><circle cx="17.5" cy="17.5" r="2.5"/></svg>',
        hash: '<svg viewBox="0 0 24 24"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg>',
        mail: '<svg viewBox="0 0 24 24"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>',
        link: '<svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>',
        loader: '<svg viewBox="0 0 24 24"><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"/><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"/><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"/></svg>',
        gripVertical: '<svg viewBox="0 0 24 24"><circle cx="9" cy="5" r="1.5"/><circle cx="9" cy="12" r="1.5"/><circle cx="9" cy="19" r="1.5"/><circle cx="15" cy="5" r="1.5"/><circle cx="15" cy="12" r="1.5"/><circle cx="15" cy="19" r="1.5"/></svg>',
        rotateCcw: '<svg viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>',
        user: '<svg viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>',
        flag: '<svg viewBox="0 0 24 24"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/><line x1="4" y1="22" x2="4" y2="15"/></svg>',
        penTool: '<svg viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>',
        save: '<svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>',
        bookmark: '<svg viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg>'
      };

      // Helper function to render icons
      function icon(name, className) {
        const svg = ICONS[name] || ICONS.alertCircle;
        const classes = 'i' + (className ? ' ' + className : '');
        return '<span class="' + classes + '">' + svg + '</span>';
      }

      // ═══════════════════════════════════════════════════════════
      // CREDITS WIDGET (v5.1)
      // ═══════════════════════════════════════════════════════════

      let totalCredits = 100; // Default, will be updated from API

      function updateCredits(remaining, total) {
        if (remaining === undefined || remaining === null) return;

        if (total !== undefined && total !== null) {
          totalCredits = total;
        }

        const valueEl = document.getElementById('creditsValue');
        const barFillEl = document.getElementById('creditsBarFill');

        if (valueEl) {
          valueEl.textContent = remaining + '/' + totalCredits;
        }

        if (barFillEl) {
          const percent = Math.max(0, Math.min(100, (remaining / totalCredits) * 100));
          barFillEl.style.width = percent + '%';

          // Add 'low' class if credits are below 20%
          if (percent < 20) {
            barFillEl.classList.add('low');
          } else {
            barFillEl.classList.remove('low');
          }
        }
      }

      function loadCredits() {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.status === 'ok') {
              updateCredits(result.credits_remaining, result.credits_total);
            } else if (result) {
              updateCredits(result.credits_remaining || 0, result.credits_total || 100);
            }
          })
          .withFailureHandler(function(err) {
            // Silent fail - will show --/--
          })
          .getCreditsInfo();
      }

      // ═══════════════════════════════════════════════════════════
      // STATE & INIT
      // ═══════════════════════════════════════════════════════════

      let currentSettings = {};
      let selectedIcon = 'zap';
      let currentTab = 'chat';
      let currentMode = 'edit'; // edit | chat
      let bannedWords = []; // v2.8: Banned expressions
      let pendingUndo = null; // v2.6 Sprint: Snapshot per Optimistic UI Undo
      let pendingPreviewChanges = null; // v3.2: Canvis pendents d'aprovar
      let pendingDocSnapshot = null;    // v3.3: Snapshot per detectar race conditions
      const previewModeEnabled = true;  // v10.2: Sempre activat (preview obligatori)

      // v11.0: Annotation System - Unified Highlights + Changes
      let pendingAnnotations = [];      // Array d'anotacions {id, type, para_id, status, ...}
      let annotationDocSnapshot = null; // Snapshot per verificar canvis
      let annotationModificationType = null; // v12.1: Per router híbrid (fix|improve|expand|simplify|translate)
      let cachedTimelineData = null;    // v4.1: Pre-loaded timeline data

      // v5.3: Selection polling
      let selectionPollingActive = false;
      let selectionRequestPending = false;
      let lastSelectionText = '';

      // v5.0: Conversations System
      let currentConversationId = null;
      let conversationsList = [];
      let conversationsLoaded = false;

      // v5.2: Debounced save system
      let pendingSaveMessages = [];
      let saveDebounceTimer = null;
      let conversationMessageCount = 0; // Track for auto-title trigger
      const SAVE_DEBOUNCE_MS = 1500; // Save 1.5s after last message

      // v6.5: Pagination for large conversations
      const MESSAGES_PAGE_SIZE = 50;
      let currentMessagesOffset = 0;
      let isLoadingMessages = false;
      let hasMoreMessages = false;
      let totalMessagesCount = 0;

      // v6.9: ESC key cancellation system
      let requestInProgress = false;
      let requestCancelled = false;

      // v14.8: Sistema centralitzat de gestió de listeners (memory leak fix)
      const registeredListeners = [];
      let listenersInitialized = false;

      /**
       * Registra un event listener i guarda la referència per cleanup
       * @param {Element} element - Element DOM o document/window
       * @param {string} event - Nom de l'event (click, blur, etc.)
       * @param {Function} handler - Funció handler
       * @param {Object} options - Opcions del listener (opcional)
       */
      function registerListener(element, event, handler, options) {
        if (!element) return;
        element.addEventListener(event, handler, options);
        registeredListeners.push({ element, event, handler, options });
      }

      /**
       * Elimina tots els listeners registrats
       * Cridat automàticament a beforeunload per evitar memory leaks
       */
      function cleanupAllListeners() {
        console.log('[Docmile v14.8] Cleaning up', registeredListeners.length, 'listeners');
        registeredListeners.forEach(({ element, event, handler, options }) => {
          try {
            element.removeEventListener(event, handler, options);
          } catch (e) {
            // Ignorar errors si l'element ja no existeix
          }
        });
        registeredListeners.length = 0;
        listenersInitialized = false;
      }

      console.log('[Docmile v14.8] Loaded - Memory leak fix');

      const MODES = {
        edit: { icon: 'edit', label: 'Mode Edit' },
        chat: { icon: 'messageCircle', label: 'Mode Xat' }
      };

      let hasActiveSelection = false;

      function updateModeLabel() {
        const mode = MODES[currentMode];
        // Update both chat and recipes mode labels
        document.getElementById('modeLabel').textContent = mode.label;
        const recipesLabel = document.getElementById('recipesModeLabel');
        if (recipesLabel) recipesLabel.textContent = mode.label;
      }

      // ═══════════════════════════════════════════════════════════
      // CONVERSATIONS SYSTEM (v5.0)
      // ═══════════════════════════════════════════════════════════

      function openConversationsDrawer() {
        document.getElementById('conversationsDrawer').classList.add('open');
        document.getElementById('drawerBackdrop').classList.add('visible');
        if (!conversationsLoaded) {
          loadConversations();
        }
      }

      function closeConversationsDrawer() {
        document.getElementById('conversationsDrawer').classList.remove('open');
        document.getElementById('drawerBackdrop').classList.remove('visible');
      }

      function loadConversations() {
        const listEl = document.getElementById('conversationsList');
        const emptyEl = document.getElementById('conversationsEmpty');

        // Show loading skeleton
        listEl.innerHTML = `
          <div class="conversation-skeleton">
            <div class="skeleton-avatar"></div>
            <div class="skeleton-lines">
              <div class="skeleton-line"></div>
              <div class="skeleton-line short"></div>
            </div>
          </div>
          <div class="conversation-skeleton">
            <div class="skeleton-avatar"></div>
            <div class="skeleton-lines">
              <div class="skeleton-line"></div>
              <div class="skeleton-line short"></div>
            </div>
          </div>
        `;
        emptyEl.classList.add('hidden');

        if (!currentSettings.license_key) {
          listEl.innerHTML = '';
          emptyEl.classList.remove('hidden');
          return;
        }

        google.script.run
          .withSuccessHandler(function(res) {
            conversationsLoaded = true;
            if (res.status === 'ok' && res.conversations && res.conversations.length > 0) {
              conversationsList = res.conversations;
              renderConversationsList(res.conversations);
              emptyEl.classList.add('hidden');
            } else {
              listEl.innerHTML = '';
              emptyEl.classList.remove('hidden');
            }
          })
          .withFailureHandler(function(err) {
            console.error('Error loading conversations:', err);
            listEl.innerHTML = '';
            emptyEl.classList.remove('hidden');
          })
          .callWorker({
            action: 'list_conversations',
            license_key: currentSettings.license_key,
            limit: 50
          });
      }

      function renderConversationsList(conversations) {
        const listEl = document.getElementById('conversationsList');

        // Group by date
        const groups = groupConversationsByDate(conversations);
        let html = '';

        for (const group of groups) {
          html += '<div class="conversation-group">';
          html += '<div class="conversation-group-title">' + group.label + '</div>';

          for (const conv of group.conversations) {
            const isActive = conv.id === currentConversationId ? ' active' : '';
            const pinnedClass = conv.pinned ? ' active' : '';
            const pinnedBadge = conv.pinned ? '<span class="conversation-pinned">' + icon('pin', 'i--sm') + '</span>' : '';

            html += `
              <div class="conversation-item${isActive}" data-id="${conv.id}" onclick="switchConversation('${conv.id}')">
                <div class="conversation-item-icon">
                  ${icon('messageCircle', 'i--sm')}
                </div>
                <div class="conversation-item-content">
                  <div class="conversation-item-title" onclick="editTitleInline('${conv.id}', this, event)" title="Clic per editar">${escapeHtml(conv.title)}</div>
                  <div class="conversation-item-preview">${escapeHtml(conv.preview || '')}</div>
                  <div class="conversation-item-meta">
                    ${pinnedBadge}
                    <span>${conv.message_count} missatges</span>
                  </div>
                </div>
                <div class="conversation-item-actions">
                  <button class="conversation-action-btn pin${pinnedClass}" onclick="togglePin('${conv.id}', event)" title="${conv.pinned ? 'Desfixar' : 'Fixar'}">
                    ${icon('pin', 'i--sm')}
                  </button>
                  <button class="conversation-action-btn delete" onclick="event.stopPropagation(); deleteConversation('${conv.id}')" title="Eliminar">
                    ${icon('trash', 'i--sm')}
                  </button>
                </div>
              </div>
            `;
          }
          html += '</div>';
        }

        listEl.innerHTML = html;
      }

      function groupConversationsByDate(conversations) {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
        const lastWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);

        const groups = {
          today: { label: 'Avui', conversations: [] },
          yesterday: { label: 'Ahir', conversations: [] },
          lastWeek: { label: 'Aquesta setmana', conversations: [] },
          older: { label: 'Més antic', conversations: [] }
        };

        for (const conv of conversations) {
          const date = new Date(conv.updated_at);
          if (date >= today) {
            groups.today.conversations.push(conv);
          } else if (date >= yesterday) {
            groups.yesterday.conversations.push(conv);
          } else if (date >= lastWeek) {
            groups.lastWeek.conversations.push(conv);
          } else {
            groups.older.conversations.push(conv);
          }
        }

        // Return only non-empty groups
        return Object.values(groups).filter(g => g.conversations.length > 0);
      }

      function switchConversation(conversationId) {
        currentConversationId = conversationId;
        closeConversationsDrawer();

        // v6.5: Reset pagination state
        currentMessagesOffset = 0;
        hasMoreMessages = false;
        totalMessagesCount = 0;

        // Clear chat and show loading
        const chatHistory = document.getElementById('chatHistory');
        chatHistory.innerHTML = '<div class="msg system">Carregant conversa...</div>';

        // v6.5: First get conversation metadata, then load paginated messages
        google.script.run
          .withSuccessHandler(function(res) {
            if (res.status === 'ok' && res.conversation) {
              updateConversationTitle(res.conversation.title);
              conversationMessageCount = res.conversation.message_count || 0;
              totalMessagesCount = conversationMessageCount;
              updateActiveConversation(conversationId);

              // Load initial batch of messages (most recent)
              loadPaginatedMessages(conversationId, false);
            } else {
              chatHistory.innerHTML = '<div class="msg system">Error carregant la conversa</div>';
            }
          })
          .withFailureHandler(function(err) {
            console.error('Error loading conversation:', err);
            chatHistory.innerHTML = '<div class="msg system">Error: ' + err.message + '</div>';
          })
          .callWorker({
            action: 'get_conversation',
            license_key: currentSettings.license_key,
            conversation_id: conversationId
          });
      }

      // v6.5: Load paginated messages
      function loadPaginatedMessages(conversationId, prepend) {
        if (isLoadingMessages) return;
        isLoadingMessages = true;

        const chatHistory = document.getElementById('chatHistory');
        const scrollHeightBefore = chatHistory.scrollHeight;

        if (!prepend) {
          chatHistory.innerHTML = '<div class="msg system">Carregant missatges...</div>';
        } else {
          // Show loading indicator at top
          const loadingEl = document.createElement('div');
          loadingEl.className = 'msg loading-more';
          loadingEl.innerHTML = '<div class="thinking-shimmer"></div>';
          loadingEl.id = 'loadingMoreIndicator';
          chatHistory.insertBefore(loadingEl, chatHistory.firstChild);
        }

        google.script.run
          .withSuccessHandler(function(res) {
            document.getElementById('loadingMoreIndicator')?.remove();
            isLoadingMessages = false;

            if (res.status === 'ok') {
              loadConversationMessages({
                messages: res.messages || [],
                has_more: res.has_more,
                total: res.total
              }, prepend);

              if (prepend) {
                // Maintain scroll position
                const scrollHeightAfter = chatHistory.scrollHeight;
                chatHistory.scrollTop = scrollHeightAfter - scrollHeightBefore;
              }
            } else {
              if (!prepend) {
                chatHistory.innerHTML = '<div class="msg system">Error carregant missatges</div>';
              }
            }
          })
          .withFailureHandler(function(err) {
            document.getElementById('loadingMoreIndicator')?.remove();
            isLoadingMessages = false;
            console.error('Error loading messages:', err);
            if (!prepend) {
              chatHistory.innerHTML = '<div class="msg system">Error: ' + err.message + '</div>';
            }
          })
          .callWorker({
            action: 'get_conversation_messages',
            license_key: currentSettings.license_key,
            conversation_id: conversationId,
            offset: currentMessagesOffset,
            limit: MESSAGES_PAGE_SIZE
          });
      }

      // v6.5: Load older messages when scrolling up
      function loadMoreMessages() {
        if (isLoadingMessages || !hasMoreMessages || !currentConversationId) return;
        loadPaginatedMessages(currentConversationId, true);
      }

      function loadConversationMessages(conversation, prepend) {
        const chatHistory = document.getElementById('chatHistory');

        if (!prepend) {
          chatHistory.innerHTML = '';
          currentMessagesOffset = 0;
        }

        if (conversation.messages && conversation.messages.length > 0) {
          // v6.5: Create bubbles and add them properly
          for (const msg of conversation.messages) {
            const bubble = document.createElement('div');
            bubble.className = 'msg ' + (msg.role === 'ai' ? 'ai' : 'user');

            if (msg.role === 'ai') {
              // Use markdown for AI messages
              bubble.innerHTML = '<div class="md-content">' + renderMarkdown(msg.content) + '</div>';
            } else {
              // v6.9: Sanitize user messages and wrap in user-text div
              // Filter out any HTML tags that might have been saved accidentally
              const cleanText = msg.content.replace(/<[^>]*>/g, '').trim();
              bubble.innerHTML = '<div class="user-text">' + cleanText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>') + '</div>';
            }

            if (prepend) {
              chatHistory.insertBefore(bubble, chatHistory.firstChild);
            } else {
              chatHistory.appendChild(bubble);
            }
          }

          // Update pagination state
          currentMessagesOffset += conversation.messages.length;
          hasMoreMessages = conversation.has_more || false;
          if (conversation.total) {
            totalMessagesCount = conversation.total;
          }

          // Scroll to bottom for initial load
          if (!prepend) {
            chatHistory.scrollTop = chatHistory.scrollHeight;
          }
        } else if (!prepend) {
          // v7.1: Mostrar landing per converses buides
          showChatLanding();
        }
      }

      // v6.5: Initialize scroll listener for lazy loading
      // v14.8: Amb registre per cleanup
      function initChatScrollListener() {
        const chatHistory = document.getElementById('chatHistory');
        if (!chatHistory) return;

        const handleChatScroll = function() {
          // Load more when near the top
          if (chatHistory.scrollTop < 100 && hasMoreMessages && !isLoadingMessages && currentConversationId) {
            loadMoreMessages();
          }
        };
        registerListener(chatHistory, 'scroll', handleChatScroll);
      }

      function updateConversationTitle(title) {
        console.log('%c[TITLE UPDATE] ' + (title || 'Nova conversa'), 'background: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px;');
        document.getElementById('chatCurrentTitle').textContent = title || 'Nova conversa';
      }

      function updateActiveConversation(activeId) {
        document.querySelectorAll('.conversation-item').forEach(function(el) {
          if (el.dataset.id === activeId) {
            el.classList.add('active');
          } else {
            el.classList.remove('active');
          }
        });
      }

      function createNewConversation() {
        currentConversationId = null;
        conversationMessageCount = 0; // v5.2: Reset counter
        updateConversationTitle('Nova conversa');
        closeConversationsDrawer();

        // v7.1: Mostrar landing interactiva en lloc de missatge simple
        showChatLanding();

        // Update drawer if open
        updateActiveConversation(null);
      }

      function deleteConversation(conversationId) {
        if (!confirm('Eliminar aquesta conversa?')) return;

        google.script.run
          .withSuccessHandler(function(res) {
            if (res.status === 'ok') {
              showToast('Conversa eliminada', 'success');
              // Remove from list
              conversationsList = conversationsList.filter(c => c.id !== conversationId);
              renderConversationsList(conversationsList);
              // If deleted current, start new
              if (currentConversationId === conversationId) {
                createNewConversation();
              }
            }
          })
          .withFailureHandler(function(err) {
            showToast('Error: ' + err.message, 'error');
          })
          .callWorker({
            action: 'delete_conversation',
            license_key: currentSettings.license_key,
            conversation_id: conversationId
          });
      }

      function filterConversations() {
        const searchTerm = document.getElementById('conversationsSearchInput').value.toLowerCase().trim();

        if (!searchTerm) {
          renderConversationsList(conversationsList);
          return;
        }

        const filtered = conversationsList.filter(function(conv) {
          return conv.title.toLowerCase().includes(searchTerm) ||
                 (conv.preview && conv.preview.toLowerCase().includes(searchTerm));
        });

        if (filtered.length > 0) {
          renderConversationsList(filtered);
          document.getElementById('conversationsEmpty').classList.add('hidden');
        } else {
          document.getElementById('conversationsList').innerHTML = `
            <div class="conversations-empty">
              <div class="conversations-empty-icon">${icon('search', 'i--xl i--muted')}</div>
              <div class="conversations-empty-text">Cap resultat per "${escapeHtml(searchTerm)}"</div>
            </div>
          `;
        }
      }

      // ═══════════════════════════════════════════════════════════
      // THEME MANAGEMENT
      // ═══════════════════════════════════════════════════════════

      function initTheme() {
        const savedTheme = localStorage.getItem('docmile-theme');
        const isDark = savedTheme === 'dark';
        applyTheme(isDark);
        document.getElementById('darkMode').checked = isDark;
      }

      function toggleTheme() {
        const isDark = document.getElementById('darkMode').checked;
        applyTheme(isDark);
        localStorage.setItem('docmile-theme', isDark ? 'dark' : 'light');
      }

      // ═══════════════════════════════════════════════════════════
      // IN-DOCUMENT PREVIEW (v3.8)
      // ═══════════════════════════════════════════════════════════

      function showInDocPreviewBar(count) {
        const bar = document.getElementById('inDocPreviewBar');
        const countEl = document.getElementById('previewCount');
        if (bar) {
          bar.classList.remove('hidden');
          if (countEl) countEl.textContent = count || 1;
        }
        // Disable input while preview is active
        document.getElementById('userInput').disabled = true;
        document.getElementById('sendBtn').disabled = true;
      }

      function hideInDocPreviewBar() {
        const bar = document.getElementById('inDocPreviewBar');
        if (bar) bar.classList.add('hidden');
        // Re-enable input
        document.getElementById('userInput').disabled = false;
        document.getElementById('sendBtn').disabled = false;
      }

      function commitInDocPreview() {
        const commitBtn = document.querySelector('.preview-bar-btn.commit');
        const cancelBtn = document.querySelector('.preview-bar-btn.cancel');

        // Disable buttons during operation
        if (commitBtn) {
          commitBtn.disabled = true;
          commitBtn.innerHTML = icon('loader', 'i--default') + ' Aplicant...';
        }
        if (cancelBtn) cancelBtn.disabled = true;

        google.script.run
          .withSuccessHandler(function(result) {
            hideInDocPreviewBar();
            if (result && result.ok) {
              showToast(result.message || 'Fet!', 'success');

              // v10.2: Afegir badge "Fet!" + "Desfer" a l'última bombolla AI
              addCommitBadgeToLastAiBubble(result.undo_snapshot);

            } else {
              showToast(result?.message || 'Error aplicant canvis', 'warning');
              addMessage('assistant', icon('alertTriangle', 'i--warning') + ' Error: ' + (result?.message || 'No s\'han pogut aplicar els canvis'));
            }
            // Reset buttons
            if (commitBtn) {
              commitBtn.disabled = false;
              commitBtn.innerHTML = icon('check', 'i--success') + ' Aplicar canvis';
            }
            if (cancelBtn) cancelBtn.disabled = false;
          })
          .withFailureHandler(function(error) {
            hideInDocPreviewBar();
            showToast('Error: ' + error.message, 'error');
            addMessage('assistant', icon('xCircle', 'i--error') + ' Error aplicant canvis: ' + error.message);
            // Reset buttons
            if (commitBtn) {
              commitBtn.disabled = false;
              commitBtn.innerHTML = icon('check', 'i--success') + ' Aplicar canvis';
            }
            if (cancelBtn) cancelBtn.disabled = false;
          })
          .commitInDocumentPreview();
      }

      // v10.2: Afegir badges "Fet!" i "Desfer" separats a l'última bombolla AI
      function addCommitBadgeToLastAiBubble(undoSnapshot) {
        const chatHistory = document.getElementById('chatHistory');
        if (!chatHistory) return;

        // Trobar l'última bombolla AI (no review-note)
        const bubbles = chatHistory.querySelectorAll('.msg.ai:not(.review-note)');
        const lastAiBubble = bubbles[bubbles.length - 1];
        if (!lastAiBubble) return;

        // Guardar snapshot per desfer
        if (undoSnapshot) {
          pendingUndo = undoSnapshot;
        }

        // Crear badges HTML - separats i independents
        let badgesHtml = '<div class="commit-badges-row">';

        // Badge "Fet!" - sempre visible
        badgesHtml += '<span class="commit-badge done-badge">' +
          icon('check', 'i--xs') + ' Fet!</span>';

        // Badge "Desfer" - separat, actiu o inactiu
        if (undoSnapshot) {
          badgesHtml += '<button class="commit-badge undo-badge active" onclick="undoLastCommit()" title="Desfer aquest canvi">' +
            icon('undo', 'i--xs') + ' Desfer</button>';
        }
        badgesHtml += '</div>';

        // Inserir badges al principi de la bombolla
        lastAiBubble.insertAdjacentHTML('afterbegin', badgesHtml);

        // Marcar la bombolla com a "committed"
        lastAiBubble.classList.add('committed');
      }

      // v10.2: Desactivar el botó Desfer quan es fa un nou canvi
      function disablePendingUndo() {
        if (!pendingUndo) return;

        // Marcar tots els botons Desfer com a inactius
        const undoBadges = document.querySelectorAll('.undo-badge.active');
        undoBadges.forEach(function(badge) {
          badge.classList.remove('active');
          badge.classList.add('inactive');
          badge.disabled = true;
          badge.title = 'Ja no es pot desfer (s\'han fet altres canvis)';
        });

        // Netejar el snapshot
        pendingUndo = null;
      }

      // v10.2: Desfer l'últim commit
      function undoLastCommit() {
        if (!pendingUndo) {
          showToast('No hi ha res per desfer', 'warning');
          return;
        }

        // Desactivar botó mentre es processa
        const undoBtn = document.querySelector('.undo-badge.active');
        if (undoBtn) {
          undoBtn.disabled = true;
          undoBtn.innerHTML = icon('loader', 'i--xs') + ' Desfent...';
        }

        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.status === 'restored') {
              showToast('Canvi desfet!', 'undo');
              // Actualitzar el badge Desfer a "Desfet"
              if (undoBtn) {
                undoBtn.innerHTML = icon('check', 'i--xs') + ' Desfet';
                undoBtn.classList.remove('active');
                undoBtn.classList.add('done');
                undoBtn.disabled = true;
              }
              // Canviar el badge "Fet!" a estat desfet
              const doneRow = undoBtn ? undoBtn.closest('.commit-badges-row') : null;
              const doneBadge = doneRow ? doneRow.querySelector('.done-badge') : null;
              if (doneBadge) {
                doneBadge.classList.add('undone');
              }
              pendingUndo = null;
            } else {
              showToast('Error: ' + (result?.error || 'No s\'ha pogut desfer'), 'error');
              if (undoBtn) {
                undoBtn.disabled = false;
                undoBtn.innerHTML = icon('undo', 'i--xs') + ' Desfer';
              }
            }
          })
          .withFailureHandler(function(error) {
            showToast('Error: ' + error.message, 'error');
            if (undoBtn) {
              undoBtn.disabled = false;
              undoBtn.innerHTML = icon('undo', 'i--xs') + ' Desfer';
            }
          })
          .restoreText(pendingUndo.targetId, pendingUndo.originalText, pendingUndo.bodyIndex, pendingUndo.formatSnapshot);
      }

      function cancelInDocPreview() {
        const commitBtn = document.querySelector('.preview-bar-btn.commit');
        const cancelBtn = document.querySelector('.preview-bar-btn.cancel');

        // Disable buttons during operation
        if (cancelBtn) {
          cancelBtn.disabled = true;
          cancelBtn.innerHTML = icon('loader', 'i--default') + ' Cancel·lant...';
        }
        if (commitBtn) commitBtn.disabled = true;

        google.script.run
          .withSuccessHandler(function(result) {
            hideInDocPreviewBar();
            if (result && result.ok) {
              showToast(result.message || 'Canvis cancel·lats', 'undo');
              addMessage('assistant', icon('undo', 'i--default') + ' S\'han cancel·lat ' + result.cancelled + ' canvis. Document restaurat.');
            } else {
              showToast(result?.message || 'Error cancel·lant', 'warning');
            }
            // Reset buttons
            if (commitBtn) commitBtn.disabled = false;
            if (cancelBtn) {
              cancelBtn.disabled = false;
              cancelBtn.innerHTML = icon('x', 'i--error') + ' Cancel·lar';
            }
          })
          .withFailureHandler(function(error) {
            hideInDocPreviewBar();
            showToast('Error: ' + error.message, 'error');
            // Reset buttons
            if (commitBtn) commitBtn.disabled = false;
            if (cancelBtn) {
              cancelBtn.disabled = false;
              cancelBtn.innerHTML = icon('x', 'i--error') + ' Cancel·lar';
            }
          })
          .cancelInDocumentPreview();
      }

      function forceCleanPreview() {
        const forceBtn = document.querySelector('.preview-bar-btn.force-clean');
        if (forceBtn) {
          forceBtn.disabled = true;
          forceBtn.innerHTML = icon('loader', 'i--warning') + ' Netejant...';
        }

        google.script.run
          .withSuccessHandler(function(result) {
            hideInDocPreviewBar();
            if (result && result.ok) {
              showToast(result.message || 'Document netejat', 'success');
              if (result.cleaned > 0) {
                addMessage('assistant', icon('trash', 'i--warning') + ' Força neteja: ' + result.message);
              }
            } else {
              showToast(result?.error || 'Error netejant', 'error');
            }
            if (forceBtn) {
              forceBtn.disabled = false;
              forceBtn.innerHTML = icon('trash', 'i--warning');
            }
          })
          .withFailureHandler(function(error) {
            hideInDocPreviewBar();
            showToast('Error: ' + error.message, 'error');
            if (forceBtn) {
              forceBtn.disabled = false;
              forceBtn.innerHTML = icon('trash', 'i--warning');
            }
          })
          .forceCleanPreview();
      }

      // Check if there's a pending in-doc preview on page load
      function checkPendingInDocPreview() {
        google.script.run
          .withSuccessHandler(function(hasPending) {
            if (hasPending) {
              showInDocPreviewBar(1); // Show bar, count unknown
              addMessage('system', icon('alertTriangle', 'i--warning') + ' Hi ha un preview pendent al document. Aplica o cancel·la els canvis.');
            }
          })
          .withFailureHandler(function(error) {
            console.log('[InDocPreview] Check failed:', error.message);
          })
          .hasPendingInDocPreview();
      }

      function applyTheme(isDark) {
        if (isDark) {
          document.documentElement.setAttribute('data-theme', 'dark');
        } else {
          document.documentElement.removeAttribute('data-theme');
        }
      }

      window.onload = function() {
        // Initialize theme
        initTheme();

        // v3.8: Check for pending in-document preview
        checkPendingInDocPreview();

        // v4.0: Initialize ban tooltip (Sprint 2)
        initBanTooltip();

        // Initialize mode selector
        initModeSelector();

        // v6.5: Initialize scroll listener for lazy loading messages
        initChatScrollListener();

        // v7.1: Mostrar landing inicial del xat
        showChatLanding();

        // Position nav pill
        updateNavPill();

        // Load settings
        google.script.run.withSuccessHandler(function(jsonStr) {
          currentSettings = JSON.parse(jsonStr);
          document.getElementById('licenseKey').value = currentSettings.license_key || '';
          document.getElementById('styleGuide').value = currentSettings.style_guide || '';
          document.getElementById('strictMode').checked = currentSettings.strict_mode || false;
          if (!currentSettings.license_key) {
            switchTab('brain');
          } else {
            // v5.1: Load credits if license is configured
            loadCredits();
          }
          // v12.4: Load BYOK settings
          initByokSettings();
        }).getSettings();

        // v2.8: Load banned words
        loadBannedWords();

        // v3.4: Load recipes
        loadRecipes();
        initRecipesView();

        // v4.1: Pre-load timeline in background
        preloadTimeline();

        // v14.8: Enter key handler for banned word input amb registre per cleanup
        const bannedWordInput = document.getElementById('newBannedWord');
        if (bannedWordInput) {
          const handleBannedWordEnter = function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              addBannedWord();
            }
          };
          registerListener(bannedWordInput, 'keydown', handleBannedWordEnter);
        }

        // Load file info
        google.script.run.withSuccessHandler(function(info) {
          if (info.hasFile) showFileStatus(info.name);
        }).getKnowledgeFileInfo();

        // v14.8: Enter key handler amb registre per cleanup
        const userInputEl = document.getElementById('userInput');
        const handleEnterKey = function(e) {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        };
        registerListener(userInputEl, 'keydown', handleEnterKey);

        // v14.8: Auto-resize textarea amb registre per cleanup
        const handleAutoResize = function() {
          this.style.height = 'auto';
          const newHeight = Math.min(Math.max(this.scrollHeight, 32), 120);
          this.style.height = newHeight + 'px';
        };
        registerListener(userInputEl, 'input', handleAutoResize);

        // v5.3: Polling intel·ligent per selecció (1s)
        selectionPollingActive = true;
        selectionRequestPending = false;

        function pollSelection() {
          if (!selectionPollingActive || selectionRequestPending) return;

          selectionRequestPending = true;
          google.script.run
            .withSuccessHandler(function(info) {
              selectionRequestPending = false;

              // v14.4: Si s'han netejat highlights, actualitzar UI de les anotacions
              if (info && info.highlightsCleared) {
                onHighlightsCleared();
              }

              // Chat indicator
              const indicator = document.getElementById('selectionIndicator');
              const preview = document.getElementById('selectionPreview');

              // v6.9: Recipes indicator (duplicate for proper positioning)
              const recipesIndicator = document.getElementById('recipesSelectionIndicator');
              const recipesPreview = document.getElementById('recipesSelectionPreview');
              const recipesWordCount = document.getElementById('recipesSelectionWordCount');

              // v8.2: Sempre visible - mostrar selecció o "Tot el document"
              const wordCountEl = document.getElementById('selectionWordCount');

              console.log('[Selection Poll]', info);

              if (info && info.hasSelection && info.textPreview) {
                // Hi ha selecció activa
                if (info.textPreview !== lastSelectionText) {
                  if (preview) preview.textContent = info.textPreview;
                  if (recipesPreview) recipesPreview.textContent = info.textPreview;
                  lastSelectionText = info.textPreview;

                  if (wordCountEl && info.wordCount) {
                    wordCountEl.textContent = '(' + info.wordCount + ' p)';
                  }
                  if (recipesWordCount && info.wordCount) {
                    recipesWordCount.textContent = '(' + info.wordCount + ' p)';
                  }
                }
                if (!hasActiveSelection) {
                  hasActiveSelection = true;
                  updateModeLabel();
                }
              } else {
                // No hi ha selecció - mostrar "Tot el document"
                const docText = info && info.docWordCount
                  ? 'Tot el document (' + info.docWordCount + ' p)'
                  : 'Tot el document';
                if (preview) preview.textContent = docText;
                if (recipesPreview) recipesPreview.textContent = docText;
                lastSelectionText = '__ALL_DOC__';

                // Amagar word count separat quan és "Tot el document"
                if (wordCountEl) wordCountEl.textContent = '';
                if (recipesWordCount) recipesWordCount.textContent = '';

                if (hasActiveSelection) {
                  hasActiveSelection = false;
                  updateModeLabel();
                }
              }

              // Sempre visible
              if (indicator) indicator.classList.remove('hidden');
              if (recipesIndicator) recipesIndicator.classList.remove('hidden');
            })
            .withFailureHandler(function() {
              selectionRequestPending = false;
            })
            .captureCurrentSelection();
        }

        // v9.0: Polling adaptatiu - 200ms quan usuari al document, 600ms normal
        let pollingInterval = 600;
        let pollingTimeoutId = null;
        const pollingIndicator = document.getElementById('pollingIndicator');
        const recipesPollingIndicator = document.getElementById('recipesPollingIndicator');

        function scheduleNextPoll() {
          pollingTimeoutId = setTimeout(function() {
            pollSelection();
            scheduleNextPoll();
          }, pollingInterval);
        }

        // Primera crida immediata i iniciar polling
        pollSelection();
        scheduleNextPoll();

        // v14.8: Handlers amb referència per cleanup
        const handlePollingBlur = function() {
          pollingInterval = 200;
          if (pollingIndicator) pollingIndicator.classList.add('fast');
          if (recipesPollingIndicator) recipesPollingIndicator.classList.add('fast');
          // Reiniciar amb nou interval
          clearTimeout(pollingTimeoutId);
          scheduleNextPoll();
        };

        const handlePollingFocus = function() {
          pollingInterval = 600;
          if (pollingIndicator) pollingIndicator.classList.remove('fast');
          if (recipesPollingIndicator) recipesPollingIndicator.classList.remove('fast');
        };

        // Pausar polling mentre escriu (però NO amagar l'indicador)
        let typingTimeout = null;
        const handleTypingPause = function() {
          selectionPollingActive = false;
          clearTimeout(typingTimeout);
          typingTimeout = setTimeout(function() {
            selectionPollingActive = true;
          }, 800); // Reprendre 0.8s després d'escriure
        };

        // v14.8: Registrar listeners amb cleanup
        registerListener(document, 'blur', handlePollingBlur);
        registerListener(document, 'focus', handlePollingFocus);
        registerListener(document.getElementById('userInput'), 'input', handleTypingPause);

        // Poll immediat quan l'usuari interactua amb el sidebar
        let lastImmediatePoll = 0;
        function triggerImmediatePoll() {
          const now = Date.now();
          // Throttle: mínim 150ms entre polls manuals
          if (now - lastImmediatePoll < 150) return;
          if (selectionRequestPending) return;
          lastImmediatePoll = now;
          pollSelection();
        }

        // v14.8: Detectar interaccions amb registre per cleanup
        const inputArea = document.getElementById('inputArea');
        if (inputArea) {
          registerListener(inputArea, 'mouseenter', triggerImmediatePoll);
        }
        registerListener(document.getElementById('userInput'), 'focus', triggerImmediatePoll);

        // v17.46: Netejar highlights del document amb qualsevol clic a la sidebar
        // (excepte si es clica el botó de l'ull que vol mostrar el highlight)
        registerListener(document, 'click', function(e) {
          // Ignorar si es clica el botó "veure" (ull)
          if (e.target.closest('.view-btn')) return;
          // Netejar TOTS els highlights del document
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            google.script.run.clearHighlight();
          }
        });

        // Select first icon
        selectIcon('zap');
      };

      // ═══════════════════════════════════════════════════════════
      // MODE SELECTOR
      // ═══════════════════════════════════════════════════════════

      function initModeSelector() {
        let savedMode = localStorage.getItem('docmile-mode') || 'edit';
        // Migrar usuaris antics de 'auto' a 'edit'
        if (savedMode === 'auto') savedMode = 'edit';
        selectMode(savedMode, false);

        // v14.8: Handlers amb referència per cleanup
        const handleDropdownClose = function(e) {
          const chatSelector = document.getElementById('modeSelector');
          const recipesSelector = document.getElementById('recipesModeSelector');
          if (chatSelector && !chatSelector.contains(e.target)) {
            chatSelector.classList.remove('open');
          }
          if (recipesSelector && !recipesSelector.contains(e.target)) {
            recipesSelector.classList.remove('open');
          }
        };

        const handleClearHighlights = function(e) {
          // Ignorar si es clica el botó "veure" (ull)
          if (e.target.closest('.view-btn')) return;
          // Netejar highlights del document
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            google.script.run.clearReferenceHighlights();
          }
        };

        // v14.8: Registrar amb cleanup
        registerListener(document, 'click', handleDropdownClose);
        registerListener(document, 'click', handleClearHighlights);
      }

      function toggleModeDropdown(source) {
        // v6.9: Support both chat and recipes selectors
        const chatSelector = document.getElementById('modeSelector');
        const recipesSelector = document.getElementById('recipesModeSelector');

        if (source === 'recipes') {
          recipesSelector.classList.toggle('open');
          chatSelector.classList.remove('open');
        } else {
          chatSelector.classList.toggle('open');
          if (recipesSelector) recipesSelector.classList.remove('open');
        }
      }

      function selectMode(mode, save = true) {
        currentMode = mode;

        // Update button display (both selectors)
        updateModeLabel();

        // Update selected state in ALL dropdowns
        document.querySelectorAll('.mode-option').forEach(function(opt) {
          opt.classList.remove('selected');
          if (opt.dataset.mode === mode) {
            opt.classList.add('selected');
          }
        });

        // Close both dropdowns
        document.getElementById('modeSelector').classList.remove('open');
        const recipesSelector = document.getElementById('recipesModeSelector');
        if (recipesSelector) recipesSelector.classList.remove('open');

        // Persist
        if (save) {
          localStorage.setItem('docmile-mode', mode);
        }
      }

      function getCurrentMode() {
        return currentMode;
      }

      // ═══════════════════════════════════════════════════════════
      // NAVIGATION
      // ═══════════════════════════════════════════════════════════

      function switchTab(tabName) {
        currentTab = tabName;

        // Update tabs (només si el tab existeix al nav)
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        const tabBtn = document.querySelector(`.tab[data-tab="${tabName}"]`);
        if (tabBtn) {
          tabBtn.classList.add('active');
        } else {
          // Si no hi ha tab al nav, mantenir "chat" actiu visualment
          const chatTab = document.querySelector('.tab[data-tab="chat"]');
          if (chatTab) chatTab.classList.add('active');
        }

        // Update panels
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        document.getElementById(tabName + 'Panel').classList.add('active');

        // Update pill position (només si hi ha tab actiu)
        if (tabBtn) updateNavPill();

        // Show/hide input area and chat selection indicator
        const inputArea = document.getElementById('inputArea');
        const selectionInd = document.getElementById('selectionIndicator');
        if (tabName === 'brain' || tabName === 'docs' || tabName === 'recipes' || tabName === 'structure' || tabName === 'timeline' || tabName === 'tables') {
          inputArea.classList.add('hidden');
          if (selectionInd) selectionInd.style.display = 'none';
        } else {
          inputArea.classList.remove('hidden');
          if (selectionInd) selectionInd.style.display = '';
        }

        // v3.9: Auto-refresh structure when opening structure panel
        if (tabName === 'structure') {
          if (typeof refreshStructure === 'function') {
            refreshStructure();
          }
        }

        // v3.9: Auto-refresh history when opening brain/settings panel
        if (tabName === 'brain') {
          if (typeof refreshHistory === 'function') {
            refreshHistory();
          }
        }

        // v5.1: Load knowledge library when opening docs panel
        if (tabName === 'docs') {
          if (typeof initKnowledgePanel === 'function') {
            initKnowledgePanel();
          }
        }

        // v4.1: Load timeline when opening timeline panel (uses cache if available)
        if (tabName === 'timeline') {
          if (typeof loadTimeline === 'function') {
            loadTimeline(false); // v8.1: Use cache, don't force refresh
          }
        }

        // v6.0: Auto-scan tables when opening tables panel
        if (tabName === 'tables') {
          if (typeof scanDocumentTables === 'function') {
            scanDocumentTables();
          }
        }
      }

      function updateNavPill() {
        const activeTab = document.querySelector('.tab.active');
        const pill = document.getElementById('navPill');
        if (activeTab && pill) {
          // Actualització immediata
          pill.style.width = activeTab.offsetWidth + 'px';
          pill.style.left = activeTab.offsetLeft + 'px';
          // Actualització després de la transició CSS del label (300ms)
          setTimeout(() => {
            pill.style.width = activeTab.offsetWidth + 'px';
            pill.style.left = activeTab.offsetLeft + 'px';
          }, 320);
        }
      }

      // ═══════════════════════════════════════════════════════════
      // CHAT HISTORY (Memory for v2.4)
      // ═══════════════════════════════════════════════════════════

      function getRecentHistory() {
        const messages = document.querySelectorAll('#chatHistory .msg');
        const history = [];

        messages.forEach(function(msg) {
          // Skip system messages, errors, and thinking indicators
          if (msg.classList.contains('system') ||
              msg.classList.contains('error') ||
              msg.classList.contains('thinking')) {
            return;
          }

          if (msg.classList.contains('user')) {
            // Get text - icons render as empty spans so innerText is clean
            let text = msg.innerText.trim();
            history.push({ role: 'user', text: text });
          } else if (msg.classList.contains('ai')) {
            // v3.3: Get text, removing entire edit badge block if present
            let text = msg.innerText.trim();

            // Remove complete badge line (Fet! + Desfer + Prohibir)
            // Note: Icons render as empty spans, so innerText has just button text
            text = text.replace(/^(Document modificat|Fet!)\s*(Desfer)?\s*(Prohibir)?\s*/i, '');

            // Also clean any remaining button artifacts
            text = text.replace(/^Desfer\s*/i, '');
            text = text.replace(/^Prohibir\s*/i, '');

            // Remove leading newlines
            text = text.replace(/^\s*\n+/, '').trim();

            if (text) {
              history.push({ role: 'model', text: text });
            }
          }
        });

        // Return last 12 messages (6 turns) for better context
        return history.slice(-12);
      }

      // ═══════════════════════════════════════════════════════════
      // CHAT
      // ═══════════════════════════════════════════════════════════

      // v3.7: Handler d'èxit per processUserCommand
      function handleSendSuccess(res) {
        // v6.9: Check if request was cancelled
        requestInProgress = false;
        if (requestCancelled) {
          requestCancelled = false;
          return; // Ignore response, UI already reset
        }

        hideThinking();
        document.getElementById('sendBtn').disabled = false;

        // v4.0: Handle auto-ban from NL detection (Sprint 3)
        if (res.auto_ban && res.auto_ban.length > 0) {
          processAutoBan(res.auto_ban);
        }

        // v11.0: Handle Preview Mode response with Unified Annotations
        // v12.1: Afegit suport per modification_type i find/replace per mode FIX
        // v14.1: Afegit suport per _status, _warn_reason i info de canvis bloquejats/stale
        if (res.status === 'preview' && res.changes && res.changes.length > 0) {
          // v14.1: Mostrar avís si hi ha canvis bloquejats o stale
          if (res._v14) {
            if (res._v14.staleChanges && res._v14.staleChanges.length > 0) {
              addBubble('system', icon('alertTriangle', 'i--sm i--warning') + ' ' + res._v14.staleChanges.length + ' canvi(s) no s\'han pogut aplicar perquè el document ha canviat.');
            }
            if (res._v14.blockedChanges && res._v14.blockedChanges.length > 0) {
              addBubble('system', icon('alertCircle', 'i--sm i--muted') + ' ' + res._v14.blockedChanges.length + ' canvi(s) han estat bloquejats per validació.');
            }
          }

          // Convertir changes a annotations per la nova UI unificada
          // v17.18: Debug - log raw change
          console.log('[v17.18] Raw changes from worker:', JSON.stringify(res.changes).substring(0, 500));
          const annotations = res.changes.map(function(c, i) {
            // v17.18: Log each change reason
            console.log('[v17.18] Change', i, 'reason:', c.reason, 'explanation:', c.explanation);
            return {
              id: c.id || ('change-' + i),
              type: 'change',
              para_id: parseInt(c.targetId !== undefined ? c.targetId : c.paragraph_id),
              // v16.3: Arreglat mapeig de camps - backend envia snake_case
              // v17.6: Netejar marcadors interns
              // v17.31: NO usar c.original com fallback - en mode FIX és el fragment, no el paràgraf!
              // original_text és SEMPRE el paràgraf complet
              originalText: cleanInternalMarkers(c.originalText || c.original_text || null),
              // v17.31: NO usar c.replacement com fallback - en mode FIX és el fragment, no el paràgraf!
              // v17.44: typeof check per preservar "" (eliminacions!)
              proposedText: cleanInternalMarkers(
                typeof c.proposedText === 'string' ? c.proposedText :
                typeof c.new_text === 'string' ? c.new_text : null
              ),
              // v12.1: Camps per mode FIX (find/replace natiu)
              // v17.7: NOMÉS usar c.find/c.replace - c.original és el paràgraf COMPLET, no el fragment
              // v17.39: Preservar strings buits per eliminacions (replace pot ser "")
              find: cleanInternalMarkers(typeof c.find === 'string' ? c.find : null),
              replace: cleanInternalMarkers(typeof c.replace === 'string' ? c.replace : null),
              // v16.6: Text exacte per highlight (sense context extra de Gemini)
              highlight_find: typeof c.highlight_find === 'string' ? c.highlight_find : null,
              highlight_replace: typeof c.highlight_replace === 'string' ? c.highlight_replace : null,
              context: c.context || null,
              reason: c.reason || c.explanation || 'Canvi proposat',
              status: 'pending',
              // v14.1: Camps de validació
              _status: c._status || 'OK',
              _warn_reason: c._warn_reason || null,
              _edit_distance: c._edit_distance || null,
            };
          });

          // v12.1: Passar modification_type per routing híbrid
          addBubbleWithAnnotations(res.ai_response, annotations, res.doc_snapshot, res.modification_type);
          if (res.credits !== undefined) {
            updateCredits(res.credits);
          }
          return;
        }

        // Handle preview with 0 changes (fallback - IDs didn't match)
        if (res.status === 'preview' && (!res.changes || res.changes.length === 0)) {
          addBubble('ai', res.ai_response, true);
          addBubble('system', icon('alertTriangle', 'i--sm i--warning') + ' No he pogut aplicar els canvis automàticament.');
          if (res.credits !== undefined) {
            updateCredits(res.credits);
          }
          return;
        }

        // v3.8: Handle In-Document Preview (Track Changes style)
        if (res.status === 'in_doc_preview') {
          const previewCount = res.changes_count || res.preview_info?.count || 1;
          addBubble('ai', res.ai_response, false);
          // v9.2: Nota de revisió just sota la bombolla AI, alineada esquerra
          addBubble('review-note', '<button class="inline-eye-btn" onclick="scrollToLastEdit(this)" title="Veure al document">' + icon('eye', 'i--sm i--accent') + '</button> Revisa els canvis al document.');
          showInDocPreviewBar(previewCount);
          if (res.credits !== undefined) {
            updateCredits(res.credits);
          }
          return;
        }

        // Handle in_doc_preview with error
        if (res.status === 'in_doc_preview_error') {
          addBubble('ai', res.ai_response, false);  // v10.2: false per no mostrar badge antic
          addBubble('system', icon('alertTriangle', 'i--sm i--warning') + ' ' + (res.preview_error || 'Error aplicant preview al document'));
          if (res.credits !== undefined) {
            updateCredits(res.credits);
          }
          return;
        }

        // v7.0: Handle Reference Highlight response
        if (res.status === 'reference_highlight' && res.highlights) {
          addBubbleWithReferences(res.ai_response, res.highlights);
          showToast(res.applied + ' paràgrafs marcats', 'success');
          if (res.credits !== undefined) {
            updateCredits(res.credits);
          }
          // v5.2: Queue message for save
          queueMessageForSave(lastSentMessage, res.ai_response, 'reference');
          return;
        }

        // v10.3: Handle Rewrite Preview (confirmació abans de reescriure)
        if (res.status === 'rewrite_preview') {
          addBubble('ai', res.ai_response, false);

          // Guardar dades del preview per a la confirmació
          window._pendingRewrite = {
            blocks: res.blocks,
            is_selection: res.is_selection,
            original_text: res.original_text,
            proposed_text: res.proposed_text
          };

          // Mostrar nota amb botons d'acceptar/cancel·lar
          const previewNote = `
            <div class="rewrite-preview-actions">
              <span>${icon('alertCircle', 'i--sm i--warning')} Es proposa reescriure ${res.is_selection ? 'la selecció' : 'el document'}.</span>
              <div class="preview-buttons">
                <button class="btn-accept-rewrite" onclick="acceptRewrite()" title="Aplicar canvis">
                  ${icon('check', 'i--sm')} Acceptar
                </button>
                <button class="btn-cancel-rewrite" onclick="cancelRewrite()" title="Descartar canvis">
                  ${icon('x', 'i--sm')} Cancel·lar
                </button>
                <button class="btn-diff-rewrite" onclick="showRewriteDiff()" title="Veure diferències">
                  ${icon('eye', 'i--sm')} Diferències
                </button>
              </div>
            </div>
          `;
          addBubble('review-note', previewNote);

          if (res.credits !== undefined) {
            updateCredits(res.credits);
          }
          return;
        }

        // Normal response handling (chat mode or fallback)
        // v10.2: No mostrar badge antic - ara tot passa per preview
        addBubble('ai', res.ai_response, false);

        // v14.3: Mostrar botó de suggested_followup si existeix
        if (res.suggested_followup && res.suggested_followup.available) {
          const followupHtml = `
            <div class="suggested-followup">
              <button class="btn-followup" onclick="handleFollowup('${res.suggested_followup.would_become_mode}')">
                ${icon('zap', 'i--sm')} ${res.suggested_followup.prompt}
              </button>
            </div>
          `;
          addBubble('followup', followupHtml);
        }

        // v10.0: Activar Pantalla Interactiva si hi ha referències [[§ID]]
        if (res.mode === 'chat' && res.ai_response) {
          triggerInteractiveScreen(res.ai_response);
        }

        // v3.7: Log estadístiques d'edició per debugging
        if (res.edit_stats) {
          console.log('[Edit Stats]', res.edit_stats);
          // Si hi ha problemes, mostrar-ho a la consola
          if (res.edit_stats.skipped > 0 || res.edit_stats.errors > 0) {
            console.warn('[Edit Warning]', {
              skipped: res.edit_stats.skipped,
              errors: res.edit_stats.errors,
              duration: res.edit_stats.duration_ms + 'ms'
            });
          }
        }

        if (res.credits !== undefined) {
          updateCredits(res.credits);
        }
        // v4.0: Confirm hash after successful edit
        if (res.mode === 'edit' && res.event_id) {
          confirmEditHashAsync(res.event_id);
        }
        // v2.5: Check and show structure hint (one-time)
        checkAndShowStructureHint();

        // v5.2: Queue message for debounced save
        queueMessageForSave(lastSentMessage, res.ai_response, res.mode);
      }

      // ═══════════════════════════════════════════════════════════
      // v5.2: DEBOUNCED SAVE SYSTEM
      // ═══════════════════════════════════════════════════════════

      function showSaveIndicator(state) {
        // v14.1: Silent save - no text shown to user (just logs)
        console.log('[v5.2] showSaveIndicator:', state);
        const indicator = document.getElementById('saveIndicator');
        if (!indicator) return;

        // Keep class for potential CSS styling but no text
        indicator.className = 'save-indicator ' + state;
        indicator.textContent = '';
      }

      function queueMessageForSave(userMessage, aiResponse, mode) {
        console.log('[v5.2] queueMessageForSave called:', { userMessage: userMessage?.substring(0, 50), mode });
        if (!userMessage) return;

        const now = new Date().toISOString();
        pendingSaveMessages.push({
          id: 'msg_' + Date.now() + '_u',
          role: 'user',
          content: userMessage,
          timestamp: now
        });
        pendingSaveMessages.push({
          id: 'msg_' + Date.now() + '_a',
          role: 'ai',
          content: aiResponse,
          timestamp: now,
          metadata: { mode: mode || 'chat' }
        });

        // Clear the stored message
        lastSentMessage = null;

        // Debounce the save
        if (saveDebounceTimer) {
          clearTimeout(saveDebounceTimer);
        }

        showSaveIndicator('saving');

        saveDebounceTimer = setTimeout(() => {
          flushPendingMessages();
        }, SAVE_DEBOUNCE_MS);
      }

      async function flushPendingMessages() {
        console.log('[v5.2] flushPendingMessages, pending:', pendingSaveMessages.length);
        if (pendingSaveMessages.length === 0) {
          showSaveIndicator('');
          return;
        }

        const messagesToSave = [...pendingSaveMessages];
        pendingSaveMessages = [];
        saveDebounceTimer = null;

        // Get license key for API calls
        if (!currentSettings.license_key) {
          console.warn('[v5.2] No license key, skipping save');
          showSaveIndicator('');
          return;
        }

        try {
          if (!currentConversationId) {
            // v9.5: Create with provisional title, AI will generate real title later
            const firstUserMsg = messagesToSave.find(m => m.role === 'user');

            // v9.1: No crear conversa si no hi ha missatges d'usuari
            if (!firstUserMsg) {
              console.log('[v9.1] No user messages, skipping conversation creation');
              showSaveIndicator('');
              return;
            }

            const title = 'Nova conversa'; // Provisional, AI generates real title after 2+ messages

            console.log('[v5.2] Creating conversation:', title);

            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .callWorker({
                  action: 'create_conversation',
                  license_key: currentSettings.license_key,
                  title: title,
                  messages: messagesToSave
                });
            });

            console.log('[v5.2] Create result:', result);

            if (result && result.conversation_id) {
              currentConversationId = result.conversation_id;
              conversationMessageCount = messagesToSave.length;
              console.log('[Conversation] Created with ID:', result.conversation_id, 'Title:', title, 'Messages:', conversationMessageCount);
              updateConversationTitle(title);

              // v10.2: Trigger auto-title after creation
              // Delay 5s to ensure Supabase has saved the conversation
              if (conversationMessageCount >= 2) {
                setTimeout(function() {
                  console.log('[Conversation] Triggering auto-title with', conversationMessageCount, 'messages');
                  triggerAutoTitle();
                }, 5000);
              }

              // Add to local list instead of reloading
              if (conversationsLoaded) {
                const newConv = {
                  id: result.conversation_id,
                  title: title,
                  preview: messagesToSave[0]?.content?.substring(0, 80) || '',
                  message_count: messagesToSave.length,
                  pinned: false,
                  created_at: new Date().toISOString(),
                  updated_at: new Date().toISOString()
                };
                conversationsList.unshift(newConv);
                renderConversationsList(conversationsList);
              }
              showSaveIndicator('saved');
            } else {
              console.warn('[v5.2] No conversation_id in result:', result);
              showSaveIndicator('error');
            }
          } else {
            // Append to existing conversation
            console.log('[v5.2] Appending to:', currentConversationId);

            const result = await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .callWorker({
                  action: 'append_messages',
                  license_key: currentSettings.license_key,
                  conversation_id: currentConversationId,
                  messages: messagesToSave
                });
            });

            console.log('[v5.2] Append result:', result);

            conversationMessageCount += messagesToSave.length;
            console.log('[Conversation] Message count now:', conversationMessageCount);

            // Trigger auto-title after first AI response (2 messages = 1 turn)
            if (conversationMessageCount === 2) {
              console.log('[Conversation] Triggering auto-title (2 messages reached)');
              triggerAutoTitle();
            }
            showSaveIndicator('saved');
          }

        } catch (e) {
          console.error('[Conversation Save Error]', e);
          showSaveIndicator('error');
          // Re-queue failed messages for retry
          pendingSaveMessages = [...messagesToSave, ...pendingSaveMessages];
        }
      }

      // v14.8: Save on page unload i cleanup de listeners
      window.addEventListener('beforeunload', function() {
        // Guardar missatges pendents
        if (pendingSaveMessages.length > 0) {
          flushPendingMessages();
        }
        // Cleanup de tots els listeners registrats per evitar memory leaks
        cleanupAllListeners();
      });

      // ═══════════════════════════════════════════════════════════
      // v5.2: AUTO-TITLE GENERATION
      // ═══════════════════════════════════════════════════════════

      function triggerAutoTitle() {
        console.log('[Auto-title] Triggering...', {
          conversationId: currentConversationId,
          hasLicense: !!currentSettings.license_key
        });

        if (!currentConversationId) {
          console.warn('[Auto-title] No conversation ID, skipping');
          return;
        }
        if (!currentSettings.license_key) {
          console.warn('[Auto-title] No license key, skipping');
          return;
        }

        google.script.run
          .withSuccessHandler(function(res) {
            console.log('[Auto-title] Response:', res);
            if (res.status === 'ok' && res.generated && res.title) {
              console.log('[Auto-title] Updating title to:', res.title);
              updateConversationTitle(res.title);
              // Update in list too
              const conv = conversationsList.find(c => c.id === currentConversationId);
              if (conv) {
                conv.title = res.title;
                renderConversationsList(conversationsList);
              }
            } else {
              console.warn('[Auto-title] Not generated:', res);
            }
          })
          .withFailureHandler(function(err) {
            console.error('[Auto-title Error]', err);
          })
          .callWorker({
            action: 'generate_title',
            license_key: currentSettings.license_key,
            conversation_id: currentConversationId
          });
      }

      // ═══════════════════════════════════════════════════════════
      // v5.2: TITLE EDITING
      // ═══════════════════════════════════════════════════════════

      function editCurrentTitle() {
        if (!currentConversationId) return;

        const titleEl = document.getElementById('chatCurrentTitle');
        const currentTitle = titleEl.textContent;

        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentTitle;
        input.className = 'chat-current-title-input';

        input.onblur = function() {
          saveCurrentTitle(input.value);
        };

        input.onkeydown = function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
          } else if (e.key === 'Escape') {
            titleEl.textContent = currentTitle;
            titleEl.style.display = '';
            input.remove();
          }
        };

        titleEl.style.display = 'none';
        titleEl.parentNode.insertBefore(input, titleEl);
        input.focus();
        input.select();
      }

      function saveCurrentTitle(newTitle) {
        const titleEl = document.getElementById('chatCurrentTitle');
        const input = titleEl.parentNode.querySelector('.chat-current-title-input');

        if (!newTitle || !newTitle.trim()) {
          titleEl.style.display = '';
          if (input) input.remove();
          return;
        }

        newTitle = newTitle.trim();

        if (currentSettings.license_key) {
          google.script.run
            .withSuccessHandler(function(res) {
              if (res.status === 'ok') {
                titleEl.textContent = newTitle;
                // Update in list
                const conv = conversationsList.find(c => c.id === currentConversationId);
                if (conv) {
                  conv.title = newTitle;
                  renderConversationsList(conversationsList);
                }
              }
            })
            .withFailureHandler(function(err) {
              console.error('[Title Save Error]', err);
              showToast('Error guardant títol', 'error');
            })
            .callWorker({
              action: 'update_conversation',
              license_key: currentSettings.license_key,
              conversation_id: currentConversationId,
              title: newTitle
            });
        }

        titleEl.textContent = newTitle;
        titleEl.style.display = '';
        if (input) input.remove();
      }

      function editTitleInline(convId, element, event) {
        event.stopPropagation();

        const currentTitle = element.textContent;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentTitle;
        input.className = 'conversation-title-input';

        input.onblur = function() {
          saveTitleInline(convId, input.value, element);
        };

        input.onkeydown = function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
          } else if (e.key === 'Escape') {
            element.textContent = currentTitle;
            element.style.display = '';
            input.remove();
          }
        };

        input.onclick = function(e) {
          e.stopPropagation();
        };

        element.style.display = 'none';
        element.parentNode.insertBefore(input, element);
        input.focus();
        input.select();
      }

      function saveTitleInline(convId, newTitle, element) {
        const input = element.parentNode.querySelector('.conversation-title-input');

        if (!newTitle || !newTitle.trim()) {
          element.style.display = '';
          if (input) input.remove();
          return;
        }

        newTitle = newTitle.trim();

        if (currentSettings.license_key) {
          google.script.run
            .withSuccessHandler(function(res) {
              if (res.status === 'ok') {
                const conv = conversationsList.find(c => c.id === convId);
                if (conv) {
                  conv.title = newTitle;
                }
                // Update header if this is current conversation
                if (convId === currentConversationId) {
                  updateConversationTitle(newTitle);
                }
              }
            })
            .withFailureHandler(function(err) {
              console.error('[Title Save Error]', err);
            })
            .callWorker({
              action: 'update_conversation',
              license_key: currentSettings.license_key,
              conversation_id: convId,
              title: newTitle
            });
        }

        element.textContent = newTitle;
        element.style.display = '';
        if (input) input.remove();
      }

      // ═══════════════════════════════════════════════════════════
      // v5.2: PIN/UNPIN TOGGLE
      // ═══════════════════════════════════════════════════════════

      function togglePin(convId, event) {
        event.stopPropagation();

        const conv = conversationsList.find(c => c.id === convId);
        if (!conv) return;

        if (!currentSettings.license_key) return;

        const newPinned = !conv.pinned;

        google.script.run
          .withSuccessHandler(function(res) {
            if (res.status === 'ok') {
              conv.pinned = newPinned;
              // Re-sort: pinned first
              conversationsList.sort((a, b) => {
                if (a.pinned && !b.pinned) return -1;
                if (!a.pinned && b.pinned) return 1;
                return new Date(b.updated_at) - new Date(a.updated_at);
              });
              renderConversationsList(conversationsList);
              showToast(newPinned ? 'Conversa fixada' : 'Conversa desfixada', 'success');
            }
          })
          .withFailureHandler(function(err) {
            console.error('[Pin Error]', err);
          })
          .callWorker({
            action: 'update_conversation',
            license_key: currentSettings.license_key,
            conversation_id: convId,
            pinned: newPinned
          });
      }

      // v3.7: Handler d'error per processUserCommand
      function handleSendFailure(err) {
        // v6.9: Check if request was cancelled
        requestInProgress = false;
        if (requestCancelled) {
          requestCancelled = false;
          return; // Ignore error, UI already reset
        }

        hideThinking();
        document.getElementById('sendBtn').disabled = false;
        // Handle expired knowledge file error
        if (err.message && err.message.includes('KNOWLEDGE_FILE_EXPIRED')) {
          addBubble('error', icon('alertTriangle', 'i--sm i--warning') + ' El fitxer de coneixement ha expirat. <button onclick="clearKnowledgeFileAndRetry()" style="margin-left:8px;padding:4px 8px;background:var(--accent);color:white;border:none;border-radius:4px;cursor:pointer;">Esborrar fitxer</button>');
        } else {
          addBubble('error', 'Error: ' + err.message);
        }
      }

      // v5.0: Temp storage for last sent message (for conversation save)
      let lastSentMessage = null;

      /**
       * v14.3: Handle suggested followup action
       * Envia una instrucció automàtica per aplicar l'acció suggerida
       */
      function handleFollowup(mode) {
        // Construir instrucció segons el mode
        let instruction = '';
        if (mode === 'REWRITE') {
          instruction = 'Sí, escurça el document aplicant el resum';
        } else if (mode === 'UPDATE_BY_ID') {
          instruction = 'Sí, aplica els canvis proposats';
        } else {
          instruction = 'Sí, aplica-ho';
        }

        // Enviar com a missatge de l'usuari
        addBubble('user', instruction, false);
        showThinking();

        google.script.run
          .withSuccessHandler(handleSendSuccess)
          .withFailureHandler(handleSendFailure)
          .processUserCommand(instruction, getRecentHistory(), 'edit', true, []);
      }

      function sendMessage() {
        const input = document.getElementById('userInput');
        const text = input.value.trim();

        // v8.0: Allow sending file without text, or text without file
        if (!text && !pendingAttachment) return;

        // v10.2: Desactivar botó Desfer de canvis anteriors
        disablePendingUndo();

        // v11.1: Auto-netejar marcatges anteriors (silent)
        clearAllHighlights(true);

        // v7.1: Amagar landing quan s'envia missatge
        hideChatLanding();

        // v5.0: Store message for later saving to conversation
        lastSentMessage = text;

        // v5.3: Capturar selecció actual per mostrar badge
        const selectionBadge = lastSelectionText || null;

        // v8.0: If there's a pending attachment, add it to session files
        if (pendingAttachment) {
          sessionFiles.push(pendingAttachment);
          updateSessionFilesBar();
        }

        // v8.0: Build message HTML with file bubble (only for new attachment) + text
        let messageHtml = '';

        // Add file bubble only if there's a new attachment this message
        if (pendingAttachment) {
          messageHtml += createFileBubbleHtml(pendingAttachment);
        }

        // Add text message
        if (text) {
          const sanitizedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
          messageHtml += '<div class="user-text">' + sanitizedText + '</div>';
        }

        // v8.0: Use addBubbleHtml for file+text messages
        if (pendingAttachment) {
          addBubbleHtml('user', messageHtml, selectionBadge, text);
        } else {
          addBubble('user', text, false, null, selectionBadge);
        }

        input.value = '';
        input.style.height = 'auto';

        // v5.3: Amagar indicador després d'enviar
        const indicator = document.getElementById('selectionIndicator');
        if (indicator) indicator.classList.add('hidden');

        const btn = document.getElementById('sendBtn');
        btn.disabled = true;

        // v6.9: Track request state for ESC cancellation
        requestInProgress = true;
        requestCancelled = false;

        // v8.0: Prepare ALL session files for backend (persistent throughout session)
        const attachmentsToSend = sessionFiles.map(function(att) {
          return {
            name: att.name,
            size: att.size,
            type: att.type,
            content: att.content,
            text: att.text || null
          };
        });

        // v8.0: Clear pending attachment and hide preview (files stay in sessionFiles)
        pendingAttachment = null;
        hideChatAttachmentPreview();

        showThinking();

        google.script.run
          .withSuccessHandler(handleSendSuccess)
          .withFailureHandler(handleSendFailure)
          .processUserCommand(text, getRecentHistory(), getCurrentMode(), previewModeEnabled, attachmentsToSend);
      }

      // ═══════════════════════════════════════════════════════════
      // MARKDOWN RENDERER (v6.5)
      // ═══════════════════════════════════════════════════════════

      /**
       * Lightweight markdown parser for AI responses
       * Supports: code blocks, inline code, bold, italic, lists, links, blockquotes
       */
      function renderMarkdown(text) {
        if (!text) return '';

        // 1. Escape HTML first (security)
        let html = text
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

        // 2. Code blocks (```) - process first to avoid conflicts
        html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, function(match, lang, code) {
          const langClass = lang ? ' class="language-' + lang + '"' : '';
          return '<pre class="md-pre"><code' + langClass + '>' + code.trim() + '</code></pre>';
        });

        // 3. Inline code (`)
        html = html.replace(/`([^`]+)`/g, '<code class="md-inline-code">$1</code>');

        // ═══════════════════════════════════════════════════════════════
        // v14.5.3: LLISTES PRIMER - Abans de bold/italic per evitar interferències
        // ═══════════════════════════════════════════════════════════════

        // Normalitzar formats alternatius de llista
        html = html.replace(/^\(\-\) /gm, '- ');  // (-) → -
        html = html.replace(/^\(•\) /gm, '- ');   // (•) → -
        html = html.replace(/^• /gm, '- ');       // • → -

        // Treure bold/italic dels bullets ABANS de processar
        // **- text** → - **text**  i  *- text* → - *text*
        html = html.replace(/^\*\*- /gm, '- **');
        html = html.replace(/^\*- /gm, '- *');
        html = html.replace(/^__- /gm, '- __');
        html = html.replace(/^_- /gm, '- _');

        // Assegurar salt de línia abans de bullets inline
        // "text:- item" → "text:\n- item"
        // "text.- item" → "text.\n- item"
        // "text - item" al principi d'una llista → "text\n- item"
        html = html.replace(/([:\.])\s*- /g, '$1\n- ');
        html = html.replace(/([^\n\-])\n?\s*- (?=[A-Z]|[a-z])/g, function(match, before) {
          // Si el caràcter anterior no és un salt de línia, afegir-lo
          if (before !== '\n') return before + '\n- ';
          return match;
        });

        // Normalitzar espais inicials
        html = html.replace(/^[ \t]+([\-\*] )/gm, '$1');

        // Processar llistes no ordenades
        html = html.split('\n').map(function(line) {
          const match = line.match(/^\s*([\-\*]) (.+)$/);
          if (match) {
            return '<li class="md-li">' + match[2] + '</li>';
          }
          return line;
        }).join('\n');
        html = html.replace(/(<li class="md-li">.*<\/li>\n?)+/g, '<ul class="md-list">$&</ul>');

        // Processar llistes ordenades
        html = html.replace(/^\d+\. (.+)$/gm, '<li class="md-li-num">$1</li>');
        html = html.replace(/(<li class="md-li-num">.*<\/li>\n?)+/g, '<ol class="md-list-num">$&</ol>');

        // Netejar newlines dins de llistes
        html = html.replace(/<\/li>\n<li/g, '</li><li');
        html = html.replace(/<ul class="md-list">\n/g, '<ul class="md-list">');
        html = html.replace(/\n<\/ul>/g, '</ul>');
        html = html.replace(/<ol class="md-list-num">\n/g, '<ol class="md-list-num">');
        html = html.replace(/\n<\/ol>/g, '</ol>');

        // ═══════════════════════════════════════════════════════════════
        // FORMATACIÓ DE TEXT - Després de llistes
        // ═══════════════════════════════════════════════════════════════

        // 4. Bold (**text** or __text__)
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');

        // 5. Italic (*text* or _text_) - careful not to conflict with bold
        html = html.replace(/(?<!\*)\*(?!\*)([^*]+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');
        html = html.replace(/(?<!_)_(?!_)([^_]+?)(?<!_)_(?!_)/g, '<em>$1</em>');

        // 6. Strikethrough (~~text~~)
        html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');

        // 7. Headers (## ## ###) - only h4-h6 to not break layout
        html = html.replace(/^#### (.+)$/gm, '<h6 class="md-header">$1</h6>');
        html = html.replace(/^### (.+)$/gm, '<h5 class="md-header">$1</h5>');
        html = html.replace(/^## (.+)$/gm, '<h4 class="md-header">$1</h4>');

        // 10. Links [text](url) - only safe HTTPS URLs
        html = html.replace(/\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g,
          '<a href="$2" target="_blank" rel="noopener noreferrer" class="md-link">$1</a>');

        // 11. Blockquotes (&gt; text - already escaped)
        html = html.replace(/^&gt; (.+)$/gm, '<blockquote class="md-quote">$1</blockquote>');

        // 12. Horizontal rule (---)
        html = html.replace(/^---+$/gm, '<hr class="md-hr">');

        // 13. Line breaks
        html = html.replace(/\n\n/g, '</p><p class="md-para">');
        html = html.replace(/\n/g, '<br>');

        // 14. Wrap in paragraph if no block elements
        if (!html.includes('<p') && !html.includes('<pre') && !html.includes('<ul') &&
            !html.includes('<ol') && !html.includes('<h') && !html.includes('<blockquote')) {
          html = '<p class="md-para">' + html + '</p>';
        }

        // 15. v6.8: Document References - [[text]] → text destacat (botó a cantonada)
        const refResult = parseDocumentReferences(html);

        return { html: refResult.html, firstRef: refResult.firstRef };
      }

      // Wrapper per compatibilitat - retorna només HTML
      function renderMarkdownHtml(text) {
        const result = renderMarkdown(text);
        return typeof result === 'object' ? result.html : result;
      }

      /**
       * v12.1: Parseja referències [[§ID]] i [[text]]
       * Format [[§ID]] → Link clicable que navega al paràgraf ID
       * Format [[text]] → Text destacat (compatibilitat 6.8)
       * @param {string} html - HTML amb possibles referències
       * @returns {Object} - { html: string, firstRef: string|null }
       */
      function parseDocumentReferences(html) {
        let firstRef = null;

        // v13.1: Primer processar [[§ID|text]] - format làser de precisió
        // Pattern tolerant: [[ §número | text_exacte ]] (espais opcionals)
        const laserRefPattern = /\[\[\s*§(\d+)\s*\|\s*(.+?)\s*\]\]/g;

        let result = html.replace(laserRefPattern, function(match, paraNum, textSnippet) {
          const paraId = parseInt(paraNum, 10) - 1; // Convertir a 0-indexed
          if (!firstRef) {
            firstRef = '__LASER_' + paraId + '_' + textSnippet + '__';
          }
          // Escapar cometes per a l'onclick
          const safeText = textSnippet
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/"/g, '&quot;');
          // v13.0: Xip làser que mostra el TEXT i ressalta precisament
          return '<span class="doc-ref-laser" onclick="focusLaserElement(' + paraId + ', \'' + safeText + '\')" ' +
                 'title="Anar a §' + paraNum + ': ' + textSnippet.substring(0, 30) + (textSnippet.length > 30 ? '...' : '') + '">' +
                 escapeHtmlSafe(textSnippet) + '</span>';
        });

        // v13.0: Fallback per format antic [[§ID]] sense text
        const oldRefPattern = /\[\[§(\d+)\]\](?!\|)/g;

        result = result.replace(oldRefPattern, function(match, paraNum) {
          const paraId = parseInt(paraNum, 10) - 1;
          if (!firstRef) {
            firstRef = '__PARA_' + paraId + '__';
          }
          // Xip clàssic que ressalta tot el paràgraf
          return '<span class="doc-ref-chip" onclick="focusLaserElement(' + paraId + ', null)" ' +
                 'title="Anar al paràgraf ' + paraNum + '">' +
                 '§' + paraNum + '</span>';
        });

        // v6.8: Després processar [[text]] - text literal per buscar
        const textRefPattern = /\[\[([^\]§]+)\]\]/g;

        result = result.replace(textRefPattern, function(match, searchText) {
          if (!firstRef) {
            firstRef = searchText;
          }
          // Mostrar text destacat (sense link, el botó de cantonada navegarà)
          return '<span class="doc-ref-text">' + searchText + '</span>';
        });

        return { html: result, firstRef: firstRef };
      }

      /**
       * v12.1: Navega a un paràgraf pel seu ID (0-indexed)
       * Crida a Apps Script per fer scroll al paràgraf
       * @param {number} paraId - ID del paràgraf (0-indexed)
       */
      function navigateToParagraph(paraId) {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              showToast('Navegant a §' + (paraId + 1), 'success');
              // Auto-clear highlight després de 2.5s
              setTimeout(function() {
                google.script.run.clearHighlight();
              }, 2500);
            } else {
              showToast(result?.error || 'Paràgraf no trobat', 'error');
            }
          })
          .withFailureHandler(function(error) {
            showToast('Error: ' + error.message, 'error');
          })
          .scrollToParagraph(paraId);
      }

      function addBubble(type, text, isEdit, lastEditWord, selectionBadge) {
        const container = document.getElementById('chatHistory');
        const bubble = document.createElement('div');
        bubble.className = 'msg ' + type;

        // v3.3: Funció per escapar HTML i permetre salts de línia
        function sanitizeText(t) {
          const div = document.createElement('div');
          div.textContent = t;
          return div.innerHTML.replace(/\n/g, '<br>');
        }

        // v5.3: Badge de selecció per missatges d'usuari
        // v9.2: Icona d'abast i "Tot el document" en lloc de "__ALL_DOC__"
        let selectionHtml = '';
        if (type === 'user' && selectionBadge) {
          const badgeText = selectionBadge === '__ALL_DOC__' ? 'Tot el document' : sanitizeText(selectionBadge);
          selectionHtml = '<div class="selection-badge">' +
            '<span class="i i--xs i--accent"><svg viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg></span>' +
            '<span class="selection-badge-text">' + badgeText + '</span></div>';
        }

        if (type === 'ai' && isEdit) {
          // v6.8: Renderitzar markdown i obtenir referència
          const mdResult = renderMarkdown(text);
          const mdHtml = typeof mdResult === 'object' ? mdResult.html : mdResult;
          const firstRef = typeof mdResult === 'object' ? mdResult.firstRef : null;

          // v6.8: Eye button amb referència o lastEdit (isEdit=true)
          const eyeBtn = createEyeButton(firstRef, true);

          let badgeHtml = '<div class="edit-badge">' + icon('check', 'i--sm i--success') + ' Fet!';
          if (lastEditWord) {
            badgeHtml += '<button class="ban-word-btn" onclick="addToBannedFromChat(\'' +
              lastEditWord.replace(/'/g, "\\'") + '\')" title="No usar mai aquesta paraula">' +
              icon('ban', 'i--error i--sm') + ' Prohibir</button>';
          }
          badgeHtml += '</div>';

          bubble.innerHTML = eyeBtn + badgeHtml + '<div class="md-content">' + mdHtml + '</div>';
          if (firstRef) bubble.dataset.docRef = firstRef;

        } else if (type === 'ai') {
          // v6.8: AI responses with markdown rendering
          const mdResult = renderMarkdown(text);
          const mdHtml = typeof mdResult === 'object' ? mdResult.html : mdResult;

          // v9.5: No mostrar ull quan no hi ha edicions (només text de xat)
          bubble.innerHTML = '<div class="md-content">' + mdHtml + '</div>';

        } else if (type === 'error' || type === 'system') {
          bubble.innerHTML = text;
        } else if (type === 'review-note') {
          // v9.2: Nota de revisió alineada esquerra, sense marges extres
          bubble.innerHTML = text;
        } else if (type === 'user') {
          const saveBtn = '<button class="save-prompt-btn" onclick="saveAsRecipe(this)" title="Desar com a recepta">' +
            icon('save', 'i--xs') + '</button>';
          bubble.innerHTML = (selectionBadge ? selectionHtml : '') +
            '<div class="user-text">' + sanitizeText(text) + '</div>' + saveBtn;
          bubble.dataset.prompt = text;
        }

        container.appendChild(bubble);
        container.scrollTop = container.scrollHeight;
      }

      /**
       * v6.8: Crea el botó d'ull per la cantonada
       * @param {string|null} docRef - Referència al document
       * @param {boolean} isEdit - Si és una edició (sempre mostrar per navegar a lastEdit)
       * @returns {string} HTML del botó o string buit si no cal mostrar
       */
      function createEyeButton(docRef, isEdit) {
        if (docRef) {
          // Hi ha referència explícita al document
          const escaped = docRef.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
          return '<button class="bubble-eye-btn" onclick="navigateToReference(this, \'' + escaped + '\')" title="Mostrar al document">' +
            '<svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>' +
            '</button>';
        } else if (isEdit) {
          // És una edició - mostrar per navegar a l'última edició
          return '<button class="bubble-eye-btn" onclick="scrollToLastEdit(this)" title="Veure al document">' +
            '<svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>' +
            '</button>';
        }
        // No hi ha referència ni és edició - no mostrar botó
        return '';
      }

      /**
       * v6.8: Navega a una referència del document amb feedback visual
       * Auto-clear del highlight després de 2.5 segons
       */
      function navigateToReference(btn, searchText) {
        btn.classList.add('loading');

        google.script.run
          .withSuccessHandler(function(result) {
            btn.classList.remove('loading');
            if (result.success) {
              btn.classList.add('success');
              setTimeout(function() { btn.classList.remove('success'); }, 1500);
              // Auto-clear highlight after 2.5s
              setTimeout(function() {
                google.script.run.clearHighlight();
              }, 2500);
            } else {
              showToast(result.error || 'No trobat', 'error');
            }
          })
          .withFailureHandler(function(error) {
            btn.classList.remove('loading');
            showToast('Error: ' + error.message, 'error');
          })
          .highlightElement({ mode: 'text', value: searchText });
      }

      // v8.0: Add bubble with raw HTML content (for file attachments)
      function addBubbleHtml(type, html, selectionBadge, promptText) {
        const container = document.getElementById('chatHistory');
        const bubble = document.createElement('div');
        bubble.className = 'msg ' + type;

        // Selection badge for user messages
        // v9.2: Icona d'abast i "Tot el document" en lloc de "__ALL_DOC__"
        let selectionHtml = '';
        if (type === 'user' && selectionBadge) {
          const badgeText = selectionBadge === '__ALL_DOC__' ? 'Tot el document' : selectionBadge.replace(/</g, '&lt;').replace(/>/g, '&gt;');
          selectionHtml = '<div class="selection-badge">' +
            '<span class="i i--xs i--accent"><svg viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg></span>' +
            '<span class="selection-badge-text">' + badgeText + '</span></div>';
        }

        // v6.7: Save button for user messages
        let saveBtn = '';
        if (type === 'user' && promptText) {
          saveBtn = '<button class="save-prompt-btn" onclick="saveAsRecipe(this)" title="Desar com a recepta">' +
            icon('save', 'i--xs') + '</button>';
          bubble.dataset.prompt = promptText;
        }

        bubble.innerHTML = selectionHtml + html + saveBtn;
        container.appendChild(bubble);
        container.scrollTop = container.scrollHeight;
      }

      // ═══════════════════════════════════════════════════════════
      // v7.0: REFERENCE HIGHLIGHTING FUNCTIONS
      // ═══════════════════════════════════════════════════════════

      /**
       * Renderitza una resposta amb referències clicables
       * @param {string} aiResponse - Text de resposta
       * @param {Array} highlights - Array de highlights
       */
      function addBubbleWithReferences(aiResponse, highlights) {
        const container = document.getElementById('chatHistory');
        const bubble = document.createElement('div');
        bubble.className = 'msg ai';

        // Renderitzar resposta principal amb markdown (usar renderMarkdownHtml que retorna string)
        let html = '<div class="md-content">' + renderMarkdownHtml(aiResponse) + '</div>';

        // Afegir secció de referències
        if (highlights && highlights.length > 0) {
          html += '<div class="reference-list">';

          for (const hl of highlights) {
            // v14.6: Usar renderHighlightAnnotation per suportar actionables
            html += renderHighlightAnnotation(hl);
          }

          html += '</div>';
          // v11.1: Botó eliminat - auto-clear quan s'envia nou missatge
        }

        bubble.innerHTML = html;
        container.appendChild(bubble);
        container.scrollTop = container.scrollHeight;
      }

      /**
       * Escapa HTML per evitar XSS
       */
      function escapeHtmlSafe(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
      }

      /**
       * v17.6: Neteja marcadors interns (⟦SEL⟧) del text
       */
      function cleanInternalMarkers(text) {
        if (!text) return text;
        return text.replace(/⟦SEL⟧\s*/g, '');
      }

      /**
       * Scroll al document i destacar referència
       */
      function scrollToDocReference(paraId, color) {
        showToast('Navegant al paràgraf...', 'info');

        google.script.run
          .withSuccessHandler(function(result) {
            console.log('[scrollToReference] Result:', result);
            if (result && result.success) {
              showToast('Paràgraf destacat', 'success');
              updateActiveReference(paraId);
            } else {
              showToast(result && result.error ? result.error : 'No s\'ha pogut navegar', 'error');
            }
          })
          .withFailureHandler(function(err) {
            console.error('[scrollToReference] Error:', err);
            showToast('Error: ' + err.message, 'error');
          })
          .scrollToReference(paraId, color);
      }

      /**
       * Actualitza UI per mostrar ref activa
       */
      function updateActiveReference(paraId) {
        // Treure 'active' de tots
        document.querySelectorAll('.reference-item').forEach(function(el) {
          el.classList.remove('active');
        });

        // Afegir 'active' al clicat
        document.querySelectorAll('.reference-item').forEach(function(el) {
          if (el.getAttribute('onclick').indexOf(paraId + ',') !== -1) {
            el.classList.add('active');
          }
        });
      }

      /**
       * Netejar tots els highlights del document
       * @param {boolean} silent - Si true, no mostra toast (per auto-clear)
       */
      function clearAllHighlights(silent) {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              if (!silent && result.cleared > 0) {
                showToast('Marcatges netejats (' + result.cleared + ')', 'success');
              }
              // Treure visual de refs
              document.querySelectorAll('.reference-item').forEach(function(el) {
                el.classList.add('cleared');
              });
              // v14.5: Reset annotation highlights state
              annotationHighlightsActive = false;
            }
          })
          .withFailureHandler(function(err) {
            if (!silent) {
              showToast('Error netejant: ' + err.message, 'error');
            }
          })
          .clearReferenceHighlights();  // Tornar a funció ràpida
      }

      // ═══════════════════════════════════════════════════════════
      // v9.0: PROACTIVE HIGHLIGHTING SYSTEM
      // ═══════════════════════════════════════════════════════════
      // Automatic highlighting of text snippets mentioned by AI
      // with 5-second auto-clear and click-to-reactivate

      let proactiveHighlightTimer = null;
      let currentProactiveHighlights = [];

      /**
       * Process AI response with proactive highlights
       * Called when we receive a response with proactive_highlights
       */
      function handleProactiveHighlights(highlights, appliedCount) {
        if (!highlights || highlights.length === 0) return;

        currentProactiveHighlights = highlights;

        // v9.2 FIX: Mark only snippets in the LAST message as active (not all messages)
        // The bubble was just added by addBubbleWithProactiveHighlights, so it's the last child
        const container = document.getElementById('chatHistory');
        const lastBubble = container ? container.lastElementChild : null;
        if (lastBubble) {
          lastBubble.querySelectorAll('.highlight-snippet').forEach(function(el) {
            el.classList.add('active');
          });
        }

        // Start 5-second timer to clear highlights from document
        if (proactiveHighlightTimer) {
          clearTimeout(proactiveHighlightTimer);
        }

        proactiveHighlightTimer = setTimeout(function() {
          clearProactiveHighlightsFromDoc();

          // Add fading animation to snippets
          document.querySelectorAll('.highlight-snippet.active').forEach(function(el) {
            el.classList.remove('active');
            el.classList.add('fading');
            setTimeout(function() {
              el.classList.remove('fading');
            }, 500);
          });
        }, 5000);  // 5 seconds

        console.log('[Proactive Highlight] Timer started for ' + highlights.length + ' highlights');
      }

      /**
       * Clear proactive highlights from document
       */
      function clearProactiveHighlightsFromDoc() {
        google.script.run
          .withSuccessHandler(function(result) {
            console.log('[Proactive Highlight] Cleared:', result);
          })
          .withFailureHandler(function(err) {
            console.error('[Proactive Highlight] Clear error:', err);
          })
          .clearProactiveHighlights();
      }

      /**
       * Reactivate highlight when snippet is clicked
       * @param {string} text - The text to highlight
       */
      function reactivateHighlight(text, snippetEl) {
        // Clear any existing timer
        if (proactiveHighlightTimer) {
          clearTimeout(proactiveHighlightTimer);
        }

        // Mark this snippet as active
        document.querySelectorAll('.highlight-snippet.active').forEach(function(el) {
          el.classList.remove('active');
        });
        snippetEl.classList.add('active');

        // Highlight in document
        google.script.run
          .withSuccessHandler(function(result) {
            if (result.success) {
              // Set new timer
              proactiveHighlightTimer = setTimeout(function() {
                clearProactiveHighlightsFromDoc();
                snippetEl.classList.remove('active');
                snippetEl.classList.add('fading');
                setTimeout(function() {
                  snippetEl.classList.remove('fading');
                }, 500);
              }, 5000);
            } else {
              showToast('Text no trobat al document', 'warning');
              snippetEl.classList.remove('active');
            }
          })
          .withFailureHandler(function(err) {
            console.error('[reactivateHighlight] Error:', err);
            snippetEl.classList.remove('active');
          })
          .highlightTextSnippet(text);
      }

      /**
       * Escape special regex characters
       */
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      /**
       * Add bubble with proactive highlights (clickable snippets)
       * @param {string} aiResponse - The AI response text
       * @param {Array} highlights - Array of highlight objects with text
       */
      function addBubbleWithProactiveHighlights(aiResponse, highlights) {
        const container = document.getElementById('chatHistory');
        const bubble = document.createElement('div');
        bubble.className = 'msg ai';

        // v9.0 FIX: Process snippets BEFORE markdown to avoid HTML interference
        // Step 1: Replace highlight texts with unique placeholders in plain text
        let processedText = aiResponse;
        const snippetMap = {};

        if (highlights && highlights.length > 0) {
          // Sort by text length (longest first) to avoid partial matches
          const sortedHighlights = highlights.slice().sort(function(a, b) {
            return (b.text || '').length - (a.text || '').length;
          });

          sortedHighlights.forEach(function(hl, idx) {
            if (hl.text && hl.text.length >= 3) {
              // v9.2 FIX: Use curly braces instead of underscores to avoid markdown interference
              // Triple underscores were being converted by bold pattern /__(.+?)__/g
              const placeholder = '{{{SNIPPET_' + idx + '}}}';
              const escapedText = escapeRegExp(hl.text);
              const regex = new RegExp(escapedText, 'gi');

              // Only replace first occurrence
              const match = processedText.match(regex);
              if (match) {
                processedText = processedText.replace(match[0], placeholder);
                snippetMap[placeholder] = {
                  originalText: match[0],
                  searchText: hl.text
                };
              }
            }
          });
        }

        // Step 2: Render markdown (placeholders survive as plain text)
        const mdResult = renderMarkdown(processedText);
        let mdHtml = typeof mdResult === 'object' ? mdResult.html : mdResult;

        // Step 3: Replace placeholders with clickable snippet HTML
        for (const [placeholder, data] of Object.entries(snippetMap)) {
          // v9.0 FIX: Escape backslashes, then quotes, then newlines for safe JS string in HTML attribute
          const escapedSearch = data.searchText
            .replace(/\\/g, '\\\\')    // Backslashes first
            .replace(/'/g, "\\'")       // Single quotes
            .replace(/"/g, '&quot;')    // Double quotes (HTML entity)
            .replace(/\n/g, '\\n')      // Newlines
            .replace(/\r/g, '\\r');     // Carriage returns
          const snippetHtml = '<span class="highlight-snippet" onclick="reactivateHighlight(\'' +
            escapedSearch + '\', this)">' + escapeHtmlSafe(data.originalText) + '</span>';
          mdHtml = mdHtml.replace(placeholder, snippetHtml);
        }

        bubble.innerHTML = '<div class="md-content">' + mdHtml + '</div>';
        container.appendChild(bubble);
        container.scrollTop = container.scrollHeight;
      }

      // ═══════════════════════════════════════════════════════════
      // v13.0: SISTEMA LÀSER DE PRECISIÓ
      // ═══════════════════════════════════════════════════════════
      // Ressalta fragments ESPECÍFICS dins de paràgrafs (no paràgrafs sencers)
      // Format: [[§ID|text_exacte]]

      let activeLaserRefs = [];
      let laserCleanupBound = false;

      /**
       * v13.0: Trigger proactiu - Analitza resposta i activa ressaltat làser
       * Detecta format [[§ID|text]] i ressalta NOMÉS el text dins del paràgraf
       * @param {string} responseText - Text de la resposta AI
       */
      function triggerInteractiveScreen(responseText) {
        if (!responseText) return;

        // v13.1: Regex tolerant amb espais opcionals \s*
        // Format: [[§ID|text]] o [[ §ID | text ]]
        // Grup 1 = ID, Grup 2 = Text exacte
        const regex = /\[\[\s*§(\d+)\s*\|\s*(.+?)\s*\]\]/g;
        const references = [];
        let match;

        // Debug per veure què envia exactament la IA
        console.log('[Laser Debug] Raw response:', responseText.substring(0, 200));

        while ((match = regex.exec(responseText)) !== null) {
          references.push({
            id: parseInt(match[1], 10) - 1, // Convertir a 0-indexed
            text: match[2].trim() // Netejar espais sobrants
          });
        }

        // Fallback: també detectar format antic [[§ID]] (sense text)
        const oldRegex = /\[\[§(\d+)\]\](?!\|)/g;
        while ((match = oldRegex.exec(responseText)) !== null) {
          references.push({
            id: parseInt(match[1], 10) - 1,
            text: null // Sense text = ressaltar paràgraf sencer
          });
        }

        console.log('[Laser Precision] Found references:', references);

        if (references.length === 0) return;

        // Netejar ressaltats anteriors
        if (activeLaserRefs.length > 0) {
          clearInteractiveScreen(true);
        }

        // Guardar noves referències
        activeLaserRefs = references;

        // Activar ressaltat làser al document
        google.script.run
          .withSuccessHandler(function(result) {
            console.log('[Laser Precision v13.4] Result:', result);
            if (result && (result.applied > 0 || result.wordMatches > 0 || result.fallbacks > 0)) {
              // v13.4: Mostrar resum de tots els tipus de coincidència
              const parts = [];
              if (result.applied > 0) parts.push(result.applied + ' exactes');
              if (result.wordMatches > 0) parts.push(result.wordMatches + ' parcials');
              if (result.fallbacks > 0) parts.push(result.fallbacks + ' paràgrafs');
              const msg = parts.length > 0 ? parts.join(', ') : 'Ressaltat actiu';
              showToast(msg, 'info');
            }
          })
          .withFailureHandler(function(err) {
            console.error('[Laser Precision] Error:', err);
          })
          .highlightLaserPrecision(references);

        // Bind cleanup listener
        bindLaserCleanup();
      }

      /**
       * v13.0: Neteja automàtica dels ressaltats làser
       * @param {boolean} silent - Si true, no mostra toast
       */
      function clearInteractiveScreen(silent) {
        if (activeLaserRefs.length === 0) return;

        activeLaserRefs = []; // Reset estat local

        // Netejar al document
        google.script.run
          .withSuccessHandler(function(result) {
            if (!silent && result && result.cleared > 0) {
              console.log('[Laser Precision] Cleared:', result.cleared);
            }
          })
          .withFailureHandler(function(err) {
            console.error('[Laser Precision] Clear error:', err);
          })
          .clearLaserHighlights();
      }

      /**
       * v13.0: Bind listeners per neteja automàtica
       */
      function bindLaserCleanup() {
        if (laserCleanupBound) return;

        // v14.8: Fix ID (era 'user-input', correcte és 'userInput') + registre per cleanup
        const input = document.getElementById('userInput');
        if (input) {
          const handleLaserCleanupFocus = function() {
            clearInteractiveScreen(true);
          };
          const handleLaserCleanupKeydown = function() {
            clearInteractiveScreen(true);
          };
          registerListener(input, 'focus', handleLaserCleanupFocus);
          registerListener(input, 'keydown', handleLaserCleanupKeydown);
        }

        laserCleanupBound = true;
      }

      /**
       * v13.0: Reactivar un element específic (per clics als xips del xat)
       * @param {number} paraId - ID del paràgraf (0-indexed)
       * @param {string} text - Text exacte a ressaltar
       */
      function focusLaserElement(paraId, text) {
        // Netejar ressaltats anteriors
        if (activeLaserRefs.length > 0) {
          clearInteractiveScreen(true);
        }

        // Guardar nova referència
        activeLaserRefs = [{ id: paraId, text: text }];

        // Ressaltar al document
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              showToast('Navegant al fragment', 'success');
            }
          })
          .withFailureHandler(function(err) {
            showToast('Error navegant', 'error');
          })
          .focusLaserElement(paraId, text);

        // Bind cleanup
        bindLaserCleanup();
      }

      // Alias per compatibilitat
      function focusInteractiveParagraph(paraId) {
        focusLaserElement(paraId, null);
      }

      // ═══════════════════════════════════════════════════════════
      // v11.0: ANNOTATION SYSTEM - Unified Highlights + Changes
      // ═══════════════════════════════════════════════════════════

      // v14.4: Controlar si els highlights estan actius
      let annotationHighlightsActive = true;

      /**
       * v14.4: Callback quan els highlights del document s'han netejat
       * Actualitza la UI de les anotacions per mostrar el botó "Veure"
       */
      function onHighlightsCleared() {
        if (!annotationHighlightsActive) return;  // Ja netejat
        annotationHighlightsActive = false;

        // Afegir classe per mostrar botó "Veure" a totes les anotacions pendents
        document.querySelectorAll('.annotation-item.change-item[data-status="pending"]').forEach(function(el) {
          el.classList.add('highlights-cleared');
        });
      }

      /**
       * v14.4: Tornar a aplicar highlight per una anotació específica
       * v14.5: Ressalta només el text específic del canvi, no tot el paràgraf
       * v14.5.1: Si acceptat mostra el canvi fet, si pendent/rebutjat mostra l'original
       * v15.1: Animació breathing mentre es processa
       * @param {string} annotationId - ID de l'anotació
       * @param {HTMLElement} btn - Botó que ha disparat l'acció (opcional)
       */
      function showAnnotationHighlight(annotationId, btn) {
        // v15.1: Activar animació de respiració
        if (btn) btn.classList.add('breathing');
        function stopBreathing() { if (btn) btn.classList.remove('breathing'); }

        const ann = pendingAnnotations.find(a => a.id === annotationId);
        if (!ann) { stopBreathing(); return; }

        // v14.5.1: Determinar el text segons l'estat de l'anotació
        let textToHighlight = '';
        const isAccepted = ann.status === 'accepted';

        // v15.4: Detectar si és una eliminació (proposedText buit o molt més curt)
        const isDeleted = isAccepted && (
          !ann.proposedText ||
          ann.proposedText === '' ||
          (ann.replace !== undefined && ann.replace === '') ||
          (ann.originalText && ann.proposedText && ann.proposedText.length < ann.originalText.length * 0.3)
        );

        if (isDeleted) {
          // v15.4: Text eliminat - ressaltar el paràgraf sencer
          google.script.run
            .withSuccessHandler(function(result) {
              stopBreathing();
              if (result && result.applied > 0) {
                annotationHighlightsActive = true;
                showToast('Paràgraf ressaltat (text eliminat)', 'info');
              } else {
                // v15.4: Si no es pot ressaltar, mostrar info alternativa
                showToast('Text eliminat: "' + (ann.find || ann.originalText || '').substring(0, 30) + '"', 'info');
              }
            })
            .withFailureHandler(function(err) {
              stopBreathing();
              showToast('Text eliminat: "' + (ann.find || ann.originalText || '').substring(0, 30) + '"', 'info');
            })
            .highlightParagraphById(ann.para_id, isAccepted ? 'lightGreen' : 'lightBlue');
          return;
        }

        if (ann.find && ann.replace !== undefined) {
          // Mode FIX: si acceptat mostra el replacement, si no el find original
          textToHighlight = isAccepted ? ann.replace : ann.find;
        } else if (ann.originalText && ann.proposedText) {
          // v17.45: Detectar canvi de paràgraf complet (MODE IMPROVE)
          // Si no té find/replace, és un canvi de paràgraf complet → ressaltar tot
          const isFullParagraphChange = !ann.find && ann.originalText.length > 50;

          if (isFullParagraphChange) {
            // v17.45: Per canvis de paràgraf complet, ressaltar tot el paràgraf
            google.script.run
              .withSuccessHandler(function(result) {
                stopBreathing();
                if (result && result.applied > 0) {
                  annotationHighlightsActive = true;
                  showToast('Paràgraf ressaltat', 'info');
                } else {
                  showToast('No s\'ha pogut ressaltar el paràgraf', 'warning');
                }
              })
              .withFailureHandler(function(err) {
                stopBreathing();
                showToast('Error ressaltant', 'error');
              })
              .highlightParagraphById(ann.para_id, isAccepted ? 'lightGreen' : 'lightBlue');
            return;
          }

          // v14.5.2: Trobar només les paraules que canvien
          const diff = findChangeFragment(
            isAccepted ? ann.proposedText : ann.originalText,
            isAccepted ? ann.originalText : ann.proposedText
          );
          if (diff) {
            textToHighlight = diff;
          } else {
            // v14.5.2: Fallback: primeres 2-3 paraules, no 50 chars
            const source = isAccepted ? ann.proposedText : ann.originalText;
            const words = source.split(/\s+/).slice(0, 3);
            textToHighlight = words.join(' ');
          }
        } else {
          // Fallback: primeres 2-3 paraules
          const source = isAccepted ? ann.proposedText : ann.originalText;
          if (source) {
            const words = source.split(/\s+/).slice(0, 3);
            textToHighlight = words.join(' ');
          }
        }

        // Aplicar highlight al document
        google.script.run
          .withSuccessHandler(function(result) {
            stopBreathing();
            if (result && result.applied > 0) {
              annotationHighlightsActive = true;
              // Treure classe de totes les anotacions
              document.querySelectorAll('.annotation-item.highlights-cleared').forEach(function(el) {
                el.classList.remove('highlights-cleared');
              });
            } else {
              // v15.4: Si el text no es troba (potser s'ha modificat manualment)
              showToast('No s\'ha trobat el text al document', 'warning');
            }
          })
          .withFailureHandler(function(err) {
            stopBreathing();
            showToast('Error ressaltant', 'error');
          })
          .applyReferenceHighlights([{
            para_id: ann.para_id,
            snippet: textToHighlight,
            // v17.46: Blau clar abans, verd clar després
            color: isAccepted ? 'lightGreen' : 'lightBlue'
          }]);
      }

      /**
       * v14.5: Mostrar tots els highlights de canvis pendents
       */
      function showAllAnnotationHighlights() {
        const pending = pendingAnnotations.filter(a => a.type === 'change' && a.status === 'pending');
        if (pending.length === 0) return;

        // Construir array de highlights per tots els canvis pendents
        const highlights = [];
        for (const ann of pending) {
          let textToHighlight = '';

          if (ann.find) {
            textToHighlight = ann.find;
          } else if (ann.originalText && ann.proposedText) {
            // v14.5.2: Trobar només les paraules que canvien
            const diff = findChangeFragment(ann.originalText, ann.proposedText);
            if (diff) {
              textToHighlight = diff;
            } else {
              // Fallback: primeres 2-3 paraules
              const words = ann.originalText.split(/\s+/).slice(0, 3);
              textToHighlight = words.join(' ');
            }
          } else if (ann.originalText) {
            // Fallback: primeres 2-3 paraules
            const words = ann.originalText.split(/\s+/).slice(0, 3);
            textToHighlight = words.join(' ');
          }

          if (textToHighlight) {
            highlights.push({
              para_id: ann.para_id,
              snippet: textToHighlight,
              color: 'blue'
            });
          }
        }

        if (highlights.length === 0) return;

        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.applied > 0) {
              annotationHighlightsActive = true;
              document.querySelectorAll('.annotation-item.highlights-cleared').forEach(function(el) {
                el.classList.remove('highlights-cleared');
              });
              showToast(result.applied + ' canvis ressaltats', 'success');
            }
          })
          .withFailureHandler(function(err) {
            showToast('Error ressaltant', 'error');
          })
          .applyReferenceHighlights(highlights);
      }

      /**
       * v14.5: Troba el fragment de text que canvia entre original i modificat
       * v14.5.2: Millorat per ressaltar només les paraules que canvien
       */
      function findChangeFragment(original, modified) {
        if (!original || !modified || original === modified) return null;

        // Trobar prefix comú
        let prefixLen = 0;
        const minLen = Math.min(original.length, modified.length);
        while (prefixLen < minLen && original[prefixLen] === modified[prefixLen]) {
          prefixLen++;
        }

        // Trobar suffix comú
        let suffixLen = 0;
        while (
          suffixLen < minLen - prefixLen &&
          original[original.length - 1 - suffixLen] === modified[modified.length - 1 - suffixLen]
        ) {
          suffixLen++;
        }

        let start = prefixLen;
        let end = original.length - suffixLen;

        // v14.5.2: Expandir als límits de paraula més propers (no al mig d'una paraula)
        // Retrocedir al principi de la paraula
        while (start > 0 && original[start - 1] !== ' ' && original[start - 1] !== '\n') {
          start--;
        }
        // Avançar al final de la paraula
        while (end < original.length && original[end] !== ' ' && original[end] !== '\n') {
          end++;
        }

        const fragment = original.substring(start, end).trim();

        // v14.5.2: Si el fragment és buit o només espais, retornar null
        if (!fragment || fragment.length === 0) return null;

        // v14.5.2: Si el fragment és molt curt (1-2 chars), expandir mínimament només per contexte de cerca
        if (fragment.length < 3 && original.length > fragment.length) {
          // Buscar la paraula completa que conté el canvi
          const words = original.split(/\s+/);
          for (const word of words) {
            if (word.includes(fragment) || fragment.includes(word)) {
              return word;
            }
          }
        }

        return fragment;
      }

      /**
       * Renderitza una resposta amb anotacions (unifica highlights i changes)
       * @param {string} aiResponse - Text de resposta de l'AI
       * @param {Array} annotations - Array d'anotacions
       * @param {string} docSnapshot - Snapshot del document (opcional)
       * @param {string} modificationType - v12.1: Tipus de modificació (fix|improve|expand|simplify|translate)
       */
      function addBubbleWithAnnotations(aiResponse, annotations, docSnapshot, modificationType) {
        // v14.4: Reset estat dels highlights
        annotationHighlightsActive = true;
        const container = document.getElementById('chatHistory');
        const bubble = document.createElement('div');
        bubble.className = 'msg ai';

        // Guardar dades per accions posteriors
        pendingAnnotations = annotations;
        annotationDocSnapshot = docSnapshot || null;
        annotationModificationType = modificationType || null; // v12.1: Per router híbrid

        // Resposta principal amb markdown
        let html = '<div class="md-content">' + renderMarkdownHtml(aiResponse) + '</div>';

        // Afegir llista d'anotacions
        if (annotations && annotations.length > 0) {
          html += '<div class="annotation-list">';

          const totalChanges = annotations.filter(a => a.type === 'change').length;
          let changeIndex = 0;
          for (const ann of annotations) {
            if (ann.type === 'change') {
              changeIndex++;
              html += renderChangeAnnotation(ann, changeIndex, totalChanges);
            } else {
              // Highlight (informatiu)
              html += renderHighlightAnnotation(ann);
            }
          }

          html += '</div>';

          // v14.5: Barra d'accions bulk només si hi ha MÉS D'UN canvi pendent
          // (si només n'hi ha 1, els botons individuals ja són suficients)
          const pendingChanges = annotations.filter(a => a.type === 'change' && a.status === 'pending');
          if (pendingChanges.length > 1) {
            html += '<div class="annotation-bulk-actions">';
            html += '<span class="bulk-info">' + pendingChanges.length + ' canvi' + (pendingChanges.length !== 1 ? 's' : '') + ' pendent' + (pendingChanges.length !== 1 ? 's' : '') + '</span>';
            html += '<div class="bulk-buttons">';
            // v16.0: Botons bulk - només Veure tots i Acceptar tots
            html += '<button class="btn-view-all" onclick="showAllAnnotationHighlights()" title="Veure tots">' + icon('eye', 'i--sm') + '</button>';
            html += '<button class="btn-accept-all" onclick="acceptAllAnnotations()" title="Acceptar tots">' + icon('check', 'i--sm') + '</button>';
            html += '</div>';
            html += '</div>';
          }
        }

        bubble.innerHTML = html;
        container.appendChild(bubble);
        container.scrollTop = container.scrollHeight;
      }

      /**
       * v17.9: Extreu el canvi petit d'un paràgraf complet
       * Retorna {find, replace} si el canvi afecta menys de 5 paraules
       * @returns {Object|null} { find, replace } o null si és canvi gran
       */
      function extractSmallChange(original, modified) {
        if (!original || !modified || original === modified) return null;

        // Comparar paraules (mantenir espais per preservar posició)
        const origWords = original.split(/(\s+)/);
        const modWords = modified.split(/(\s+)/);

        // Trobar primer índex diferent des del principi
        let startDiff = 0;
        while (startDiff < origWords.length && startDiff < modWords.length && origWords[startDiff] === modWords[startDiff]) {
          startDiff++;
        }

        // Trobar primer índex diferent des del final
        let endDiffOrig = origWords.length - 1;
        let endDiffMod = modWords.length - 1;
        while (endDiffOrig >= startDiff && endDiffMod >= startDiff && origWords[endDiffOrig] === modWords[endDiffMod]) {
          endDiffOrig--;
          endDiffMod--;
        }

        // Si no hi ha diferència
        if (startDiff > endDiffOrig && startDiff > endDiffMod) {
          return null;
        }

        // Extreure fragments
        const origDiffWords = origWords.slice(startDiff, endDiffOrig + 1);
        const modDiffWords = modWords.slice(startDiff, endDiffMod + 1);

        const findText = origDiffWords.join('').trim();
        const replaceText = modDiffWords.join('').trim();

        // Si el canvi és massa gran (>5 paraules), no és canvi petit
        const origWordCount = origDiffWords.filter(w => w.trim()).length;
        const modWordCount = modDiffWords.filter(w => w.trim()).length;
        if (origWordCount > 5 || modWordCount > 5) {
          return null;
        }

        // v17.24: Permetre insercions (find buit) i eliminacions (replace buit)
        // Comparar normalitzat SENSE toLowerCase() - majúscules són canvis vàlids
        const normalizeForCompare = (s) => (s || '').trim().replace(/\s+/g, ' ');
        if (normalizeForCompare(findText) === normalizeForCompare(replaceText)) return null;

        return {
          find: findText,  // Pot ser "" per insercions
          replace: replaceText  // Pot ser "" per eliminacions
        };
      }

      /**
       * v14.6: Calcula estadístiques d'un canvi
       * @returns {Object} { charDiff, wordsAdded, wordsRemoved, isLarge }
       */
      function computeChangeStats(original, proposed) {
        const origText = original || '';
        const propText = proposed || '';

        const origWords = origText.split(/\s+/).filter(w => w.length > 0);
        const propWords = propText.split(/\s+/).filter(w => w.length > 0);

        const charDiff = Math.abs(propText.length - origText.length);
        const totalCharChange = Math.abs(propText.length - origText.length) +
          Math.min(origText.length, propText.length) * 0.5; // Estimació de canvis

        // Comptar paraules afegides/eliminades (aproximat)
        const wordsAdded = Math.max(0, propWords.length - origWords.length);
        const wordsRemoved = Math.max(0, origWords.length - propWords.length);

        // És gran si: >80 chars de diferència O >60 chars en total i canvi significatiu
        const isLarge = charDiff > 80 || (origText.length + propText.length > 120 && charDiff > 30);

        return { charDiff, wordsAdded, wordsRemoved, isLarge, origLen: origText.length, propLen: propText.length };
      }

      /**
       * v17.0: Genera una descripció curta del canvi (màx 2-3 paraules)
       * Exemples: "corregir «Informaciió»", "simplificar frase", "afegir accent"
       */
      function generateChangeDescription(original, proposed) {
        if (!original || !proposed) return '';

        const origText = original.trim();
        const propText = proposed.trim();

        // Si són idèntics, no hi ha descripció
        if (origText === propText) return '';

        // Trobar la paraula/fragment que canvia
        const origWords = origText.split(/\s+/);
        const propWords = propText.split(/\s+/);

        // Buscar la primera diferència paraula per paraula
        let diffWord = '';
        let correctedWord = '';
        for (let i = 0; i < Math.max(origWords.length, propWords.length); i++) {
          const ow = origWords[i] || '';
          const pw = propWords[i] || '';
          if (ow !== pw) {
            diffWord = ow;
            correctedWord = pw;
            break;
          }
        }

        // Si no hi ha diferència a nivell de paraula, buscar a nivell de caràcter
        if (!diffWord && origText !== propText) {
          // Canvi petit dins d'una paraula (accent, lletra)
          for (let i = 0; i < origWords.length; i++) {
            if (origWords[i] !== propWords[i]) {
              diffWord = origWords[i];
              correctedWord = propWords[i];
              break;
            }
          }
        }

        // Determinar tipus de canvi
        if (!diffWord) {
          // Canvi general
          if (propText.length < origText.length * 0.7) return 'escurçar';
          if (propText.length > origText.length * 1.3) return 'expandir';
          return 'millorar';
        }

        // Limitar longitud de la paraula mostrada
        const maxLen = 15;
        const shortWord = diffWord.length > maxLen ? diffWord.substring(0, maxLen) + '…' : diffWord;

        // Detectar tipus específic de canvi
        const lowerOrig = diffWord.toLowerCase();
        const lowerProp = (correctedWord || '').toLowerCase();

        // Accent afegit?
        if (lowerOrig.replace(/[àáèéíòóú]/g, c => 'aaeeioo'[['à','á','è','é','í','ò','ó','ú'].indexOf(c)]) ===
            lowerProp.replace(/[àáèéíòóú]/g, c => 'aaeeioo'[['à','á','è','é','í','ò','ó','ú'].indexOf(c)])) {
          // Mateixa paraula però diferent accentuació
          if (correctedWord.match(/[àáèéíòóú]/)) {
            return '«' + shortWord + '»';
          }
        }

        // Lletra duplicada? (informaciió → informació)
        if (diffWord.match(/(.)\1/) && !correctedWord.match(/(.)\1/)) {
          return '«' + shortWord + '»';
        }

        // Retornar descripció amb la paraula afectada
        return '«' + shortWord + '»';
      }

      /**
       * v14.6: Toggle expandir/col·lapsar una anotació
       */
      function toggleAnnotationExpand(annId) {
        const item = document.querySelector('.annotation-item[data-id="' + annId + '"]');
        if (!item) return;

        const isExpanded = item.classList.contains('expanded');
        item.classList.toggle('expanded', !isExpanded);

        // Actualitzar icona del botó
        const btn = item.querySelector('.btn-expand');
        if (btn) {
          btn.innerHTML = isExpanded ? icon('chevronDown', 'i--sm') : icon('chevronUp', 'i--sm');
          btn.title = isExpanded ? 'Expandir' : 'Col·lapsar';
        }
      }

      /**
       * Renderitza una anotació de canvi (amb botons Accept/Reject)
       * v14.1: Afegit suport per indicadors WARN
       * v14.6: Vista col·lapsada per canvis grans
       * v17.0: "Canvi N: descripció curta" en lloc de "Canvi proposat N:"
       * v17.4: Canvis llargs mostren només "Paràgraf proposat:" amb text net
       *        (original s'assenyala al document, proposat es mostra a la barra)
       */
      function renderChangeAnnotation(ann, changeNum, totalChanges) {
        const statusClass = 'data-status="' + (ann.status || 'pending') + '"';

        // v17.24: Decidir si és canvi puntual (find/replace) o canvi de línia completa
        // IMPORTANT: find pot ser "" per insercions, replace pot ser "" per eliminacions
        // Usar typeof per detectar si existeixen (no truthy check)
        const hasFind = typeof ann.find === 'string';
        const hasReplace = typeof ann.replace === 'string';
        // v17.24: Normalitzar SENSE toLowerCase() - les majúscules SÓN canvis vàlids
        const normalizeForCompare = (s) => (s || '').trim().replace(/\s+/g, ' ');
        let isFindReplaceChange = hasFind && hasReplace &&
          normalizeForCompare(ann.find) !== normalizeForCompare(ann.replace);

        // v17.9: Si no tenim find/replace però el canvi és petit, calcular-los
        let displayOriginal, displayProposed;
        if (isFindReplaceChange) {
          displayOriginal = ann.find;
          displayProposed = ann.replace;
        } else if (ann.originalText && ann.proposedText && ann.originalText !== ann.proposedText) {
          // Intentar extreure el fragment que canvia
          const extracted = extractSmallChange(ann.originalText, ann.proposedText);
          if (extracted) {
            displayOriginal = extracted.find;
            displayProposed = extracted.replace;
            isFindReplaceChange = true;  // Ara és un canvi petit!
          } else {
            displayOriginal = ann.originalText;
            displayProposed = ann.proposedText;
          }
        } else {
          displayOriginal = ann.originalText;
          displayProposed = ann.proposedText;
        }

        const stats = computeChangeStats(displayOriginal, displayProposed);

        // v17.7: Detectar si el canvi és prou llarg per mostrar només el proposat
        // Per canvis find/replace petits, MAI mostrar com a "paràgraf complet"
        const SHOW_PROPOSED_ONLY_THRESHOLD = 80;
        const originalLen = (displayOriginal || '').length;
        const isFullParagraphChange = !isFindReplaceChange && originalLen > SHOW_PROPOSED_ONLY_THRESHOLD;

        // v14.1: Afegir classe especial si és WARN
        const warnClass = ann._status === 'WARN' ? ' warn-change' : '';
        // v14.6: Classe per canvis grans (col·lapsats per defecte)
        const largeClass = stats.isLarge ? ' large-change' : '';
        // v17.4: Classe per canvis de paràgraf complet
        const fullParaClass = isFullParagraphChange ? ' full-paragraph-change' : '';

        let html = '<div class="annotation-item change-item' + warnClass + largeClass + fullParaClass + '" data-id="' + ann.id + '" ' + statusClass + '>';
        // v16.5: Header amb botons a la dreta
        html += '<div class="annotation-header">';
        html += '<div class="annotation-header-left">';

        // v17.13: Format simplificat - només número de canvi, sense descripció
        const locationLabel = (totalChanges > 1) ? 'Canvi ' + changeNum : 'Canvi';
        html += '<span class="annotation-location">' + locationLabel + '</span>';

        // v14.1: Mostrar badge WARN si aplica
        if (ann._status === 'WARN') {
          html += '<span class="annotation-warn-badge" title="' + escapeHtmlSafe(ann._warn_reason || 'Canvi gran que requereix revisió') + '">';
          html += icon('alertTriangle', 'i--sm i--warning') + ' Reviseu';
          html += '</span>';
        }
        html += '</div>'; // annotation-header-left

        // v16.5: Botons i status a la dreta de la capçalera
        html += '<div class="annotation-header-right">';
        // Status (es mostra quan està accepted)
        html += '<span class="annotation-status">';
        if (ann.status === 'accepted') {
          html += icon('checkCircle', 'i--sm') + ' Aplicat';
        }
        html += '</span>';
        // Botons d'acció
        html += '<div class="annotation-actions">';
        if (stats.isLarge && !isFullParagraphChange) {
          html += '<button class="btn-expand" onclick="toggleAnnotationExpand(\'' + ann.id + '\')" title="Expandir">' + icon('chevronDown', 'i--sm') + '</button>';
        }
        // v17.14: Botó info per mostrar l'explicació del canvi
        if (ann.reason) {
          html += '<button class="btn-info" onclick="toggleChangeInfo(\'' + ann.id + '\', this)" title="Informació del canvi">' + icon('info', 'i--sm') + '</button>';
        }
        html += '<button class="btn-view" onclick="showAnnotationHighlight(\'' + ann.id + '\', this)" title="Veure al document">' + icon('eye', 'i--sm') + '</button>';
        html += '<button class="btn-accept" onclick="acceptSingleAnnotation(\'' + ann.id + '\', this)" title="Acceptar">' + icon('check', 'i--sm') + '</button>';
        html += '</div>';
        html += '</div>'; // annotation-header-right

        html += '</div>'; // annotation-header

        // v17.7: Per canvis de paràgraf complet, mostrar el text proposat net (sense diff)
        if (isFullParagraphChange) {
          html += '<div class="annotation-proposed-text">' + escapeHtmlSafe(displayProposed || '') + '</div>';
        } else if (stats.isLarge) {
          // v14.6: Per canvis grans (no de paràgraf), mostrar vista col·lapsada
          const diffHtml = ann.diffHtml || computeDiffHtml(displayOriginal || '', displayProposed || '');
          // Estadístiques compactes
          html += '<div class="annotation-stats">';
          if (stats.wordsRemoved > 0) html += '<span class="stat-removed">−' + stats.wordsRemoved + ' p</span>';
          if (stats.wordsAdded > 0) html += '<span class="stat-added">+' + stats.wordsAdded + ' p</span>';
          html += '<span class="stat-chars">±' + stats.charDiff + ' chars</span>';
          html += '</div>';

          // Diff amagat (es mostra quan s'expandeix)
          html += '<div class="annotation-diff collapsed">' + diffHtml + '</div>';
        } else {
          // v17.7: Canvi petit o find/replace: mostrar diff directament
          const diffHtml = ann.diffHtml || computeDiffHtml(displayOriginal || '', displayProposed || '');
          html += '<div class="annotation-diff">' + diffHtml + '</div>';
        }

        // v14.1: Mostrar info d'edit distance si és WARN
        if (ann._status === 'WARN' && ann._edit_distance) {
          html += '<div class="annotation-warn-info">';
          html += icon('info', 'i--xs i--muted') + ' Distància d\'edició: ' + ann._edit_distance + ' caràcters';
          html += '</div>';
        }

        // v16.5: Footer eliminat - botons ara a la capçalera

        html += '</div>';
        return html;
      }

      /**
       * Renderitza una anotació de highlight (informativa, clicable)
       * v16.0: Simplificat - només localització, sense accions
       */
      function renderHighlightAnnotation(ann) {
        const colorClass = 'ref-' + (ann.color || 'yellow');

        let html = '<div class="annotation-item highlight-item reference-item ' + colorClass + '" ';
        html += 'onclick="scrollToDocReference(' + ann.para_id + ', \'' + ann.color + '\')" ';
        html += 'title="Clic per veure al document">';

        // Format clàssic: snippet + reason
        html += '<span class="ref-content">';
        html += '<span class="ref-snippet">"' + escapeHtmlSafe(ann.snippet || '...') + '"</span>';
        html += '<span class="ref-reason">' + escapeHtmlSafe(ann.reason) + '</span>';
        html += '</span>';

        html += '<span class="ref-arrow">' + icon('chevronRight', 'i--sm') + '</span>';

        html += '</div>';
        return html;
      }

      /**
       * v17.14: Mostrar/amagar informació del canvi (tooltip)
       */
      function toggleChangeInfo(annotationId, btn) {
        console.log('[v17.28] toggleChangeInfo called for:', annotationId);
        const ann = pendingAnnotations.find(a => a.id === annotationId);
        console.log('[v17.28] annotation found:', !!ann, 'reason:', ann ? ann.reason : 'N/A');
        if (!ann || !ann.reason) {
          console.log('[v17.28] EARLY RETURN - no annotation or no reason');
          return;
        }

        // v17.28: Usar closest() per trobar l'element CORRECTE (no el primer del DOM)
        let el = btn ? btn.closest('.annotation-item[data-id="' + annotationId + '"]') : null;
        if (!el) {
          console.log('[v17.28] Element not found via closest, trying querySelector');
          // Fallback al querySelector si btn no funciona
          el = document.querySelector('.annotation-item[data-id="' + annotationId + '"]');
          if (!el) return;
        }

        // Comprovar si ja existeix el tooltip
        let infoBox = el.querySelector('.change-info-box');
        if (infoBox) {
          // Toggle: amagar si ja està visible
          infoBox.remove();
          btn.classList.remove('active');
          return;
        }

        // Crear el tooltip amb l'explicació
        infoBox = document.createElement('div');
        infoBox.className = 'change-info-box';
        infoBox.innerHTML = '<div class="change-info-content">' + escapeHtmlSafe(ann.reason) + '</div>';

        // Inserir just després del header
        const header = el.querySelector('.annotation-header');
        if (header && header.nextSibling) {
          el.insertBefore(infoBox, header.nextSibling);
        } else {
          el.appendChild(infoBox);
        }

        btn.classList.add('active');
      }

      /**
       * Acceptar un canvi individual
       * v12.1: Router híbrid - FIX usa replaceText natiu, altres usen FormatPreserver
       * v17.37: Usar closest() per trobar l'element correcte quan hi ha duplicats
       */
      function acceptSingleAnnotation(annotationId, btn) {
        const ann = pendingAnnotations.find(a => a.id === annotationId);
        if (!ann || ann.status !== 'pending') return;

        // v16.4: Activar animació breathing al botó ABANS de deshabilitar-lo
        if (btn) {
          btn.classList.add('breathing');
          // NO deshabilitar el botó - només afegir classe per evitar doble-click
          btn.style.pointerEvents = 'none';
        }
        function stopBreathing() {
          if (btn) {
            btn.classList.remove('breathing');
            btn.style.pointerEvents = '';
          }
        }

        // v14.5: NO netejar tots els highlights - només el d'aquest canvi es netejarà
        // perquè el text original canviarà. Els altres highlights es mantenen.

        // v17.37: Usar closest() per trobar l'element correcte (no el primer del DOM)
        // Això és CRÍTIC quan hi ha duplicats per converses antigues
        let el = btn ? btn.closest('.annotation-item[data-id="' + annotationId + '"]') : null;
        if (!el) {
          el = document.querySelector('.annotation-item[data-id="' + annotationId + '"]');
        }
        console.log('[v17.37] acceptSingleAnnotation found element via', btn ? 'closest()' : 'querySelector()', ':', !!el);
        if (el) {
          el.setAttribute('data-status', 'applying');
          const btnReject = el.querySelector('.btn-reject');
          if (btnReject) btnReject.disabled = true;
        }

        const successHandler = function(result) {
          stopBreathing();  // v16.2: Aturar breathing
          // v16.3: Debug logging per undo
          console.log('[acceptSingleAnnotation] result:', JSON.stringify(result));
          console.log('[acceptSingleAnnotation] modification_type:', annotationModificationType);

          // v17.33: Debug exhaustiu
          console.log('[v17.33] acceptSingleAnnotation SUCCESS HANDLER');
          console.log('[v17.33] result.ok:', result?.ok);
          console.log('[v17.33] result.applied:', result?.applied);
          console.log('[v17.33] result.skipped:', result?.skipped);
          console.log('[v17.33] result.undoSnapshots:', JSON.stringify(result?.undoSnapshots || 'undefined'));
          // v17.42: Debug - mostrar què ha rebut Code.gs
          if (result?._debug_v17_42) {
            console.log('[v17.42] DEBUG from Code.gs:', JSON.stringify(result._debug_v17_42, null, 2));
          }

          // v16.9: Verificar que el canvi s'ha aplicat realment (no skipped)
          if (result && result.ok && result.applied === 0 && result.skipped > 0) {
            console.warn('[acceptSingleAnnotation] Change was skipped, not applied');
            showToast('No s\'ha pogut aplicar el canvi (text no trobat)', 'warning');
            return;
          }

          if (result && result.ok) {
            ann.status = 'accepted';
            // v16.1: Guardar snapshot local per undo immediat
            console.log('[v17.33] Checking for undoSnapshot...');
            if (result.undoSnapshots && result.undoSnapshots.length > 0) {
              ann.undoSnapshot = result.undoSnapshots[0];
              console.log('[v17.33] ✅ Using undoSnapshots[0]:', JSON.stringify(ann.undoSnapshot).substring(0, 100));
            } else if (result.undoSnapshot) {
              ann.undoSnapshot = result.undoSnapshot;
              console.log('[v17.33] ✅ Using undoSnapshot:', JSON.stringify(ann.undoSnapshot).substring(0, 100));
            } else {
              console.warn('[v17.33] ❌ NO undoSnapshot in result!');
            }
            console.log('[v17.33] ann.undoSnapshot after assignment:', !!ann.undoSnapshot);

            // v16.1: Guardar a Supabase per historial persistent (async, no bloqueja)
            const editData = {
              target_id: ann.para_id,
              before_text: ann.undoSnapshot ? ann.undoSnapshot.originalText : (ann.find || ann.originalText),
              after_text: ann.replace !== undefined ? ann.replace : ann.proposedText,
              instruction: ann.reason || 'Canvi acceptat',
              reason: ann.reason || null
            };
            google.script.run
              .withSuccessHandler(function(saveResult) {
                if (saveResult && saveResult.ok && saveResult.event_id) {
                  ann.event_id = saveResult.event_id;  // Guardar per undo persistent
                }
              })
              .saveAppliedEdit(editData);

            // v17.37: Passar l'element per evitar problemes amb duplicats
            updateAnnotationUI(annotationId, 'accepted', el);
            // v15.4: Toast més informatiu
            let toastMsg = 'Canvi aplicat';
            if (ann.find || ann.originalText) {
              const original = ann.find || ann.originalText.substring(0, 30);
              const replacement = ann.replace !== undefined ? ann.replace : ann.proposedText;
              if (replacement === '' || (ann.proposedText && ann.proposedText.length < ann.originalText.length * 0.5)) {
                toastMsg = 'Eliminat: "' + original.substring(0, 20) + '"';
              } else {
                toastMsg = 'Canviat: "' + original.substring(0, 15) + '"';
              }
            }
            showToast(toastMsg, 'success');
            updateBulkActionsBar();

            // v16.4: Auto-clear highlight després d'1.5 segons
            // v16.7: Reduït de 3s a 1.5s per feedback de l'usuari
            if (result.highlightApplied) {
              setTimeout(function() {
                google.script.run.clearHighlightByParaId(ann.para_id);
              }, 1500);
            }
          } else {
            ann.status = 'pending';
            // v17.37: Passar l'element
            updateAnnotationUI(annotationId, 'pending', el);
            showToast(result.error || 'Error aplicant canvi', 'error');
          }
        };

        const failureHandler = function(err) {
          stopBreathing();  // v16.2: Aturar breathing
          ann.status = 'pending';
          // v17.37: Passar l'element
          updateAnnotationUI(annotationId, 'pending', el);
          showToast('Error: ' + err.message, 'error');
        };

        // v17.2: Unificat - sempre usa applyFindReplaceChanges amb fallbacks
        // v17.36: Debug logging per diagnosticar undoSnapshot
        console.log('[v17.36] acceptSingleAnnotation sending to backend:', {
          targetId: ann.para_id,
          hasFind: !!ann.find,
          hasReplace: !!ann.replace,
          hasOriginalText: !!ann.originalText,
          hasProposedText: !!ann.proposedText,
          originalText_preview: ann.originalText ? ann.originalText.substring(0, 50) : 'NULL',
          proposedText_preview: ann.proposedText ? ann.proposedText.substring(0, 50) : 'NULL'
        });
        // v17.39: IMPORTANT - No usar || per strings que poden ser buits!
        // "" || null = null (INCORRECTE per eliminacions)
        // typeof x === 'string' preserva strings buits
        google.script.run
          .withSuccessHandler(successHandler)
          .withFailureHandler(failureHandler)
          .applyFindReplaceChanges([{
            targetId: ann.para_id,
            // Mode FIX: find/replace atòmic (replace pot ser "" per eliminacions!)
            find: typeof ann.find === 'string' ? ann.find : null,
            replace: typeof ann.replace === 'string' ? ann.replace : null,
            // Mode IMPROVE/altres: original_text/new_text per full-replace
            // v17.43: typeof check per preservar "" (Google Apps Script converteix "" a null!)
            original_text: typeof ann.originalText === 'string' ? ann.originalText : null,
            new_text: typeof ann.proposedText === 'string' ? ann.proposedText : null,
            // Highlight precís
            highlight_find: typeof ann.highlight_find === 'string' ? ann.highlight_find : null,
            highlight_replace: typeof ann.highlight_replace === 'string' ? ann.highlight_replace : null,
            context: ann.context || null
          }]);
      }

      /**
       * Acceptar tots els canvis pendents
       * v12.1: Router híbrid - usa applyFindReplaceChanges per mode FIX
       */
      function acceptAllAnnotations() {
        const pending = pendingAnnotations.filter(a => a.type === 'change' && a.status === 'pending');
        if (pending.length === 0) return;

        // v14.1: Netejar highlights anteriors quan l'usuari interactua
        clearAllHighlights(true);

        showToast('Aplicant ' + pending.length + ' canvis...', 'info');

        const successHandler = function(result) {
          // v17.32: Debug logging complet
          console.log('[v17.32] acceptAllAnnotations result:', JSON.stringify(result));
          console.log('[v17.32] undoSnapshots count:', result?.undoSnapshots?.length || 0);

          if (result && result.ok) {
            // v17.30: Guardar undoSnapshots per cada anotació per permetre undo individual
            const snapshots = result.undoSnapshots || [];
            console.log('[v17.32] Processing', pending.length, 'pending annotations with', snapshots.length, 'snapshots');

            pending.forEach((ann, i) => {
              ann.status = 'accepted';
              // v17.30: Assignar undoSnapshot corresponent (per targetId o per índex)
              const matchingSnapshot = snapshots.find(s => String(s.targetId) === String(ann.para_id)) || snapshots[i];
              console.log('[v17.32] ann', ann.id, 'para_id:', ann.para_id, 'matchingSnapshot:', !!matchingSnapshot, matchingSnapshot ? 'targetId=' + matchingSnapshot.targetId : '');
              if (matchingSnapshot) {
                ann.undoSnapshot = matchingSnapshot;
                console.log('[v17.32] SAVED undoSnapshot for', ann.id);
              } else {
                console.warn('[v17.32] NO undoSnapshot found for', ann.id, '- snapshots:', snapshots.map(s => s.targetId));
              }
              updateAnnotationUI(ann.id, 'accepted');
            });
            updateBulkActionsBar();
            const skippedMsg = result.skipped > 0 ? ' (' + result.skipped + ' saltats)' : '';
            showToast('Tots els canvis aplicats (' + result.applied + ')' + skippedMsg, 'success');
          } else {
            showToast(result.error || 'Error aplicant canvis', 'error');
          }
        };

        const failureHandler = function(err) {
          showToast('Error: ' + err.message, 'error');
        };

        // v17.31: Unificat - sempre usa applyFindReplaceChanges amb mateixa estructura que acceptSingleAnnotation
        // El backend decideix si usar find/replace o original_text/new_text
        const changes = pending.map(ann => {
          // v17.32: Debug logging per diagnosticar undo
          console.log('[v17.32] Building change for', ann.id, {
            para_id: ann.para_id,
            hasFind: !!ann.find,
            hasOriginalText: !!ann.originalText,
            hasProposedText: !!ann.proposedText,
            find_preview: ann.find ? ann.find.substring(0, 30) : null,
            originalText_preview: ann.originalText ? ann.originalText.substring(0, 50) : null
          });
          // v17.39: Preservar strings buits per eliminacions
          return {
            targetId: ann.para_id,
            // Mode FIX: find/replace atòmic (replace pot ser "" per eliminacions!)
            find: typeof ann.find === 'string' ? ann.find : null,
            replace: typeof ann.replace === 'string' ? ann.replace : null,
            // Mode IMPROVE/altres: original_text/new_text per full-replace
            // v17.43: typeof check per preservar "" (Google Apps Script converteix "" a null!)
            original_text: typeof ann.originalText === 'string' ? ann.originalText : null,
            new_text: typeof ann.proposedText === 'string' ? ann.proposedText : null,
            // Highlight precís
            highlight_find: typeof ann.highlight_find === 'string' ? ann.highlight_find : null,
            highlight_replace: typeof ann.highlight_replace === 'string' ? ann.highlight_replace : null,
            context: ann.context || null
          };
        });

        google.script.run
          .withSuccessHandler(successHandler)
          .withFailureHandler(failureHandler)
          .applyFindReplaceChanges(changes);
      }

      /**
       * v17.52: Actualitza la UI d'una anotació segons el seu status
       * Actualitza TOTS els elements amb el mateix ID (per duplicats de converses anteriors)
       */
      function updateAnnotationUI(annotationId, status, providedElement) {
        // v17.52: Trobar TOTS els elements amb aquest ID
        const allItems = document.querySelectorAll('.annotation-item[data-id="' + annotationId + '"]');
        console.log('[v17.52] updateAnnotationUI:', annotationId, '→', status, '| Found', allItems.length, 'elements');

        if (allItems.length === 0) {
          console.warn('[v17.52] No elements found for:', annotationId);
          return;
        }

        // v17.52: Actualitzar CADA element trobat
        allItems.forEach(function(el, idx) {
          var oldStatus = el.getAttribute('data-status');
          console.log('[v17.52] Element', idx, ':', oldStatus, '→', status);

          // 1. Actualitzar data-status
          el.setAttribute('data-status', status);

          // 2. Actualitzar text d'status
          var statusEl = el.querySelector('.annotation-status');
          if (statusEl) {
            if (status === 'accepted') {
              statusEl.innerHTML = icon('checkCircle', 'i--sm') + ' Aplicat';
            } else if (status === 'pending') {
              statusEl.innerHTML = '';
            }
          }

          // 3. Actualitzar botons
          var actionsEl = el.querySelector('.annotation-actions');
          if (!actionsEl) return;

          var undoBtn = actionsEl.querySelector('.btn-undo');
          var acceptBtn = actionsEl.querySelector('.btn-accept');

          if (status === 'accepted') {
            // Treure accept, afegir undo
            if (acceptBtn) acceptBtn.remove();
            if (!undoBtn) {
              var newUndoBtn = document.createElement('button');
              newUndoBtn.className = 'btn-undo';
              newUndoBtn.title = 'Desfer';
              newUndoBtn.innerHTML = icon('undo', 'i--sm');
              newUndoBtn.onclick = function() { undoSingleAnnotation(annotationId); };
              actionsEl.appendChild(newUndoBtn);
            }
          } else if (status === 'pending') {
            // Treure undo, afegir accept
            if (undoBtn) undoBtn.remove();
            if (acceptBtn) acceptBtn.remove(); // Treure per evitar duplicats
            var newAcceptBtn = document.createElement('button');
            newAcceptBtn.className = 'btn-accept';
            newAcceptBtn.title = 'Acceptar';
            newAcceptBtn.innerHTML = icon('check', 'i--sm');
            newAcceptBtn.onclick = function() { acceptSingleAnnotation(annotationId, newAcceptBtn); };
            actionsEl.appendChild(newAcceptBtn);
            console.log('[v17.52] Created accept button for element', idx);
          }
        });
      }

      /**
       * v16.1: Desfer un canvi individual
       * Usa event_id (persistent via Supabase) o undoSnapshot (local immediat)
       */
      function undoSingleAnnotation(annotationId) {
        // v17.38: Debug exhaustiu
        console.log('[v17.38] undoSingleAnnotation called for:', annotationId);
        console.log('[v17.38] pendingAnnotations count:', pendingAnnotations.length);
        console.log('[v17.38] pendingAnnotations IDs:', pendingAnnotations.map(a => a.id));

        const ann = pendingAnnotations.find(a => a.id === annotationId);

        // v17.38: Debug de l'anotació trobada
        console.log('[v17.38] Found ann:', !!ann);
        if (ann) {
          console.log('[v17.38] ann.status:', ann.status);
          console.log('[v17.38] ann.undoSnapshot:', !!ann.undoSnapshot, ann.undoSnapshot ? JSON.stringify(ann.undoSnapshot).substring(0, 100) : 'null');
          console.log('[v17.38] ann.event_id:', ann.event_id);
        }

        // Verificar que tenim algun mètode de desfer
        if (!ann || (!ann.undoSnapshot && !ann.event_id)) {
          console.warn('[v17.38] Cannot undo - no snapshot or event_id!');
          showToast('No es pot desfer aquest canvi', 'warning');
          return;
        }

        // Desactivar botó mentre es processa
        const el = document.querySelector('.annotation-item[data-id="' + annotationId + '"]');
        const undoBtn = el ? el.querySelector('.btn-undo') : null;
        if (undoBtn) {
          undoBtn.disabled = true;
          undoBtn.innerHTML = icon('loader', 'i--sm');
        }

        const handleUndoSuccess = function(result) {
          // v17.49: Debug logging exhaustiu
          console.log('[v17.49] handleUndoSuccess CALLED for:', annotationId);
          console.log('[v17.49] result:', JSON.stringify(result));
          // Verificar èxit segons el tipus de resposta
          const success = result && (result.ok || result.success || result.status === 'restored');
          console.log('[v17.49] success:', success, 'result.ok:', result?.ok, 'result.fallback:', result?.fallback);
          if (success) {
            // v17.49: Tornar a estat 'pending' per poder re-aplicar el canvi
            console.log('[v17.49] Setting ann.status to pending');
            ann.status = 'pending';
            ann.undoSnapshot = null;
            ann.event_id = null;
            console.log('[v17.49] Calling updateAnnotationUI with pending');
            updateAnnotationUI(annotationId, 'pending');
            console.log('[v17.49] updateAnnotationUI completed');
            showToast('Canvi desfet - pots tornar a aplicar-lo', 'undo');
            updateBulkActionsBar();  // Actualitzar comptador de pendents

            // v16.7: Netejar highlight del document després d'1.5 segons
            const paraId = result.targetId !== undefined ? result.targetId : ann.para_id;
            if (paraId !== undefined) {
              setTimeout(function() {
                google.script.run.clearHighlightByParaId(paraId);
              }, 1500);
            }
          } else {
            showToast(result.error || 'Error desfent canvi', 'error');
            if (undoBtn) {
              undoBtn.disabled = false;
              undoBtn.innerHTML = icon('undo', 'i--sm');
            }
          }
        };

        const handleUndoFailure = function(err) {
          showToast('Error: ' + err.message, 'error');
          if (undoBtn) {
            undoBtn.disabled = false;
            undoBtn.innerHTML = icon('undo', 'i--sm');
          }
        };

        // v17.48: Prioritzar undoSnapshot (local, immediat) sobre event_id
        // v16.1 tenia event_id primer però és més lent (Supabase async)
        if (ann.undoSnapshot) {
          // v17.48: Debug complet del snapshot
          console.log('[v17.48] Using undoSnapshot:', {
            mode: ann.undoSnapshot.mode,
            find: ann.undoSnapshot.find,
            replace: ann.undoSnapshot.replace,
            targetId: ann.undoSnapshot.targetId,
            hasOriginalText: !!ann.undoSnapshot.originalText
          });
          google.script.run
            .withSuccessHandler(handleUndoSuccess)
            .withFailureHandler(handleUndoFailure)
            .undoAnnotationChange(ann.undoSnapshot);
        } else if (ann.event_id) {
          // Fallback a undo persistent via Supabase
          console.log('[v17.48] Using event_id fallback:', ann.event_id);
          google.script.run
            .withSuccessHandler(handleUndoSuccess)
            .withFailureHandler(handleUndoFailure)
            .revertEditById(ann.event_id);
        } else {
          console.error('[v17.48] No undo method available!');
          showToast('No es pot desfer aquest canvi', 'error');
        }
      }

      /**
       * Actualitza la barra d'accions bulk
       */
      function updateBulkActionsBar() {
        const bulkBar = document.querySelector('.annotation-bulk-actions');
        if (!bulkBar) return;

        const pending = pendingAnnotations.filter(a => a.type === 'change' && a.status === 'pending');

        // v14.5: Amagar barra bulk si només queda 0 o 1 canvi (botons individuals suficients)
        if (pending.length <= 1) {
          bulkBar.style.display = 'none';
        } else {
          bulkBar.style.display = 'flex';
          const infoEl = bulkBar.querySelector('.bulk-info');
          if (infoEl) {
            infoEl.textContent = pending.length + ' canvis pendents';
          }
        }
      }

      // ═══════════════════════════════════════════════════════════
      // v7.1: CHAT LANDING - Pantalla inicial interactiva
      // ═══════════════════════════════════════════════════════════

      /**
       * Mostra la landing del xat si no hi ha missatges
       */
      function showChatLanding() {
        const container = document.getElementById('chatHistory');
        const existingLanding = document.getElementById('chatLanding');
        const chatPanel = document.getElementById('chatPanel');

        // Afegir classe per amagar elements del header
        if (chatPanel) chatPanel.classList.add('landing-active');
        const selIndicator = document.getElementById('selectionIndicator');
        if (selIndicator) selIndicator.classList.add('landing-mode');

        // Si ja existeix, només mostrar-la
        if (existingLanding) {
          existingLanding.classList.remove('hidden');
          return;
        }

        // Salutació dinàmica segons hora i varietat
        function getGreeting() {
          const hour = new Date().getHours();
          const greetings = {
            morning: [
              'Bon dia! Què escrivim avui?',
              'Bon dia! Com et puc ajudar?',
              'Bon dia! A punt per escriure?',
              'Bon dia! En què treballem?'
            ],
            afternoon: [
              'Bona tarda! Què necessites?',
              'Bona tarda! Com t\'ajudo?',
              'Bona tarda! A punt!',
              'Bona tarda! Què fem?'
            ],
            evening: [
              'Bona nit! Encara escrivint?',
              'Bona nit! En què t\'ajudo?',
              'Bona nit! Què necessites?',
              'Bona nit! A punt per ajudar!'
            ],
            generic: [
              'Hola! En què et puc ajudar?',
              'Hola! Què necessites?',
              'Hola! A punt per escriure!',
              'Hola! Com t\'ajudo avui?'
            ]
          };

          let pool;
          if (hour >= 6 && hour < 13) pool = greetings.morning;
          else if (hour >= 13 && hour < 20) pool = greetings.afternoon;
          else if (hour >= 20 || hour < 6) pool = greetings.evening;
          else pool = greetings.generic;

          return pool[Math.floor(Math.random() * pool.length)];
        }

        // Icones SVG minimalistes
        const icons = {
          edit: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg>',
          lightbulb: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9 18h6M10 22h4M12 2a7 7 0 0 0-4 12.9V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.1A7 7 0 0 0 12 2z"/></svg>',
          summarize: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 6h16M4 10h16M4 14h10M4 18h7"/></svg>',
          style: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>',
          settings: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>',
          list: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><line x1="9" y1="6" x2="20" y2="6"/><line x1="9" y1="12" x2="20" y2="12"/><line x1="9" y1="18" x2="20" y2="18"/><circle cx="5" cy="6" r="1.5" fill="currentColor"/><circle cx="5" cy="12" r="1.5" fill="currentColor"/><circle cx="5" cy="18" r="1.5" fill="currentColor"/></svg>'
        };

        const suggestions = [
          { icon: icons.edit, color: '#4CAF50', text: "Corregeix", prompt: "Corregeix tots els errors ortogràfics, gramaticals i de puntuació. Manté l'estil i to originals." },
          { icon: icons.lightbulb, color: '#FF9800', text: 'Explica', prompt: "Explica el contingut d'aquest text de forma clara, destacant les idees principals i la seva relació." },
          { icon: icons.summarize, color: '#2196F3', text: 'Resumeix', prompt: "Resumeix el text en un terç de la seva extensió original, preservant les idees clau i l'estructura argumentativa." },
          { icon: icons.style, color: '#9C27B0', text: "Millora", prompt: "Millora la claredat, fluïdesa i precisió del text. Elimina redundàncies i reforça la cohesió entre frases." },
          { icon: icons.settings, color: '#607D8B', text: "Tècnic", prompt: "Transforma el text a un registre tècnic: usa terminologia precisa, estructura lògica i elimina ambigüitats. Manté la informació factual." },
          { icon: icons.list, color: '#00BCD4', text: "Bullets", prompt: "Reorganitza el contingut en llista amb bullets. Cada punt ha de ser independent i complet. Agrupa elements relacionats." }
        ];

        let cardsHtml = suggestions.map(function(s) {
          const onclick = s.action ? s.action : "useSuggestion('" + s.prompt.replace(/'/g, "\\'") + "')";
          return '<button class="suggestion-card" onclick="' + onclick + '">' +
            '<span class="suggestion-icon" style="color:' + s.color + '">' + s.icon + '</span>' +
            '<span class="suggestion-text">' + s.text + '</span>' +
            '</button>';
        }).join('');

        const landingHtml = '<div id="chatLanding" class="chat-landing">' +
          '<div class="landing-greeting">' +
            '<div class="landing-logo">' +
              '<svg width="140" height="40" viewBox="0 0 200 56" xmlns="http://www.w3.org/2000/svg">' +
                '<g transform="translate(4, 4)">' +
                  '<rect x="0" y="0" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="17" y="0" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="34" y="0" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="0" y="17" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="17" y="17" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="34" y="17" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="0" y="34" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="17" y="34" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<rect x="34" y="34" width="14" height="14" rx="1" fill="#6AC1E4"/>' +
                  '<line x1="0" y1="48" x2="48" y2="0" stroke="#3B75A8" stroke-width="4" stroke-linecap="round"/>' +
                '</g>' +
                '<text x="62" y="38" font-family="system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif" font-size="32" font-weight="500" fill="#3B75A8" letter-spacing="-0.5">docmile</text>' +
              '</svg>' +
            '</div>' +
            '<p class="landing-subtitle">' + getGreeting() + '</p>' +
          '</div>' +
          '<div class="landing-suggestions">' +
            '<div class="suggestion-grid">' + cardsHtml + '</div>' +
          '</div>' +
        '</div>';

        container.innerHTML = landingHtml;
      }

      /**
       * Usa un suggeriment de la landing
       */
      function useSuggestion(prompt) {
        hideChatLanding();
        const input = document.getElementById('userInput');
        input.value = prompt;
        sendMessage();
      }

      /**
       * Amaga la landing del xat
       */
      function hideChatLanding() {
        const landing = document.getElementById('chatLanding');
        const chatPanel = document.getElementById('chatPanel');

        // Treure classe per mostrar elements del header
        if (chatPanel) chatPanel.classList.remove('landing-active');
        const selIndicator = document.getElementById('selectionIndicator');
        if (selIndicator) selIndicator.classList.remove('landing-mode');

        if (landing) {
          landing.remove();
        }
      }

      function showThinking() {
        const container = document.getElementById('chatHistory');
        const thinking = document.createElement('div');
        thinking.className = 'msg thinking';
        thinking.id = 'thinkingIndicator';
        thinking.innerHTML = '<div class="thinking-shimmer"></div>';
        container.appendChild(thinking);
        container.scrollTop = container.scrollHeight;
      }

      function hideThinking() {
        const indicator = document.getElementById('thinkingIndicator');
        if (indicator) indicator.remove();
      }

      /**
       * v6.9: Cancel·la el procés en curs (ESC key)
       */
      function cancelCurrentRequest() {
        if (!requestInProgress) return;

        requestCancelled = true;
        requestInProgress = false;
        hideThinking();
        document.getElementById('sendBtn').disabled = false;
        document.getElementById('userInput').disabled = false;

        // Afegir missatge de cancel·lació
        addBubble('system', icon('x', 'i--sm i--muted') + ' Interromput');

        console.log('[Docmile] Request cancelled by user (ESC)');
      }

      // v14.8: ESC key listener amb registre per cleanup
      const handleEscapeKey = function(e) {
        if (e.key === 'Escape' && requestInProgress) {
          e.preventDefault();
          cancelCurrentRequest();
        }
      };
      registerListener(document, 'keydown', handleEscapeKey);

      // ═══════════════════════════════════════════════════════════
      // OPTIMISTIC UI UNDO (v2.6 Sprint)
      // ═══════════════════════════════════════════════════════════

      function showUndoBar() {
        // Remove existing undo bar if any
        hideUndoBar();

        const container = document.getElementById('chatHistory');
        const undoBar = document.createElement('div');
        undoBar.className = 'undo-bar';
        undoBar.id = 'undoBar';
        undoBar.innerHTML = `
          <div class="undo-bar-text">
            <span class="i i--sm i--warning"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>
            <span>Text modificat</span>
          </div>
          <div class="undo-bar-actions">
            <button class="btn-icon confirm" onclick="commitChange()"><span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg></span> Acceptar</button>
            <button class="btn-icon undo" onclick="triggerUndo()"><span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg></span> Desfer</button>
          </div>
        `;
        container.appendChild(undoBar);
        container.scrollTop = container.scrollHeight;
      }

      function hideUndoBar() {
        const existing = document.getElementById('undoBar');
        if (existing) existing.remove();
      }

      function commitChange() {
        // L'usuari accepta el canvi - simplement amaguem la barra
        pendingUndo = null;
        hideUndoBar();
        addBubble('system', icon('check', 'i--sm i--success') + ' Perfecte!');
      }

      function triggerUndo() {
        if (!pendingUndo) {
          addBubble('error', 'No hi ha cap canvi per desfer');
          hideUndoBar();
          return;
        }

        // Bloquejar la UI
        const undoBar = document.getElementById('undoBar');
        if (undoBar) {
          undoBar.classList.add('restoring');
          const textEl = undoBar.querySelector('.undo-bar-text span:last-child');
          if (textEl) textEl.textContent = 'Restaurant';
        }

        google.script.run
          .withSuccessHandler(function(res) {
            hideUndoBar();
            if (res.status === 'restored') {
              pendingUndo = null;
              addBubble('system', icon('undo', 'i--sm i--accent') + ' Restaurat!');
            } else {
              addBubble('error', 'Error: ' + (res.error || 'No s\'ha pogut restaurar'));
            }
          })
          .withFailureHandler(function(err) {
            hideUndoBar();
            addBubble('error', 'Error: ' + err.message);
          })
          .restoreText(pendingUndo.targetId, pendingUndo.originalText, pendingUndo.bodyIndex, pendingUndo.formatSnapshot);  // v6.6: bodyIndex
      }

      // ═══════════════════════════════════════════════════════════
      // RECEIPTS
      // ═══════════════════════════════════════════════════════════

      function loadReceipts() {
        const container = document.getElementById('receiptsList');
        container.innerHTML = '<div class="loading-text">Carregant receptes...</div>';

        google.script.run
          .withSuccessHandler(function(result) {
            container.innerHTML = '';
            if (result.receipts && result.receipts.length > 0) {
              result.receipts.forEach(function(r, index) {
                const card = document.createElement('div');
                card.className = 'receipt-card';
                card.style.animationDelay = (index * 50) + 'ms';
                const recipeIconName = mapEmojiToIcon(r.icon || r.emoji || 'zap');
                card.innerHTML = `
                  <span class="i i--accent">${ICONS[recipeIconName] || ICONS.circle}</span>
                  <span class="label">${r.label}</span>
                  <button class="delete-btn" onclick="event.stopPropagation(); deleteReceipt('${r.id}')"><span class="i i--sm"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>
                `;
                card.onclick = function() { runReceipt(r.instruction, r.label); };
                container.appendChild(card);
              });
            } else {
              container.innerHTML = '<div class="empty-state">Cap recepta encara.<br>Crea la primera!</div>';
            }
          })
          .withFailureHandler(function(err) {
            container.innerHTML = '<div class="empty-state" style="color: var(--error);">Error carregant receptes</div>';
          })
          .getReceiptsFromWorker();
      }

      function toggleNewReceiptForm() {
        const form = document.getElementById('newReceiptForm');
        form.classList.toggle('hidden');
        if (!form.classList.contains('hidden')) {
          document.getElementById('receiptLabel').value = '';
          document.getElementById('receiptInstruction').value = '';
          selectIcon('zap');
        }
      }

      function selectIcon(iconName) {
        selectedIcon = iconName;
        document.querySelectorAll('.icon-picker-btn').forEach(function(btn) {
          btn.classList.remove('selected');
          if (btn.dataset.icon === iconName) btn.classList.add('selected');
        });
      }

      function saveNewReceipt() {
        const label = document.getElementById('receiptLabel').value.trim();
        const instruction = document.getElementById('receiptInstruction').value.trim();

        if (!label) return alert('Posa un nom al boto');
        if (!instruction) return alert('Escriu la instruccio per la IA');

        google.script.run
          .withSuccessHandler(function() {
            toggleNewReceiptForm();
            loadReceipts();
          })
          .withFailureHandler(function(err) {
            alert('Error: ' + err.message);
          })
          .saveReceiptToWorker(label, instruction, selectedIcon);
      }

      function deleteReceipt(receiptId) {
        if (!confirm('Eliminar aquesta recepta?')) return;

        google.script.run
          .withSuccessHandler(function() {
            loadReceipts();
          })
          .withFailureHandler(function(err) {
            alert('Error: ' + err.message);
          })
          .deleteReceiptFromWorker(receiptId);
      }

      function runReceipt(instruction, label) {
        switchTab('chat');
        hideChatLanding();
        // v9.3: Use addBubbleHtml to render icon properly (not escaped)
        const escapedLabel = label.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const receiptHtml = '<div class="user-text">' + icon('target', 'i--sm i--accent') + ' ' + escapedLabel + '</div>';
        addBubbleHtml('user', receiptHtml, null, instruction);
        showThinking();

        document.getElementById('sendBtn').disabled = true;

        google.script.run
          .withSuccessHandler(function(res) {
            hideThinking();
            document.getElementById('sendBtn').disabled = false;

            // v10.2: Handle In-Document Preview (same logic as sendMessage)
            if (res.status === 'in_doc_preview') {
              const previewCount = res.changes_count || res.preview_info?.count || 1;
              addBubble('ai', res.ai_response, false);
              addBubble('review-note', '<button class="inline-eye-btn" onclick="scrollToLastEdit(this)" title="Veure al document">' + icon('eye', 'i--sm i--accent') + '</button> Revisa els canvis al document.');
              showInDocPreviewBar(previewCount);
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // Handle in_doc_preview with error
            if (res.status === 'in_doc_preview_error') {
              addBubble('ai', res.ai_response, false);
              addBubble('system', icon('alertTriangle', 'i--sm i--warning') + ' ' + (res.preview_error || 'Error aplicant preview al document'));
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // v11.0: Handle Preview Mode with Unified Annotations
            // v12.1: Afegit suport per modification_type i find/replace per mode FIX
            if (res.status === 'preview' && res.changes && res.changes.length > 0) {
              var annotations = res.changes.map(function(c, i) {
                return {
                  id: 'change-' + i,
                  type: 'change',
                  para_id: parseInt(c.targetId !== undefined ? c.targetId : c.paragraph_id),
                  // v16.3: Arreglat mapeig de camps - backend envia snake_case
                  // v17.6: Netejar marcadors interns
                  // v17.7: c.original és el paràgraf complet, NO usar com fallback per find
                  originalText: cleanInternalMarkers(c.originalText || c.original_text || c.original || null),
                  // v17.44: typeof check per preservar "" (eliminacions!)
                  proposedText: cleanInternalMarkers(
                    typeof c.proposedText === 'string' ? c.proposedText :
                    typeof c.new_text === 'string' ? c.new_text :
                    typeof c.replacement === 'string' ? c.replacement : null
                  ),
                  // v12.1: Camps per mode FIX (find/replace natiu)
                  // v17.7: NOMÉS usar c.find/c.replace - c.original és el paràgraf COMPLET, no el fragment
                  // v17.39: Preservar strings buits per eliminacions (replace pot ser "")
                  find: cleanInternalMarkers(typeof c.find === 'string' ? c.find : null),
                  replace: cleanInternalMarkers(typeof c.replace === 'string' ? c.replace : null),
                  // v16.7: Text exacte per highlight verd després d'aplicar (sense context extra)
                  highlight_find: typeof c.highlight_find === 'string' ? c.highlight_find : null,
                  highlight_replace: typeof c.highlight_replace === 'string' ? c.highlight_replace : null,
                  context: c.context || null,
                  reason: c.reason || c.explanation || 'Canvi proposat',
                  status: 'pending'
                };
              });
              // v12.1: Passar modification_type per routing híbrid
              addBubbleWithAnnotations(res.ai_response, annotations, res.doc_snapshot, res.modification_type);
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // Handle preview with 0 changes (fallback)
            if (res.status === 'preview' && (!res.changes || res.changes.length === 0)) {
              addBubble('ai', res.ai_response, false);
              addBubble('system', icon('alertTriangle', 'i--sm i--warning') + ' No he pogut aplicar els canvis automàticament.');
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // Normal response handling (chat mode, no edits)
            addBubble('ai', res.ai_response, false);
            if (res.credits !== undefined) {
              updateCredits(res.credits);
            }
            // v3.3: Show undo bar if edit was made
            if (res.mode === 'edit' && res.undo_snapshot) {
              pendingUndo = res.undo_snapshot;
              showUndoBar();
            }
            // v4.0: Confirm hash after successful edit
            if (res.mode === 'edit' && res.event_id) {
              confirmEditHashAsync(res.event_id);
            }
          })
          .withFailureHandler(function(err) {
            hideThinking();
            document.getElementById('sendBtn').disabled = false;
            addBubble('error', 'Error: ' + err.message);
          })
          .processUserCommand(instruction, getRecentHistory(), getCurrentMode(), previewModeEnabled);
      }

      // ═══════════════════════════════════════════════════════════
      // TIMELINE (v4.0 - Forensic Timeline)
      // ═══════════════════════════════════════════════════════════

      /**
       * v4.1: Pre-loads timeline data in background (fire-and-forget)
       * Called on sidebar init to have data ready when user clicks timeline tab
       */
      function preloadTimeline() {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result.status === 'ok' && result.timeline) {
              cachedTimelineData = result.timeline;
            }
          })
          .withFailureHandler(function() {
            // Silent fail - user can refresh manually
          })
          .getDocumentTimeline();
      }

      function loadTimeline(forceRefresh) {
        const container = document.getElementById('timelineContent');

        // v4.1: Use cached data if available and not forcing refresh
        if (!forceRefresh && cachedTimelineData) {
          renderTimeline(cachedTimelineData);
          return;
        }

        container.innerHTML = '<div class="loading-text">Carregant timeline...</div>';

        google.script.run
          .withSuccessHandler(function(result) {
            if (result.status === 'ok' && result.timeline) {
              cachedTimelineData = result.timeline; // v4.1: Cache the data
              renderTimeline(result.timeline);
            } else {
              container.innerHTML = '<div class="timeline-empty"><span class="i i--muted">' + ICONS.clock + '</span><span>No hi ha edicions registrades</span></div>';
            }
          })
          .withFailureHandler(function(err) {
            container.innerHTML = '<div class="timeline-empty" style="color: var(--error);">Error carregant timeline</div>';
          })
          .getDocumentTimeline();
      }

      function renderTimeline(events) {
        const container = document.getElementById('timelineContent');
        container.innerHTML = '';

        if (!events || events.length === 0) {
          container.innerHTML = '<div class="timeline-empty"><span class="i i--muted">' + ICONS.clock + '</span><span>No hi ha edicions registrades</span></div>';
          return;
        }

        // v4.3: Find the first non-invalidated event (this is the "current" version)
        // Events are sorted by created_at DESC, so first valid event is the most recent
        const currentEventIndex = events.findIndex(function(e) {
          return !e.invalidated_at && !e.reverted_at;
        });

        events.forEach(function(event, index) {
          const card = document.createElement('div');
          const isManual = event.source === 'manual' || event.operation === 'manual_gap';
          const isBaseline = event.source === 'baseline' || event.type === 'baseline';
          const isInvalidated = !!event.invalidated_at;
          const isCurrent = index === currentEventIndex;

          // Build class names
          // v4.3: Determine if this event can be reverted
          const hasBeforeText = event.before_text && event.before_text.length > 0;
          const isRevertible = event.source === 'ai' && !event.reverted_at && event.type !== 'REVERT' && !isBaseline && hasBeforeText && !isInvalidated;

          // Build class names
          let cardClasses = 'timeline-card';
          cardClasses += isManual ? ' timeline-manual' : isBaseline ? ' timeline-baseline' : ' timeline-ai';
          if (isInvalidated) cardClasses += ' timeline-invalidated';
          if (isCurrent) cardClasses += ' timeline-current';
          // v4.3: Add reference class for non-revertible events (more subtle)
          if (isManual && !isBaseline) cardClasses += ' timeline-reference';
          if (isBaseline) cardClasses += ' timeline-baseline-ref';
          card.className = cardClasses;
          card.style.animationDelay = (index * 30) + 'ms';

          // Determine icon and label based on source/type
          let iconName = 'edit';
          let sourceLabel = 'IA';
          let description = '';

          if (isManual) {
            iconName = 'penTool';
            sourceLabel = 'A mà';
            description = 'Canvis fets fora de l\'assistent';
          } else if (isBaseline) {
            iconName = 'flag';
            sourceLabel = 'Punt inicial';
            description = 'Primera captura del document';
          } else if (event.type === 'REVERT') {
            iconName = 'rotateCcw';
            sourceLabel = 'Reversió';
            description = 'Edició revertida';
          }

          // Format time
          const timeStr = formatTimelineTime(event.created_at);

          // Words changed indicator - més destacat per manuals
          let wordsInfo = '';
          if (event.words_changed !== null && event.words_changed !== undefined) {
            const sign = event.words_changed >= 0 ? '+' : '';
            const color = event.words_changed >= 0 ? 'var(--success)' : 'var(--error)';
            const label = isManual ? ' paraules modificades' : ' paraules';
            wordsInfo = '<span class="timeline-words" style="color: ' + color + '">' + sign + event.words_changed + label + '</span>';
          } else if (isBaseline && event.word_count) {
            wordsInfo = '<span class="timeline-words" style="color: var(--text-muted)">' + event.word_count + ' paraules al document</span>';
          }

          // Build body content based on type
          let bodyContent = '';
          if (isManual || isBaseline) {
            bodyContent = '<div class="timeline-description">' + description + '</div>' + wordsInfo;
          } else {
            bodyContent =
              (event.instruction ? '<div class="timeline-instruction">' + escapeHtml(event.instruction.substring(0, 100)) + (event.instruction.length > 100 ? '...' : '') + '</div>' : '') +
              (event.thought ? '<div class="timeline-thought">' + escapeHtml(event.thought.substring(0, 80)) + '</div>' : '') +
              wordsInfo;
          }

          // v4.3: Revert button only for revertible events
          let revertButtonHtml = '';
          if (isRevertible) {
            revertButtonHtml = '<button class="timeline-revert-btn-mini" onclick="event.stopPropagation(); revertTimelineEvent(\'' + event.id + '\', \'' + escapeHtml((event.before_text || '').substring(0, 40)).replace(/'/g, "\\'") + '\')" title="Revertir a aquest punt"><span class="i i--xs">' + ICONS.rotateCcw + '</span></button>';
          }

          // v4.3: Status badges - show what type of event this is
          let statusBadge = '';
          if (isCurrent) {
            statusBadge = '<span class="timeline-current-badge">● Actual</span>';
          } else if (isInvalidated) {
            statusBadge = '<span class="timeline-invalidated-badge">Obsolet</span>';
          } else if (isManual || isBaseline) {
            statusBadge = '<span class="timeline-reference-badge">Referència</span>';
          }

          card.innerHTML =
            '<div class="timeline-card-header">' +
              '<span class="timeline-source ' + (isManual ? 'source-manual' : isBaseline ? 'source-baseline' : 'source-ai') + '">' +
                '<span class="i i--xs">' + (ICONS[iconName] || ICONS.circle) + '</span> ' + sourceLabel +
                statusBadge +
              '</span>' +
              '<div class="timeline-header-right">' +
                '<span class="timeline-time">' + timeStr + '</span>' +
                revertButtonHtml +
              '</div>' +
            '</div>' +
            '<div class="timeline-card-body">' + bodyContent + '</div>' +
            (event.reverted_at ? '<div class="timeline-reverted"><span class="i i--xs">' + ICONS.rotateCcw + '</span> Desfet</div>' : '') +
            // Expandable details section (hidden by default)
            '<div class="timeline-details hidden">' +
              (event.before_text ? '<div class="timeline-diff"><span class="diff-label">Abans:</span><div class="diff-text diff-before">' + escapeHtml(event.before_text || '').substring(0, 200) + '</div></div>' : '') +
              (event.after_text && event.after_text !== '[edició manual]' && event.after_text !== '[baseline]' ? '<div class="timeline-diff"><span class="diff-label">Després:</span><div class="diff-text diff-after">' + escapeHtml(event.after_text || '').substring(0, 200) + '</div></div>' : '') +
            '</div>';

          // Click to expand/collapse details
          card.onclick = function() {
            const details = card.querySelector('.timeline-details');
            const isExpanded = card.classList.contains('expanded');

            // Collapse all other cards
            document.querySelectorAll('.timeline-card.expanded').forEach(function(c) {
              c.classList.remove('expanded');
              c.querySelector('.timeline-details').classList.add('hidden');
            });

            // Toggle this card
            if (!isExpanded) {
              card.classList.add('expanded');
              details.classList.remove('hidden');
            }
          };

          container.appendChild(card);
        });
      }

      /**
       * Revert a timeline event
       * @param {string} eventId - ID of the event to revert
       * @param {string} beforeTextPreview - Preview of the original text (optional)
       */
      function revertTimelineEvent(eventId, beforeTextPreview) {
        // Build confirmation message with preview
        let confirmMsg = 'Vols revertir aquesta edició?';
        if (beforeTextPreview && beforeTextPreview.length > 0) {
          confirmMsg = 'Vols revertir aquesta edició?\n\nText original: "' + beforeTextPreview + '..."';
        }

        if (!confirm(confirmMsg)) return;

        showToast('Revertint...', 'info');

        google.script.run
          .withSuccessHandler(function(result) {
            if (result.status === 'ok') {
              if (result.restore_text !== undefined) {
                showToast('Edició revertida correctament!', 'success');
              } else {
                showToast('Edició marcada com a revertida', 'warning');
              }
              loadTimeline(true); // Force refresh after revert
            } else {
              // Missatge d'error més descriptiu
              let errorMsg = result.error || 'No s\'ha pogut revertir';
              if (errorMsg.includes('text anterior')) {
                errorMsg = 'No hi ha text original guardat. Usa Ctrl+Z al document.';
              }
              showToast('Error: ' + errorMsg, 'error');
            }
          })
          .withFailureHandler(function(err) {
            showToast('Error: ' + err.message, 'error');
          })
          .revertEditEvent(eventId);
      }

      function formatTimelineTime(isoString) {
        if (!isoString) return '';
        const date = new Date(isoString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Ara';
        if (diffMins < 60) return 'Fa ' + diffMins + ' min';
        if (diffHours < 24) return 'Fa ' + diffHours + 'h';
        if (diffDays < 7) return 'Fa ' + diffDays + ' dies';

        return date.toLocaleDateString('ca-ES', { day: 'numeric', month: 'short' });
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      /**
       * v4.0: Confirms an edit hash asynchronously (fire-and-forget)
       * Called after a successful edit to close the hash confirmation loop
       */
      function confirmEditHashAsync(eventId) {
        if (!eventId) return;
        // Fire-and-forget: no need to wait for response
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.confirmed) {
              console.log('[Timeline] Hash confirmed for event:', eventId);
              // v4.1: Refresh timeline cache in background after successful edit
              preloadTimeline();
            }
          })
          .withFailureHandler(function(err) {
            console.warn('[Timeline] Hash confirmation failed:', err.message);
          })
          .confirmEditHash(eventId);
      }

      // ═══════════════════════════════════════════════════════════
      // RECIPES MANAGEMENT (v3.6 - Folder System)
      // ═══════════════════════════════════════════════════════════

      // Default folders with recipes
      const DEFAULT_FOLDERS = [
        {
          id: 'redaccio',
          name: 'Redacció',
          icon: 'fileText',
          collapsed: false,
          recipes: [
            { id: 'r1', name: 'Corregir', icon: 'edit', instruction: 'Corregeix tots els errors ortogràfics, gramaticals i de puntuació. No canviïs l\'estil ni el vocabulari.' },
            { id: 'r2', name: 'Formal', icon: 'briefcase', instruction: 'Reescriu el text amb un registre formal i professional. Elimina col·loquialismes, usa vocabulari precís i estructura les frases de forma clara.' },
            { id: 'r3', name: 'Informal', icon: 'messageCircle', instruction: 'Reformula el text amb un to proper i conversacional. Usa frases curtes, expressions naturals i un ritme àgil.' },
            { id: 'r4', name: 'Millorar', icon: 'wand', instruction: 'Refina la redacció: millora la fluïdesa entre frases, elimina repeticions, precisa el vocabulari i reforça la cohesió textual.' },
            { id: 'r5', name: 'Simplificar', icon: 'type', instruction: 'Simplifica el text: usa frases curtes, vocabulari comú i estructura clara. Fes-lo accessible per a qualsevol lector.' },
            { id: 'r6', name: 'Clarificar', icon: 'lightbulb', instruction: 'Clarifica el text: reorganitza les idees en ordre lògic, explicita les connexions implícites entre conceptes i reformula les frases ambigües perquè el significat sigui inequívoc.' }
          ]
        },
        {
          id: 'traduccio',
          name: 'Traducció',
          icon: 'globe',
          collapsed: true,
          recipes: [
            { id: 't1', name: 'Anglès', icon: 'globe', instruction: 'Tradueix el text a anglès. Adapta expressions idiomàtiques i manté el to i registre originals.' },
            { id: 't2', name: 'Castellà', icon: 'globe', instruction: 'Tradueix el text a castellà. Adapta expressions idiomàtiques i manté el to i registre originals.' },
            { id: 't3', name: 'Català', icon: 'globe', instruction: 'Tradueix el text a català. Adapta expressions idiomàtiques i manté el to i registre originals.' },
            { id: 't4', name: 'Francès', icon: 'globe', instruction: 'Tradueix el text a francès. Adapta expressions idiomàtiques i manté el to i registre originals.' }
          ]
        },
        {
          id: 'longitud',
          name: 'Longitud',
          icon: 'ruler',
          collapsed: true,
          recipes: [
            { id: 'l1', name: 'Resumir', icon: 'minimize', instruction: 'Resumeix el text reduint-lo a un terç. Preserva les idees principals, elimina detalls secundaris i manté la coherència.' },
            { id: 'l2', name: 'Ampliar', icon: 'maximize', instruction: 'Amplia el text afegint detalls, exemples i explicacions. Desenvolupa cada idea sense repetir-te ni afegir informació inventada.' },
            { id: 'l3', name: 'Concís', icon: 'target', instruction: 'Condensa el text: elimina redundàncies, paraules de farcit i circumloquis. Cada frase ha de dir alguna cosa nova.' }
          ]
        },
        {
          id: 'estil',
          name: 'Estil',
          icon: 'wand',
          collapsed: true,
          recipes: [
            { id: 's1', name: 'Persuasiu', icon: 'zap', instruction: 'Reescriu el text amb to persuasiu: reforça els arguments, afegeix crides a l\'acció i usa llenguatge que connecti emocionalment amb el lector.' },
            { id: 's2', name: 'Creatiu', icon: 'star', instruction: 'Reformula el text amb estil creatiu: usa metàfores, varia el ritme de les frases i afegeix un toc distintiu que el faci memorable.' },
            { id: 's3', name: 'Tècnic', icon: 'settings', instruction: 'Transforma el text a un registre tècnic: usa terminologia precisa, estructura lògica i elimina ambigüitats. Manté la informació factual.' },
            { id: 's4', name: 'Bullets', icon: 'list', instruction: 'Reorganitza el contingut en llista amb bullets. Cada punt ha de ser independent i complet. Agrupa elements relacionats.' }
          ]
        }
      ];

      let userFolders = [];
      let currentSearch = '';
      let selectedFolderId = null;

      // Load folders from backend
      function loadRecipes() {
        google.script.run
          .withSuccessHandler(function(data) {
            if (data && data.length > 0 && data[0].recipes) {
              // Already folder format - filter out "Importades" if exists
              userFolders = data.filter(function(f) {
                return !f.id.startsWith('imported_') && f.name !== 'Importades';
              });
              if (userFolders.length !== data.length) {
                saveRecipes(); // Save without Importades
              }
            } else {
              // First time or old format: load defaults
              userFolders = JSON.parse(JSON.stringify(DEFAULT_FOLDERS));
              saveRecipes();
            }
            renderFolders();
          })
          .withFailureHandler(function(err) {
            console.error('Error loading recipes:', err);
            userFolders = JSON.parse(JSON.stringify(DEFAULT_FOLDERS));
            renderFolders();
          })
          .getRecipes();
      }

      // Save folders to backend
      function saveRecipes() {
        google.script.run
          .withFailureHandler(function(err) {
            console.error('Error saving recipes:', err);
          })
          .saveRecipes(userFolders);
      }

      // ═══════════════════════════════════════════════════════════════
      // RECIPES VIEW MODE (1, 2, 3 columns)
      // ═══════════════════════════════════════════════════════════════

      let recipesViewMode = 1; // Default: list view

      const VIEW_ICONS = {
        1: '<svg viewBox="0 0 24 24"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
        2: '<svg viewBox="0 0 24 24"><rect x="3" y="3" width="8" height="8" rx="1"/><rect x="13" y="3" width="8" height="8" rx="1"/><rect x="3" y="13" width="8" height="8" rx="1"/><rect x="13" y="13" width="8" height="8" rx="1"/></svg>',
        3: '<svg viewBox="0 0 24 24"><rect x="3" y="3" width="5" height="5" rx="1"/><rect x="10" y="3" width="5" height="5" rx="1"/><rect x="17" y="3" width="5" height="5" rx="1"/><rect x="3" y="10" width="5" height="5" rx="1"/><rect x="10" y="10" width="5" height="5" rx="1"/><rect x="17" y="10" width="5" height="5" rx="1"/><rect x="3" y="17" width="5" height="5" rx="1"/><rect x="10" y="17" width="5" height="5" rx="1"/><rect x="17" y="17" width="5" height="5" rx="1"/></svg>'
      };

      // v8.1: Get preview text from instruction
      function getRecipePreview(instruction, maxLen) {
        if (!instruction) return '';
        // Clean up: remove extra whitespace, newlines
        let preview = instruction.replace(/\s+/g, ' ').trim();
        // Escape HTML
        preview = preview.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // Truncate
        if (preview.length > maxLen) {
          preview = preview.substring(0, maxLen - 1) + '…';
        }
        return preview;
      }

      function initRecipesView() {
        const saved = localStorage.getItem('recipesViewMode');
        if (saved) {
          recipesViewMode = parseInt(saved) || 1;
        }
        applyRecipesView();
      }

      function cycleRecipesView() {
        recipesViewMode = recipesViewMode >= 3 ? 1 : recipesViewMode + 1;
        localStorage.setItem('recipesViewMode', recipesViewMode);
        applyRecipesView();
      }

      function applyRecipesView() {
        const container = document.getElementById('recipesContainer');
        const iconEl = document.getElementById('recipesViewIcon');

        if (container) {
          container.classList.remove('view-1', 'view-2', 'view-3');
          container.classList.add('view-' + recipesViewMode);
        }

        if (iconEl) {
          iconEl.innerHTML = VIEW_ICONS[recipesViewMode];
        }
      }

      // Go back from recipes to chat (with landing if no messages)
      function goBackFromRecipes() {
        switchTab('chat');
      }

      // Filter recipes by search
      function filterRecipes() {
        currentSearch = document.getElementById('recipesSearch').value.toLowerCase();
        renderFolders();
      }

      // Toggle folder collapsed state
      function toggleFolder(folderId) {
        const folder = userFolders.find(f => f.id === folderId);
        if (folder) {
          folder.collapsed = !folder.collapsed;
          saveRecipes();
          renderFolders();
        }
      }

      // Render folders
      function renderFolders() {
        const container = document.getElementById('recipesContainer');
        const emptyState = document.getElementById('recipesEmptyState');
        const noResults = document.getElementById('recipesNoResults');

        if (userFolders.length === 0) {
          container.innerHTML = '';
          emptyState.classList.remove('hidden');
          if (noResults) noResults.classList.add('hidden');
          return;
        }

        emptyState.classList.add('hidden');

        // Check if any recipes match search
        let hasResults = false;
        if (currentSearch) {
          userFolders.forEach(function(folder) {
            folder.recipes.forEach(function(recipe) {
              if (recipe.name.toLowerCase().includes(currentSearch) ||
                  recipe.instruction.toLowerCase().includes(currentSearch)) {
                hasResults = true;
              }
            });
          });
          if (!hasResults) {
            container.innerHTML = '';
            if (noResults) noResults.classList.remove('hidden');
            return;
          }
        }

        if (noResults) noResults.classList.add('hidden');

        let html = '';
        userFolders.forEach(function(folder, folderIndex) {
          const isCollapsed = folder.collapsed && !currentSearch;
          const toggleIcon = isCollapsed ? '▶' : '▼';

          // Filter recipes if searching
          let recipes = folder.recipes;
          if (currentSearch) {
            recipes = folder.recipes.filter(function(r) {
              return r.name.toLowerCase().includes(currentSearch) ||
                     r.instruction.toLowerCase().includes(currentSearch);
            });
            if (recipes.length === 0) return; // Skip empty folders in search
          }

          // Get folder icon (backwards compatible with emojis)
          const folderIconName = mapEmojiToIcon(folder.icon);
          html += '<div class="folder' + (isCollapsed ? ' collapsed' : '') + '" data-folder-id="' + folder.id + '" data-folder-index="' + folderIndex + '" ondragover="onFolderDragOver(event)" ondragleave="onFolderDragLeave(event)" ondrop="onFolderDrop(event)">' +
            '<div class="folder-header" onclick="toggleFolder(\'' + folder.id + '\')">' +
              '<span class="folder-icon">' + icon(folderIconName, 'i--accent') + '</span>' +
              '<span class="folder-name">' + folder.name + '</span>' +
              '<span class="folder-count">' + folder.recipes.length + '</span>' +
              '<span class="folder-toggle">' + (isCollapsed ? icon('chevronRight', 'i--sm') : icon('chevronDown', 'i--sm')) + '</span>' +
              '<div class="folder-actions">' +
                '<button class="folder-action-btn folder-add-btn" onclick="event.stopPropagation(); showAddRecipeToFolder(\'' + folder.id + '\')" title="Afegir recepta">' + icon('plus', 'i--sm') + '</button>' +
                '<button class="folder-action-btn folder-edit-btn" onclick="event.stopPropagation(); showEditFolderModal(' + folderIndex + ')" title="Editar carpeta">' + icon('edit', 'i--sm') + '</button>' +
                '<button class="folder-action-btn folder-delete-btn" onclick="event.stopPropagation(); deleteFolder(' + folderIndex + ')" title="Esborrar carpeta">' + icon('trash', 'i--error i--sm') + '</button>' +
              '</div>' +
            '</div>' +
            '<div class="folder-content">';

          recipes.forEach(function(recipe, recipeIndex) {
            const realRecipeIndex = folder.recipes.indexOf(recipe);
            const escapedInstruction = recipe.instruction.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const escapedName = recipe.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            // Get recipe icon (backwards compatible with emojis)
            const recipeIconName = mapEmojiToIcon(recipe.icon || recipe.emoji || 'circle');
            // v8.1: Preview text for 1 and 2 column views
            // v8.1: Use AI summary if available, otherwise preview of instruction
            const previewText = recipe.summary || getRecipePreview(recipe.instruction, 80);

            html += '<div class="folder-recipe" draggable="true" data-folder-index="' + folderIndex + '" data-recipe-index="' + realRecipeIndex + '" ondragstart="onRecipeDragStart(event)" ondragend="onRecipeDragEnd(event)" onclick="runRecipe(\'' + escapedInstruction + '\', \'' + escapedName + '\')">' +
              '<span class="folder-recipe-drag-handle">' + icon('gripVertical', 'i--sm i--muted') + '</span>' +
              '<span class="folder-recipe-icon">' + icon(recipeIconName, 'i--default') + '</span>' +
              '<span class="folder-recipe-name">' + recipe.name + '</span>' +
              '<span class="folder-recipe-preview">' + previewText + '</span>' +
              '<button class="folder-recipe-edit" onclick="event.stopPropagation(); showEditRecipeModal(' + folderIndex + ', ' + realRecipeIndex + ')" title="Editar">' + icon('edit', 'i--sm') + '</button>' +
              '<button class="folder-recipe-delete" onclick="event.stopPropagation(); deleteRecipeFromFolder(' + folderIndex + ', ' + realRecipeIndex + ')" title="Esborrar">' + icon('x', 'i--sm') + '</button>' +
            '</div>';
          });

          html += '</div></div>';
        });

        container.innerHTML = html;
      }

      // Run a recipe
      function runRecipe(instruction, label) {
        switchTab('chat');
        hideChatLanding();
        // v10.2: Mostrar el prompt complet en lloc de només el títol
        const escapedInstruction = instruction.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
        const recipeHtml = '<div class="user-text">' + escapedInstruction + '</div>';
        // v9.4: Show selection badge when running recipe with selection (like chat)
        const selectionBadge = lastSelectionText || null;
        addBubbleHtml('user', recipeHtml, selectionBadge, instruction);
        showThinking();

        document.getElementById('sendBtn').disabled = true;

        google.script.run
          .withSuccessHandler(function(res) {
            hideThinking();
            document.getElementById('sendBtn').disabled = false;

            // v10.2: Handle In-Document Preview
            if (res.status === 'in_doc_preview') {
              const previewCount = res.changes_count || res.preview_info?.count || 1;
              addBubble('ai', res.ai_response, false);
              addBubble('review-note', '<button class="inline-eye-btn" onclick="scrollToLastEdit(this)" title="Veure al document">' + icon('eye', 'i--sm i--accent') + '</button> Revisa els canvis al document.');
              showInDocPreviewBar(previewCount);
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // Handle in_doc_preview with error
            if (res.status === 'in_doc_preview_error') {
              addBubble('ai', res.ai_response, false);
              addBubble('system', icon('alertTriangle', 'i--sm i--warning') + ' ' + (res.preview_error || 'Error aplicant preview al document'));
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // v11.0: Handle Preview Mode with Unified Annotations
            // v12.1: Afegit suport per modification_type i find/replace per mode FIX
            if (res.status === 'preview' && res.changes && res.changes.length > 0) {
              var annotations = res.changes.map(function(c, i) {
                return {
                  id: 'change-' + i,
                  type: 'change',
                  para_id: parseInt(c.targetId !== undefined ? c.targetId : c.paragraph_id),
                  // v16.3: Arreglat mapeig de camps - backend envia snake_case
                  // v17.6: Netejar marcadors interns
                  // v17.7: c.original és el paràgraf complet, NO usar com fallback per find
                  originalText: cleanInternalMarkers(c.originalText || c.original_text || c.original || null),
                  // v17.44: typeof check per preservar "" (eliminacions!)
                  proposedText: cleanInternalMarkers(
                    typeof c.proposedText === 'string' ? c.proposedText :
                    typeof c.new_text === 'string' ? c.new_text :
                    typeof c.replacement === 'string' ? c.replacement : null
                  ),
                  // v12.1: Camps per mode FIX (find/replace natiu)
                  // v17.7: NOMÉS usar c.find/c.replace - c.original és el paràgraf COMPLET, no el fragment
                  // v17.39: Preservar strings buits per eliminacions (replace pot ser "")
                  find: cleanInternalMarkers(typeof c.find === 'string' ? c.find : null),
                  replace: cleanInternalMarkers(typeof c.replace === 'string' ? c.replace : null),
                  // v16.7: Text exacte per highlight verd després d'aplicar (sense context extra)
                  highlight_find: typeof c.highlight_find === 'string' ? c.highlight_find : null,
                  highlight_replace: typeof c.highlight_replace === 'string' ? c.highlight_replace : null,
                  context: c.context || null,
                  reason: c.reason || c.explanation || 'Canvi proposat',
                  status: 'pending'
                };
              });
              // v12.1: Passar modification_type per routing híbrid
              addBubbleWithAnnotations(res.ai_response, annotations, res.doc_snapshot, res.modification_type);
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // Handle preview with 0 changes (fallback)
            if (res.status === 'preview' && (!res.changes || res.changes.length === 0)) {
              addBubble('ai', res.ai_response, false);
              addBubble('system', icon('alertTriangle', 'i--sm i--warning') + ' No he pogut aplicar els canvis automàticament.');
              if (res.credits !== undefined) {
                updateCredits(res.credits);
              }
              return;
            }

            // Normal response handling (chat mode, no edits)
            // v9.0: Handle proactive highlights
            if (res.proactive_highlights && res.proactive_highlights.length > 0) {
              // Render response with clickable snippets
              addBubbleWithProactiveHighlights(res.ai_response, res.proactive_highlights);
              // Start the 5-second timer
              handleProactiveHighlights(res.proactive_highlights, res.proactive_applied || 0);
            } else {
              addBubble('ai', res.ai_response, false);
            }

            if (res.credits !== undefined) {
              updateCredits(res.credits);
            }
            // v4.0: Confirm hash after successful edit
            if (res.mode === 'edit' && res.event_id) {
              confirmEditHashAsync(res.event_id);
            }
          })
          .withFailureHandler(function(err) {
            hideThinking();
            document.getElementById('sendBtn').disabled = false;
            addBubble('error', 'Error: ' + err.message);
          })
          .processUserCommand(instruction, getRecentHistory(), getCurrentMode(), previewModeEnabled);
      }

      // ═══════════════════════════════════════════════════════════
      // FOLDER MANAGEMENT (v3.6)
      // ═══════════════════════════════════════════════════════════

      // Delete a folder
      function deleteFolder(index) {
        const folder = userFolders[index];
        if (!folder) return;

        const msg = folder.recipes.length > 0
          ? 'Vols esborrar la carpeta "' + folder.name + '" i les seves ' + folder.recipes.length + ' recepta(s)?'
          : 'Vols esborrar la carpeta "' + folder.name + '"?';

        if (confirm(msg)) {
          userFolders.splice(index, 1);
          saveRecipes();
          renderFolders();
        }
      }

      // Delete a recipe from a folder
      function deleteRecipeFromFolder(folderIndex, recipeIndex) {
        if (confirm('Vols esborrar aquesta recepta?')) {
          userFolders[folderIndex].recipes.splice(recipeIndex, 1);
          saveRecipes();
          renderFolders();
        }
      }

      // ═══════════════════════════════════════════════════════════
      // DRAG AND DROP RECIPES
      // ═══════════════════════════════════════════════════════════
      let draggedRecipe = null;
      let dragSourceFolderIndex = null;
      let dragSourceRecipeIndex = null;

      function onRecipeDragStart(event) {
        const recipeEl = event.target.closest('.folder-recipe');
        dragSourceFolderIndex = parseInt(recipeEl.dataset.folderIndex);
        dragSourceRecipeIndex = parseInt(recipeEl.dataset.recipeIndex);
        draggedRecipe = userFolders[dragSourceFolderIndex].recipes[dragSourceRecipeIndex];

        recipeEl.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', ''); // Required for Firefox

        // Add visual feedback to all folders
        setTimeout(function() {
          document.querySelectorAll('.folder').forEach(function(folder) {
            folder.classList.add('drop-target');
          });
        }, 0);
      }

      function onRecipeDragEnd(event) {
        const recipeEl = event.target.closest('.folder-recipe');
        if (recipeEl) {
          recipeEl.classList.remove('dragging');
        }

        // Remove visual feedback from all folders
        document.querySelectorAll('.folder').forEach(function(folder) {
          folder.classList.remove('drop-target', 'drag-over');
        });

        draggedRecipe = null;
        dragSourceFolderIndex = null;
        dragSourceRecipeIndex = null;
      }

      function onFolderDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';

        const folderEl = event.target.closest('.folder');
        if (folderEl && draggedRecipe) {
          folderEl.classList.add('drag-over');
        }
      }

      function onFolderDragLeave(event) {
        const folderEl = event.target.closest('.folder');
        if (folderEl) {
          // Only remove if actually leaving the folder (not entering a child)
          const relatedTarget = event.relatedTarget;
          if (!folderEl.contains(relatedTarget)) {
            folderEl.classList.remove('drag-over');
          }
        }
      }

      function onFolderDrop(event) {
        event.preventDefault();

        const folderEl = event.target.closest('.folder');
        if (!folderEl || !draggedRecipe) return;

        const targetFolderIndex = parseInt(folderEl.dataset.folderIndex);

        // Don't do anything if dropping on same folder
        if (targetFolderIndex === dragSourceFolderIndex) {
          folderEl.classList.remove('drag-over');
          return;
        }

        // Move recipe from source to target folder
        const recipe = userFolders[dragSourceFolderIndex].recipes.splice(dragSourceRecipeIndex, 1)[0];
        userFolders[targetFolderIndex].recipes.push(recipe);

        // Expand target folder if collapsed
        userFolders[targetFolderIndex].collapsed = false;

        saveRecipes();
        renderFolders();

        showToast('Recepta moguda a "' + userFolders[targetFolderIndex].name + '"', 'success');
      }

      // Show new folder modal
      // Available icons for folders and recipes
      const FOLDER_ICONS = ['folder', 'folderOpen', 'fileText', 'globe', 'wand', 'ruler', 'star', 'target', 'briefcase'];
      const RECIPE_ICONS = [
        'wand', 'star', 'zap', 'lightbulb', 'rocket', 'target',
        'edit', 'type', 'list', 'clipboard', 'fileText',
        'messageSquare', 'mail', 'globe', 'link', 'tag', 'hash',
        'book', 'briefcase', 'calendar', 'clock',
        'check', 'pin', 'eye', 'settings'
      ];

      // Render icon selector buttons
      function renderIconSelector(containerId, icons, selectedIcon, selectFn) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = icons.map(function(iconName) {
          const isSelected = iconName === selectedIcon ? ' selected' : '';
          return '<button type="button" class="icon-picker-btn' + isSelected + '" data-icon="' + iconName + '" onclick="' + selectFn + '(\'' + iconName + '\')">' + icon(iconName, 'i--default') + '</button>';
        }).join('');
      }

      function showNewFolderModal() {
        document.getElementById('newFolderName').value = '';
        selectedFolderIcon = 'folder';
        renderIconSelector('folderIconSelector', FOLDER_ICONS, selectedFolderIcon, 'selectFolderIcon');
        const modal = document.getElementById('newFolderModal');
        modal.classList.remove('hidden');
        setTimeout(function() {
          modal.classList.add('visible');
          document.getElementById('newFolderName').focus();
        }, 10);
      }

      // Hide new folder modal
      function hideNewFolderModal() {
        const modal = document.getElementById('newFolderModal');
        modal.classList.remove('visible');
        setTimeout(function() {
          modal.classList.add('hidden');
        }, 200);
      }

      let selectedFolderIcon = 'folder';
      function selectFolderIcon(iconName) {
        selectedFolderIcon = iconName;
        document.querySelectorAll('#folderIconSelector .icon-picker-btn').forEach(function(btn) {
          btn.classList.toggle('selected', btn.dataset.icon === iconName);
        });
      }

      // Save new folder
      function saveNewFolder() {
        const name = document.getElementById('newFolderName').value.trim();

        if (!name) {
          showToast('Escriu un nom per la carpeta', 'warning');
          return;
        }

        const newFolder = {
          id: 'folder_' + Date.now(),
          name: name,
          icon: selectedFolderIcon,
          collapsed: false,
          recipes: []
        };

        userFolders.push(newFolder);
        saveRecipes();
        renderFolders();
        hideNewFolderModal();
      }

      // ═══════════════════════════════════════════════════════════════
      // EDIT FOLDER MODAL FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      let selectedEditFolderIcon = 'folder';

      function showEditFolderModal(folderIndex) {
        const folder = userFolders[folderIndex];
        if (!folder) return;

        document.getElementById('editFolderIndex').value = folderIndex;
        document.getElementById('editFolderName').value = folder.name;
        selectedEditFolderIcon = mapEmojiToIcon(folder.icon);
        renderIconSelector('editFolderIconSelector', FOLDER_ICONS, selectedEditFolderIcon, 'selectEditFolderIcon');

        const modal = document.getElementById('editFolderModal');
        modal.classList.remove('hidden');
        setTimeout(function() {
          modal.classList.add('visible');
          document.getElementById('editFolderName').focus();
        }, 10);
      }

      function hideEditFolderModal() {
        const modal = document.getElementById('editFolderModal');
        modal.classList.remove('visible');
        setTimeout(function() {
          modal.classList.add('hidden');
        }, 200);
      }

      function selectEditFolderIcon(iconName) {
        selectedEditFolderIcon = iconName;
        document.querySelectorAll('#editFolderIconSelector .icon-picker-btn').forEach(function(btn) {
          btn.classList.toggle('selected', btn.dataset.icon === iconName);
        });
      }

      function saveEditFolder() {
        const folderIndex = parseInt(document.getElementById('editFolderIndex').value);
        const name = document.getElementById('editFolderName').value.trim();

        if (!name) {
          showToast('Escriu un nom per la carpeta', 'warning');
          return;
        }

        if (userFolders[folderIndex]) {
          userFolders[folderIndex].name = name;
          userFolders[folderIndex].icon = selectedEditFolderIcon;
          saveRecipes();
          renderFolders();
          hideEditFolderModal();
          showToast('Carpeta actualitzada', 'success');
        }
      }

      // ═══════════════════════════════════════════════════════════════
      // STRICT MODE INFO POPUP
      // ═══════════════════════════════════════════════════════════════

      function toggleStrictModeInfo(event) {
        event.stopPropagation();
        const popup = document.getElementById('strictModePopup');
        popup.classList.toggle('visible');

        // Close when clicking outside
        if (popup.classList.contains('visible')) {
          setTimeout(() => {
            document.addEventListener('click', closeStrictModeInfo);
          }, 10);
        }
      }

      function closeStrictModeInfo() {
        const popup = document.getElementById('strictModePopup');
        popup.classList.remove('visible');
        document.removeEventListener('click', closeStrictModeInfo);
      }

      // ═══════════════════════════════════════════════════════════════
      // KNOWLEDGE FOLDER MODAL FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      function showNewKnowledgeFolderModal() {
        document.getElementById('newKnowledgeFolderName').value = '';
        const modal = document.getElementById('newKnowledgeFolderModal');
        modal.classList.remove('hidden');
        setTimeout(function() {
          modal.classList.add('visible');
          document.getElementById('newKnowledgeFolderName').focus();
        }, 10);
      }

      function hideNewKnowledgeFolderModal() {
        const modal = document.getElementById('newKnowledgeFolderModal');
        modal.classList.remove('visible');
        setTimeout(function() {
          modal.classList.add('hidden');
        }, 200);
      }

      function saveNewKnowledgeFolder() {
        const name = document.getElementById('newKnowledgeFolderName').value.trim();

        if (!name) {
          showToast('Escriu un nom per la carpeta', 'warning');
          return;
        }

        if (name.length > 30) {
          showToast('Nom massa llarg (màx 30 caràcters)', 'warning');
          return;
        }

        // v7.0: Save to database (persistent)
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.status === 'ok') {
              invalidateKnowledgeCache();
              refreshKnowledgeLibrary(false);
              hideNewKnowledgeFolderModal();
              showToast('Carpeta creada: ' + name, 'success');
            }
          })
          .withFailureHandler(function(err) {
            let message = 'Error creant carpeta';
            if (err.message && err.message.includes('duplicate')) {
              message = 'Aquesta carpeta ja existeix';
            }
            showToast(message, 'error');
          })
          .createFolder(name);
      }

      // Show new recipe modal (without pre-selected folder)
      function showNewRecipeModal() {
        // If no folders exist, prompt to create one first
        if (userFolders.length === 0) {
          showToast('Primer crea una carpeta', 'warning');
          showNewFolderModal();
          return;
        }
        // Use first folder as default, or let user choose
        showAddRecipeToFolder(userFolders[0].id);
      }

      // Show add recipe to folder modal
      function showAddRecipeToFolder(folderId) {
        selectedFolderId = folderId;
        document.getElementById('newRecipeName').value = '';
        document.getElementById('newRecipeInstruction').value = '';
        selectedRecipeIcon = 'pin';
        renderIconSelector('recipeIconSelector', RECIPE_ICONS, selectedRecipeIcon, 'selectRecipeIcon');
        const modal = document.getElementById('newRecipeModal');
        modal.classList.remove('hidden');
        setTimeout(function() {
          modal.classList.add('visible');
          document.getElementById('newRecipeName').focus();
        }, 10);
      }

      // Hide new recipe modal
      function hideNewRecipeModal() {
        const modal = document.getElementById('newRecipeModal');
        modal.classList.remove('visible');
        setTimeout(function() {
          modal.classList.add('hidden');
        }, 200);
        selectedFolderId = null;
      }

      /**
       * v6.7: Save a user message as a recipe
       * Called from the save button in user message bubbles
       */
      function saveAsRecipe(btn) {
        const bubble = btn.closest('.msg.user');
        if (!bubble || !bubble.dataset.prompt) {
          showToast('No s\'ha pogut obtenir el text', 'error');
          return;
        }

        const promptText = bubble.dataset.prompt;

        // Ensure we have at least one folder
        if (userFolders.length === 0) {
          userFolders.push({
            id: 'saved_' + Date.now(),
            name: 'Desats',
            icon: 'bookmark',
            collapsed: false,
            recipes: []
          });
          saveRecipes();
        }

        // Open the recipe modal with instruction pre-filled
        selectedFolderId = userFolders[0].id;
        document.getElementById('newRecipeName').value = '';
        document.getElementById('newRecipeInstruction').value = promptText;
        selectedRecipeIcon = 'bookmark';
        renderIconSelector('recipeIconSelector', RECIPE_ICONS, selectedRecipeIcon, 'selectRecipeIcon');

        const modal = document.getElementById('newRecipeModal');
        modal.classList.remove('hidden');
        setTimeout(function() {
          modal.classList.add('visible');
          document.getElementById('newRecipeName').focus();
        }, 10);

        // Visual feedback on button
        btn.classList.add('saved');
        setTimeout(function() { btn.classList.remove('saved'); }, 1000);
      }

      let selectedRecipeIcon = 'pin';
      function selectRecipeIcon(iconName) {
        selectedRecipeIcon = iconName;
        document.querySelectorAll('#recipeIconSelector .icon-picker-btn').forEach(function(btn) {
          btn.classList.toggle('selected', btn.dataset.icon === iconName);
        });
      }

      // Backwards compatibility: map old emojis to icon names
      function mapEmojiToIcon(emoji) {
        const emojiMap = {
          '📁': 'folder', '📂': 'folderOpen', '📝': 'fileText', '🌍': 'globe',
          '✨': 'wand', '📏': 'ruler', '⭐': 'star', '🎯': 'target', '💼': 'briefcase',
          '📌': 'pin', '✏️': 'edit', '🔧': 'settings', '📋': 'clipboard',
          '💡': 'lightbulb', '🚀': 'rocket', '•': 'circle'
        };
        return emojiMap[emoji] || (ICONS[emoji] ? emoji : 'circle');
      }

      // v8.1: Generate recipe summary using AI
      function generateRecipeSummary(name, instruction, callback) {
        google.script.run
          .withSuccessHandler(function(res) {
            if (res && res.status === 'ok' && res.summary) {
              callback(res.summary);
            } else {
              callback(null);
            }
          })
          .withFailureHandler(function() {
            callback(null);
          })
          .callWorker({
            action: 'generate_recipe_summary',
            name: name,
            instruction: instruction
          });
      }

      // Save new recipe to folder
      function saveNewRecipe() {
        const name = document.getElementById('newRecipeName').value.trim();
        const instruction = document.getElementById('newRecipeInstruction').value.trim();

        if (!name) {
          showToast('Escriu un nom per la recepta', 'warning');
          return;
        }
        if (!instruction) {
          showToast('Escriu la instrucció per la recepta', 'warning');
          return;
        }

        const folder = userFolders.find(f => f.id === selectedFolderId);
        if (!folder) {
          showToast('Error: Carpeta no trobada', 'error');
          return;
        }

        // Hide modal immediately for better UX
        hideNewRecipeModal();
        showToast('Generant descripció...', 'info');

        // Generate AI summary
        generateRecipeSummary(name, instruction, function(summary) {
          folder.recipes.push({
            id: 'recipe_' + Date.now(),
            name: name,
            icon: selectedRecipeIcon,
            instruction: instruction,
            summary: summary || '' // v8.1: AI-generated summary
          });

          saveRecipes();
          renderFolders();
          showToast('Recepta creada', 'success');
        });
      }

      // ═══════════════════════════════════════════════════════════════
      // EDIT RECIPE MODAL FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      let selectedEditRecipeIcon = 'wand';

      function showEditRecipeModal(folderIndex, recipeIndex) {
        const folder = userFolders[folderIndex];
        if (!folder) return;
        const recipe = folder.recipes[recipeIndex];
        if (!recipe) return;

        document.getElementById('editRecipeFolderIndex').value = folderIndex;
        document.getElementById('editRecipeIndex').value = recipeIndex;
        document.getElementById('editRecipeName').value = recipe.name;
        document.getElementById('editRecipeInstruction').value = recipe.instruction;
        selectedEditRecipeIcon = mapEmojiToIcon(recipe.icon || recipe.emoji || 'wand');
        renderIconSelector('editRecipeIconSelector', RECIPE_ICONS, selectedEditRecipeIcon, 'selectEditRecipeIcon');

        const modal = document.getElementById('editRecipeModal');
        modal.classList.remove('hidden');
        setTimeout(function() {
          modal.classList.add('visible');
          document.getElementById('editRecipeName').focus();
        }, 10);
      }

      function hideEditRecipeModal() {
        const modal = document.getElementById('editRecipeModal');
        modal.classList.remove('visible');
        setTimeout(function() {
          modal.classList.add('hidden');
        }, 200);
      }

      function selectEditRecipeIcon(iconName) {
        selectedEditRecipeIcon = iconName;
        document.querySelectorAll('#editRecipeIconSelector .icon-picker-btn').forEach(function(btn) {
          btn.classList.toggle('selected', btn.dataset.icon === iconName);
        });
      }

      function saveEditRecipe() {
        const folderIndex = parseInt(document.getElementById('editRecipeFolderIndex').value);
        const recipeIndex = parseInt(document.getElementById('editRecipeIndex').value);
        const name = document.getElementById('editRecipeName').value.trim();
        const instruction = document.getElementById('editRecipeInstruction').value.trim();

        if (!name) {
          showToast('Escriu un nom per la recepta', 'warning');
          return;
        }
        if (!instruction) {
          showToast('Escriu la instrucció per la recepta', 'warning');
          return;
        }

        if (userFolders[folderIndex] && userFolders[folderIndex].recipes[recipeIndex]) {
          const recipe = userFolders[folderIndex].recipes[recipeIndex];
          const instructionChanged = recipe.instruction !== instruction;

          recipe.name = name;
          recipe.instruction = instruction;
          recipe.icon = selectedEditRecipeIcon;

          hideEditRecipeModal();

          // v8.1: Regenerate summary if instruction changed
          if (instructionChanged) {
            showToast('Actualitzant descripció...', 'info');
            generateRecipeSummary(name, instruction, function(summary) {
              recipe.summary = summary || '';
              saveRecipes();
              renderFolders();
              showToast('Recepta actualitzada', 'success');
            });
          } else {
            saveRecipes();
            renderFolders();
            showToast('Recepta actualitzada', 'success');
          }
        }
      }

      // ═══════════════════════════════════════════════════════════
      // SETTINGS
      // ═══════════════════════════════════════════════════════════

      function saveSettings() {
        const btn = document.getElementById('saveBtn');
        btn.disabled = true;
        btn.innerHTML = '<svg class="spinner" width="16" height="16" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" opacity="0.3"/></svg> Desant...';

        const newSettings = {
          license_key: document.getElementById('licenseKey').value,
          style_guide: document.getElementById('styleGuide').value,
          strict_mode: document.getElementById('strictMode').checked
        };

        google.script.run.withSuccessHandler(function() {
          btn.disabled = false;
          btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg> Desar Configuracio';
          currentSettings = newSettings;

          const status = document.getElementById('saveStatus');
          status.classList.add('visible');
          setTimeout(function() { status.classList.remove('visible'); }, 2000);
        }).saveSettings(JSON.stringify(newSettings));
      }

      // ═══════════════════════════════════════════════════════════
      // BYOK (Bring Your Own Key) v12.4
      // ═══════════════════════════════════════════════════════════

      // Models per provider
      const BYOK_MODELS = {
        gemini: {
          'gemini-2.0-flash': 'Gemini 2.0 Flash (Recomanat)',
          'gemini-1.5-pro': 'Gemini 1.5 Pro',
          'gemini-1.5-flash': 'Gemini 1.5 Flash'
        },
        openai: {
          'gpt-4o-mini': 'GPT-4o Mini (Recomanat)',
          'gpt-4o': 'GPT-4o (Més potent)',
          'gpt-4-turbo': 'GPT-4 Turbo'
        },
        claude: {
          'claude-sonnet-4-20250514': 'Claude Sonnet 4 (Recomanat)',
          'claude-3-5-sonnet-20241022': 'Claude 3.5 Sonnet',
          'claude-3-5-haiku-20241022': 'Claude 3.5 Haiku (Ràpid)'
        },
        mistral: {
          'mistral-small-latest': 'Mistral Small (Recomanat)',
          'mistral-large-latest': 'Mistral Large',
          'codestral-latest': 'Codestral (Codi)'
        },
        groq: {
          'llama-3.3-70b-versatile': 'Llama 3.3 70B (Recomanat)',
          'llama-3.1-8b-instant': 'Llama 3.1 8B (Ultraràpid)',
          'mixtral-8x7b-32768': 'Mixtral 8x7B'
        }
      };

      let byokStatus = null;

      function initByokSettings() {
        google.script.run
          .withSuccessHandler(function(status) {
            byokStatus = status;
            updateByokUI(status);
          })
          .getByokStatus();
      }

      function updateByokUI(status) {
        const toggle = document.getElementById('byokEnabled');
        const content = document.getElementById('byokContent');
        const configuredList = document.getElementById('byokConfiguredList');

        if (status.enabled) {
          toggle.checked = true;
          content.style.display = 'block';

          // Select active provider
          document.getElementById('byokProvider').value = status.provider || '';
          if (status.provider) {
            onByokProviderChange();
            document.getElementById('byokModel').value = status.model || '';
          }
        } else {
          toggle.checked = false;
          content.style.display = 'none';
        }

        // Update configured list
        google.script.run
          .withSuccessHandler(function(result) {
            const configured = document.getElementById('byokConfigured');
            const list = document.getElementById('byokConfiguredList');

            const configuredProviders = Object.entries(result.providers)
              .filter(([k, v]) => v.configured);

            if (configuredProviders.length > 0) {
              configured.style.display = 'block';
              list.innerHTML = configuredProviders.map(([id, info]) =>
                `<div class="byok-configured-item ${result.activeProvider === id ? 'active' : ''}">
                   <span class="provider-name">${info.name}</span>
                   <span class="provider-key">${info.masked}</span>
                   <button class="byok-delete-key" onclick="deleteByokKey('${id}')" title="Eliminar">
                     <span class="i i--sm i--error"><svg viewBox="0 0 24 24"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></span>
                   </button>
                 </div>`
              ).join('');
            } else {
              configured.style.display = 'none';
            }
          })
          .getAllApiKeys();
      }

      function toggleByokMode() {
        const enabled = document.getElementById('byokEnabled').checked;
        const content = document.getElementById('byokContent');

        if (enabled) {
          content.style.display = 'block';
          // If there was a previous active provider, select it
          if (byokStatus && byokStatus.provider) {
            document.getElementById('byokProvider').value = byokStatus.provider;
            onByokProviderChange();
          }
        } else {
          content.style.display = 'none';
          // Clear active provider
          google.script.run
            .withSuccessHandler(function() {
              byokStatus = { enabled: false };
              showByokMessage('Mode BYOK desactivat. Usant Docmile central.', 'info');
            })
            .clearActiveProvider();
        }
      }

      function onByokProviderChange() {
        const provider = document.getElementById('byokProvider').value;
        const modelSection = document.getElementById('byokModelSection');
        const keySection = document.getElementById('byokKeySection');

        if (!provider) {
          modelSection.style.display = 'none';
          keySection.style.display = 'none';
          return;
        }

        // Populate model dropdown
        const modelSelect = document.getElementById('byokModel');
        modelSelect.innerHTML = Object.entries(BYOK_MODELS[provider] || {})
          .map(([id, name]) => `<option value="${id}">${name}</option>`)
          .join('');

        modelSection.style.display = 'block';
        keySection.style.display = 'block';

        // Check if key already exists
        google.script.run
          .withSuccessHandler(function(result) {
            const statusEl = document.getElementById('byokKeyStatus');
            if (result.providers[provider] && result.providers[provider].configured) {
              statusEl.innerHTML = `<span class="byok-status-ok">✓ Clau configurada: ${result.providers[provider].masked}</span>`;
              document.getElementById('byokApiKey').placeholder = 'Canviar clau (opcional)...';
            } else {
              statusEl.innerHTML = '';
              document.getElementById('byokApiKey').placeholder = 'Enganxa la teva API key...';
            }
          })
          .getAllApiKeys();
      }

      function toggleApiKeyVisibility() {
        const input = document.getElementById('byokApiKey');
        input.type = input.type === 'password' ? 'text' : 'password';
      }

      function saveByokApiKey() {
        const provider = document.getElementById('byokProvider').value;
        const model = document.getElementById('byokModel').value;
        const apiKey = document.getElementById('byokApiKey').value.trim();

        if (!provider) {
          showByokMessage('Selecciona un proveïdor', 'error');
          return;
        }

        const btn = document.getElementById('byokSaveKeyBtn');
        btn.disabled = true;
        btn.innerHTML = '<svg class="spinner" width="16" height="16" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" opacity="0.3"/></svg> Guardant...';

        // If there's a new API key, save it first
        if (apiKey) {
          // Validate format
          google.script.run
            .withSuccessHandler(function(validation) {
              if (!validation.valid) {
                showByokMessage(validation.error, 'error');
                resetByokSaveBtn();
                return;
              }

              // Save the key
              google.script.run
                .withSuccessHandler(function(saveResult) {
                  if (!saveResult.success) {
                    showByokMessage(saveResult.error, 'error');
                    resetByokSaveBtn();
                    return;
                  }

                  // Now set as active
                  setActiveByokProvider(provider, model);
                })
                .saveApiKey(provider, apiKey);
            })
            .validateApiKey(provider, apiKey);
        } else {
          // No new key, just set as active (must already have a key)
          setActiveByokProvider(provider, model);
        }
      }

      function setActiveByokProvider(provider, model) {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result.success) {
              byokStatus = { enabled: true, provider: provider, model: model };
              showByokMessage(`Ara uses ${result.name} (${model})`, 'success');
              updateByokUI(byokStatus);
              document.getElementById('byokApiKey').value = '';
            } else {
              showByokMessage(result.error, 'error');
            }
            resetByokSaveBtn();
          })
          .setActiveProvider(provider, model);
      }

      function deleteByokKey(provider) {
        if (!confirm(`Segur que vols eliminar la clau de ${provider}?`)) return;

        google.script.run
          .withSuccessHandler(function(result) {
            if (result.success) {
              showByokMessage('Clau eliminada', 'info');
              updateByokUI(byokStatus || { enabled: false });
            } else {
              showByokMessage(result.error, 'error');
            }
          })
          .deleteApiKey(provider);
      }

      function showByokMessage(message, type) {
        const statusEl = document.getElementById('byokKeyStatus');
        const className = type === 'error' ? 'byok-status-error' :
                          type === 'success' ? 'byok-status-ok' : 'byok-status-info';
        statusEl.innerHTML = `<span class="${className}">${message}</span>`;
        setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
      }

      function resetByokSaveBtn() {
        const btn = document.getElementById('byokSaveKeyBtn');
        btn.disabled = false;
        btn.innerHTML = '<span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg></span> Guardar API Key';
      }

      // ═══════════════════════════════════════════════════════════
      // KNOWLEDGE LIBRARY (v6.0 - Multiple Active Files + Folders)
      // ═══════════════════════════════════════════════════════════

      let knowledgeLibrary = [];
      let knowledgeFolders = []; // v6.0: Array of folder names
      let currentFolder = null; // v6.0: Current folder (null = root)
      let activeKnowledgeFiles = []; // v6.0: Array of active files
      let knowledgeLibraryLoaded = false; // v8.1: Cache flag

      // v8.2: Cache TTL for knowledge library
      const KNOWLEDGE_CACHE_TTL = 300000; // 5 minuts
      let knowledgeCacheTimestamp = 0;

      // v8.0: Session files (persistent throughout the session)
      let sessionFiles = [];      // Files that persist for the entire session
      let pendingAttachment = null; // File being uploaded (before send)

      function initKnowledgePanel() {
        loadActiveKnowledgeFiles();
        // v8.1: Only load library if not already loaded
        if (!knowledgeLibraryLoaded) {
          refreshKnowledgeLibrary(true);
        }
      }

      function loadActiveKnowledgeFiles() {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.hasFiles && result.files.length > 0) {
              activeKnowledgeFiles = result.files;
              showActiveFiles(result.files);
              updateChatAttachmentBadge();
            } else {
              activeKnowledgeFiles = [];
              hideActiveFiles();
              hideChatAttachment();
            }
          })
          .getActiveKnowledgeFiles();
      }

      function isFileActive(fileId) {
        return activeKnowledgeFiles.some(f => f.id === fileId);
      }

      function refreshKnowledgeLibrary(forceRefresh) {
        const listEl = document.getElementById('knowledgeLibraryList');
        const now = Date.now();

        // v8.2: Usar cache si vàlid (carregat + no forçat + té dades + no expirat)
        if (knowledgeLibraryLoaded &&
            !forceRefresh &&
            knowledgeLibrary.length > 0 &&
            (now - knowledgeCacheTimestamp) < KNOWLEDGE_CACHE_TTL) {
          console.log('[Cache] Using cached knowledge library');
          renderKnowledgeLibrary();
          return;
        }

        listEl.innerHTML = '<div class="knowledge-empty"><span>Carregant...</span></div>';

        google.script.run
          .withSuccessHandler(function(result) {
            knowledgeLibraryLoaded = true;
            knowledgeCacheTimestamp = Date.now(); // v8.2: Track cache time
            if (result && result.files) {
              knowledgeLibrary = result.files;
              knowledgeFolders = result.folders || [];
              renderKnowledgeLibrary();
            }
          })
          .withFailureHandler(function(err) {
            // v8.2 FIX: Reset cache on failure so retry is possible
            knowledgeCacheTimestamp = 0;
            knowledgeLibraryLoaded = false;
            listEl.innerHTML = '<div class="knowledge-empty"><span>Error carregant biblioteca</span></div>';
          })
          .getKnowledgeLibrary();
      }

      // v8.2: Invalidar cache (cridar abans de refreshKnowledgeLibrary)
      function invalidateKnowledgeCache() {
        knowledgeLibraryLoaded = false;
        knowledgeCacheTimestamp = 0;
        console.log('[Cache] Knowledge library cache invalidated');
      }

      function navigateToFolder(folderName) {
        currentFolder = folderName;
        renderKnowledgeLibrary();
      }

      function navigateToRoot() {
        currentFolder = null;
        renderKnowledgeLibrary();
      }

      function renderKnowledgeLibrary() {
        const listEl = document.getElementById('knowledgeLibraryList');

        // Filter files for current folder
        const currentFiles = knowledgeLibrary.filter(f =>
          currentFolder === null ? !f.folder : f.folder === currentFolder
        );

        // Get folders to show (only at root level)
        const foldersToShow = currentFolder === null ? knowledgeFolders : [];

        if (knowledgeLibrary.length === 0 && knowledgeFolders.length === 0) {
          listEl.innerHTML = `
            <div class="knowledge-empty">
              <span class="i i--muted"><svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg></span>
              <span>Cap fitxer a la biblioteca</span>
            </div>
          `;
          return;
        }

        let html = '';

        // v6.0: Show breadcrumb navigation if inside a folder
        if (currentFolder !== null) {
          html += `
            <div class="folder-breadcrumb" onclick="navigateToRoot()">
              <span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"/></svg></span>
              <span>Tornar</span>
            </div>
            <div class="folder-header">
              <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>
              <span class="folder-name">${escapeHtml(currentFolder)}</span>
              <div class="folder-actions">
                <button class="file-action-btn" onclick="event.stopPropagation(); promptRenameFolder('${escapeHtml(currentFolder)}')" title="Renombrar">
                  <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></span>
                </button>
                <button class="file-action-btn" onclick="event.stopPropagation(); promptDeleteFolder('${escapeHtml(currentFolder)}')" title="Eliminar carpeta">
                  <span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></span>
                </button>
              </div>
            </div>
          `;
        }

        // v6.0: Render folders (only at root)
        foldersToShow.forEach(function(folderName) {
          const filesInFolder = knowledgeLibrary.filter(f => f.folder === folderName).length;
          html += `
            <div class="knowledge-folder-item" onclick="navigateToFolder('${escapeHtml(folderName)}')">
              <span class="folder-icon i i--sm"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>
              <div class="file-info">
                <div class="file-name">${escapeHtml(folderName)}</div>
                <div class="file-meta">${filesInFolder} fitxer${filesInFolder !== 1 ? 's' : ''}</div>
              </div>
              <span class="i i--sm folder-arrow"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"/></svg></span>
            </div>
          `;
        });

        // Render files in current folder
        currentFiles.forEach(function(file) {
          const isActive = isFileActive(file.id);
          const docsCount = (file.used_in_docs || []).length;
          const sizeKB = Math.round(file.size / 1024);

          html += `
            <div class="knowledge-file-item ${isActive ? 'active' : ''}" onclick="toggleKnowledgeFile('${file.id}')">
              <span class="file-icon i i--sm">
                ${isActive
                  ? '<svg viewBox="0 0 24 24"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>'
                  : '<svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>'
                }
              </span>
              <div class="file-info">
                <div class="file-name">${escapeHtml(file.name)}</div>
                <div class="file-meta">${sizeKB}KB · ${docsCount} doc${docsCount !== 1 ? 's' : ''}</div>
              </div>
              <div class="file-actions">
                <button class="file-action-btn" onclick="event.stopPropagation(); promptMoveFile('${file.id}', '${escapeHtml(file.name)}')" title="Moure">
                  <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>
                </button>
                <button class="file-action-btn" onclick="event.stopPropagation(); deleteKnowledgeFile('${file.id}')" title="Eliminar">
                  <span class="i i--sm"><svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></span>
                </button>
              </div>
            </div>
          `;
        });

        // Show empty message if no files in current folder
        if (currentFiles.length === 0 && currentFolder !== null) {
          html += `
            <div class="knowledge-empty">
              <span>Carpeta buida</span>
            </div>
          `;
        }

        listEl.innerHTML = html;
      }

      // v6.0: Folder management functions
      function promptRenameFolder(oldName) {
        const newName = prompt('Nou nom per la carpeta:', oldName);
        if (newName && newName.trim() && newName.trim() !== oldName) {
          google.script.run
            .withSuccessHandler(function() {
              currentFolder = newName.trim();
              invalidateKnowledgeCache();
              refreshKnowledgeLibrary(false);
            })
            .withFailureHandler(function(err) {
              alert('Error: ' + err.message);
            })
            .renameFolder(oldName, newName.trim());
        }
      }

      function promptDeleteFolder(folderName) {
        if (confirm('Eliminar la carpeta "' + folderName + '"? Els fitxers es mouran a l\'arrel.')) {
          google.script.run
            .withSuccessHandler(function() {
              currentFolder = null;
              invalidateKnowledgeCache();
              refreshKnowledgeLibrary(false);
            })
            .withFailureHandler(function(err) {
              alert('Error: ' + err.message);
            })
            .deleteFolder(folderName);
        }
      }

      // Move file modal state
      let moveFileId = null;
      let moveFileName = null;

      function promptMoveFile(fileId, fileName) {
        moveFileId = fileId;
        moveFileName = fileName;

        // Find current folder of the file
        const file = knowledgeLibrary.find(f => f.id === fileId);
        const fileFolder = file ? file.folder : null;

        // Set file name in modal
        document.getElementById('moveFileName').textContent = fileName;
        document.getElementById('moveNewFolderName').value = '';

        // Render folder options
        let html = '';

        // Root option (only if file is in a folder)
        if (fileFolder !== null) {
          html += `
            <button class="move-folder-option" onclick="executeMoveFile(null)">
              <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg></span>
              <span>General (sense carpeta)</span>
            </button>
          `;
        }

        // Existing folders (exclude current folder)
        knowledgeFolders.forEach(folder => {
          if (folder !== fileFolder) {
            html += `
              <button class="move-folder-option" onclick="executeMoveFile('${escapeHtml(folder)}')">
                <span class="i i--sm"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>
                <span>${escapeHtml(folder)}</span>
              </button>
            `;
          }
        });

        if (!html) {
          html = '<div class="move-folder-empty">No hi ha altres carpetes disponibles</div>';
        }

        document.getElementById('moveFolderList').innerHTML = html;

        // Show modal
        const modal = document.getElementById('moveFileModal');
        modal.classList.remove('hidden');
        setTimeout(() => modal.classList.add('visible'), 10);
      }

      function hideMoveFileModal() {
        const modal = document.getElementById('moveFileModal');
        modal.classList.remove('visible');
        setTimeout(() => modal.classList.add('hidden'), 200);
        moveFileId = null;
        moveFileName = null;
      }

      function executeMoveFile(targetFolder) {
        if (!moveFileId) return;

        google.script.run
          .withSuccessHandler(function() {
            hideMoveFileModal();
            invalidateKnowledgeCache();
            refreshKnowledgeLibrary(false);
            showToast('Fitxer mogut correctament', 'success');
          })
          .withFailureHandler(function(err) {
            alert('Error: ' + err.message);
          })
          .moveFileToFolder(moveFileId, targetFolder);
      }

      function moveToNewFolder() {
        const newFolderName = document.getElementById('moveNewFolderName').value.trim();
        if (!newFolderName) {
          showToast('Escriu un nom per la carpeta', 'warning');
          return;
        }
        executeMoveFile(newFolderName);
      }

      // v6.0: Toggle file activation (add/remove from active list)
      function toggleKnowledgeFile(fileId) {
        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.status === 'ok') {
              activeKnowledgeFiles = result.activeFiles || [];
              showActiveFiles(activeKnowledgeFiles);
              updateChatAttachmentBadge();
              renderKnowledgeLibrary();
            }
          })
          .withFailureHandler(function(err) {
            alert('Error: ' + err.message);
          })
          .toggleKnowledgeFile(fileId);
      }

      function removeActiveFile(fileId) {
        google.script.run
          .withSuccessHandler(function(result) {
            activeKnowledgeFiles = result.activeFiles || [];
            showActiveFiles(activeKnowledgeFiles);
            updateChatAttachmentBadge();
            renderKnowledgeLibrary();
          })
          .unlinkKnowledgeFile(fileId);
      }

      function removeAllActiveFiles() {
        google.script.run
          .withSuccessHandler(function(result) {
            activeKnowledgeFiles = [];
            hideActiveFiles();
            hideChatAttachment();
            renderKnowledgeLibrary();
          })
          .unlinkKnowledgeFile();
      }

      function deleteKnowledgeFile(fileId) {
        if (!confirm('Eliminar aquest fitxer de la biblioteca?')) return;

        google.script.run
          .withSuccessHandler(function() {
            // Remove from active files if present
            activeKnowledgeFiles = activeKnowledgeFiles.filter(f => f.id !== fileId);
            showActiveFiles(activeKnowledgeFiles);
            updateChatAttachmentBadge();
            invalidateKnowledgeCache();
            refreshKnowledgeLibrary(false);
          })
          .withFailureHandler(function(err) {
            alert('Error: ' + err.message);
          })
          .deleteFromKnowledgeLibrary(fileId);
      }

      // v6.0: Show multiple active files
      function showActiveFiles(files) {
        const displayEl = document.getElementById('activeFileDisplay');
        const statusEl = document.getElementById('activeFileStatus');

        if (!files || files.length === 0) {
          hideActiveFiles();
          return;
        }

        let html = '';
        files.forEach(function(file) {
          html += `
            <div class="active-file-chip">
              <span class="chip-name">${escapeHtml(file.name)}</span>
              <button class="chip-remove" onclick="removeActiveFile('${file.id}')" title="Treure">×</button>
            </div>
          `;
        });

        displayEl.innerHTML = html;
        displayEl.classList.remove('hidden');
        statusEl.textContent = files.length === 1 ? 'Fitxer actiu' : files.length + ' fitxers actius';
      }

      function hideActiveFiles() {
        const displayEl = document.getElementById('activeFileDisplay');
        const statusEl = document.getElementById('activeFileStatus');

        displayEl.innerHTML = '';
        displayEl.classList.add('hidden');
        statusEl.textContent = 'Cap fitxer seleccionat';
      }

      // v8.0: This function is now deprecated - knowledge files no longer show in chat
      // Chat attachments are temporary and handled separately
      function updateChatAttachmentBadge() {
        // No-op: knowledge files don't affect chat input anymore
      }

      function handleFileSelect() {
        const fileInput = document.getElementById('fileInput');
        if (fileInput.files.length === 0) return;

        const file = fileInput.files[0];
        if (file.size > 10 * 1024 * 1024) {
          alert('Màxim 10MB');
          fileInput.value = '';
          return;
        }

        // Show upload progress
        showUploadProgress(file.name, 'llegint');

        const reader = new FileReader();
        reader.onload = function(e) {
          showUploadProgress(file.name, 'pujant');

          const base64 = e.target.result.split(',')[1];
          google.script.run
            .withSuccessHandler(function(res) {
              if (res && res.status === 'ok' && res.file) {
                showUploadProgress(file.name, 'completat');
                // v6.0: Add to active files array
                if (!activeKnowledgeFiles.find(f => f.id === res.file.id)) {
                  activeKnowledgeFiles.push({ id: res.file.id, name: res.file.name });
                }
                showActiveFiles(activeKnowledgeFiles);
                updateChatAttachmentBadge();
                invalidateKnowledgeCache();
                refreshKnowledgeLibrary(false);

                // Hide progress after success animation
                setTimeout(hideUploadProgress, 1500);
              } else {
                hideUploadProgress();
                alert('Error pujant el fitxer');
              }
            })
            .withFailureHandler(function(err) {
              hideUploadProgress();
              alert('Error: ' + err.message);
            })
            .uploadToKnowledgeLibrary(base64, file.type, file.name);
        };
        reader.readAsDataURL(file);
        fileInput.value = '';
      }

      function showUploadProgress(fileName, stage) {
        const uploadBtn = document.getElementById('uploadBtn');
        const progress = document.getElementById('uploadProgress');
        const statusEl = progress.querySelector('.upload-status');
        const fillEl = progress.querySelector('.upload-progress-fill');

        uploadBtn.classList.add('hidden');
        progress.classList.remove('hidden');

        const stages = {
          'llegint': { text: 'Llegint ' + fileName + '...', percent: 30 },
          'pujant': { text: 'Pujant a la biblioteca...', percent: 70 },
          'completat': { text: '✓ Fitxer afegit!', percent: 100 }
        };

        const stageData = stages[stage] || stages['llegint'];
        statusEl.textContent = stageData.text;
        fillEl.style.width = stageData.percent + '%';

        if (stage === 'completat') {
          progress.classList.add('success');
        }
      }

      function hideUploadProgress() {
        const uploadBtn = document.getElementById('uploadBtn');
        const progress = document.getElementById('uploadProgress');
        const fillEl = progress.querySelector('.upload-progress-fill');

        progress.classList.add('hidden');
        progress.classList.remove('success');
        uploadBtn.classList.remove('hidden');
        fillEl.style.width = '0%';
      }

      function showFileStatus(name, uploading) {
        // Legacy function - redirects to new progress system
        if (!name) {
          hideUploadProgress();
        } else if (uploading) {
          showUploadProgress(name, 'pujant');
        }
      }

      // ═══════════════════════════════════════════════════════════
      // CHAT FILE ATTACHMENT (v8.0 - Temporary files in memory)
      // ═══════════════════════════════════════════════════════════

      function triggerChatAttachment() {
        document.getElementById('chatFileInput').click();
      }

      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      }

      function handleChatFileSelect() {
        const fileInput = document.getElementById('chatFileInput');
        if (fileInput.files.length === 0) return;

        const file = fileInput.files[0];

        // v8.0: Límit 2MB per fitxers de xat (temporals)
        if (file.size > 2 * 1024 * 1024) {
          showToast('Màxim 2MB per fitxers de xat', 'warning');
          fileInput.value = '';
          return;
        }

        // Show loading state in preview
        showChatAttachmentPreview(file.name, file.size, true);

        const reader = new FileReader();
        reader.onload = function(e) {
          const base64 = e.target.result.split(',')[1];

          // v8.0: Store in memory (NOT Supabase)
          const attachment = {
            id: 'chat_' + Date.now(),
            name: file.name,
            size: file.size,
            type: file.type,
            content: base64
          };

          // For text files, decode content directly
          if (file.type === 'text/plain' || file.type === 'text/markdown' ||
              file.type === 'text/csv' || file.name.endsWith('.md') ||
              file.name.endsWith('.txt') || file.name.endsWith('.csv')) {
            try {
              attachment.text = atob(base64);
            } catch (err) {
              attachment.text = null;
            }
          }

          // Store as pending attachment (will be added to sessionFiles on send)
          pendingAttachment = attachment;

          // Show preview (loaded)
          showChatAttachmentPreview(file.name, file.size, false);
        };

        reader.onerror = function() {
          showToast('Error llegint el fitxer', 'error');
          hideChatAttachmentPreview();
        };

        reader.readAsDataURL(file);
        fileInput.value = '';
      }

      function showChatAttachmentPreview(name, size, loading) {
        const preview = document.getElementById('chatAttachmentPreview');
        const nameEl = document.getElementById('chatAttachmentName');
        const sizeEl = document.getElementById('chatAttachmentSize');

        nameEl.textContent = loading ? 'Carregant...' : name;
        sizeEl.textContent = loading ? '' : formatFileSize(size);
        preview.classList.remove('hidden');
        preview.classList.toggle('loading', loading);
      }

      function hideChatAttachmentPreview() {
        const preview = document.getElementById('chatAttachmentPreview');
        preview.classList.add('hidden');
        // Note: pendingAttachment is cleared in removeChatAttachment() or moved to sessionFiles in sendMessage()
      }

      function removeChatAttachment() {
        pendingAttachment = null;
        hideChatAttachmentPreview();
      }

      // v8.0: Update session files bar
      function updateSessionFilesBar() {
        const bar = document.getElementById('sessionFilesBar');
        const list = document.getElementById('sessionFilesList');

        if (sessionFiles.length === 0) {
          bar.classList.add('hidden');
          list.innerHTML = '';
          return;
        }

        // Build chips for each file
        let html = '';
        sessionFiles.forEach(function(file, index) {
          html += '<div class="session-file-chip" title="' + file.name + '">' +
            '<span class="session-file-name">' + truncateFileName(file.name, 15) + '</span>' +
            '<button class="session-file-remove" onclick="removeSessionFile(' + index + ')" title="Treure">×</button>' +
          '</div>';
        });

        list.innerHTML = html;
        bar.classList.remove('hidden');
      }

      // v8.0: Truncate filename for display
      function truncateFileName(name, maxLen) {
        if (name.length <= maxLen) return name;
        const ext = name.lastIndexOf('.') > 0 ? name.substring(name.lastIndexOf('.')) : '';
        const base = name.substring(0, name.length - ext.length);
        const maxBase = maxLen - ext.length - 2;
        if (maxBase < 3) return name.substring(0, maxLen - 2) + '..';
        return base.substring(0, maxBase) + '..' + ext;
      }

      // v8.0: Remove a single session file
      function removeSessionFile(index) {
        if (index >= 0 && index < sessionFiles.length) {
          sessionFiles.splice(index, 1);
          updateSessionFilesBar();
        }
      }

      // v8.0: Clear all session files
      function clearSessionFiles() {
        sessionFiles = [];
        updateSessionFilesBar();
      }

      // v8.0: Create file bubble HTML for chat
      function createFileBubbleHtml(attachment) {
        return '<div class="chat-file-bubble">' +
          '<div class="file-bubble-icon">' +
            '<svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>' +
          '</div>' +
          '<div class="file-bubble-info">' +
            '<span class="file-bubble-name">' + attachment.name + '</span>' +
            '<span class="file-bubble-size">' + formatFileSize(attachment.size) + '</span>' +
          '</div>' +
        '</div>';
      }

      // ═══════════════════════════════════════════════════════════
      // BANNED WORDS (v2.8)
      // ═══════════════════════════════════════════════════════════

      function loadBannedWords() {
        google.script.run
          .withSuccessHandler(function(words) {
            bannedWords = words || [];
            renderBannedWordsList();
            renderConstraintChips(); // v4.0: També renderitza chips
          })
          .withFailureHandler(function(err) {
            console.error('Error loading banned words:', err);
            bannedWords = [];
          })
          .getBannedWords();
      }

      function renderBannedWordsList() {
        const container = document.getElementById('bannedWordsList');
        const countEl = document.getElementById('bannedWordsCount');
        if (!container) return;

        // Update count badge
        if (countEl) {
          countEl.textContent = bannedWords.length > 0 ? bannedWords.length : '';
        }

        if (bannedWords.length === 0) {
          container.innerHTML = '<div class="banned-words-empty">Cap paraula prohibida</div>';
          return;
        }

        container.innerHTML = bannedWords.map(function(word, index) {
          return '<span class="banned-word-tag">' +
            '<span>' + escapeHtml(word) + '</span>' +
            '<button class="remove-btn" onclick="removeBannedWord(' + index + ')"><span class="i i--sm"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button>' +
            '</span>';
        }).join('');
      }

      function toggleBannedWordsPanel() {
        const btn = document.getElementById('bannedWordsToggle');
        const panel = document.getElementById('bannedWordsPanel');
        const isOpen = panel.classList.contains('open');

        if (isOpen) {
          panel.classList.remove('open');
          btn.classList.remove('open');
        } else {
          panel.classList.add('open');
          btn.classList.add('open');
        }
      }

      // ═══════════════════════════════════════════════════════════
      // v4.0 SPRINT 1: CONSTRAINT CHIPS (Visible sobre input)
      // ═══════════════════════════════════════════════════════════

      function renderConstraintChips() {
        const container = document.getElementById('constraintsChips');
        const area = document.getElementById('constraintsArea');
        const btn = document.getElementById('banBtn');
        if (!container) return;

        if (bannedWords.length === 0) {
          container.innerHTML = '';
          // Hide area if no words
          if (area) area.classList.add('hidden');
          if (btn) btn.classList.remove('active');
          return;
        }

        // Show area if there are words
        if (area) area.classList.remove('hidden');
        if (btn) btn.classList.add('active');

        container.innerHTML = bannedWords.map(function(word, index) {
          return '<span class="constraint-chip">' +
            '<span class="chip-icon">' + icon('ban', 'i--error i--sm') + '</span>' +
            '<span class="chip-text">' + escapeHtml(word) + '</span>' +
            '<button class="chip-remove" onclick="removeConstraintChip(' + index + ')" title="Eliminar restricció">' + icon('x', 'i--sm') + '</button>' +
            '</span>';
        }).join('');
      }

      function removeConstraintChip(index) {
        const removed = bannedWords.splice(index, 1)[0];

        google.script.run
          .withSuccessHandler(function() {
            renderBannedWordsList();
            renderConstraintChips();
            showToast('"' + removed + '" ja es pot usar', 'success');
          })
          .withFailureHandler(function(err) {
            bannedWords.splice(index, 0, removed); // Rollback
            console.error('Error removing constraint:', err);
          })
          .saveBannedWords(bannedWords);
      }

      // v4.0.1: Toggle avoid words area
      function toggleAvoidWords() {
        const area = document.getElementById('constraintsArea');
        const btn = document.getElementById('banBtn');
        const input = document.getElementById('constraintInput');

        if (area && btn) {
          const isHidden = area.classList.toggle('hidden');
          btn.classList.toggle('active', !isHidden);

          if (!isHidden && input) {
            input.value = '';
            input.focus();
          }
        }
      }

      function showConstraintInput() {
        const area = document.getElementById('constraintsArea');
        const btn = document.getElementById('banBtn');
        const input = document.getElementById('constraintInput');

        if (area) {
          area.classList.remove('hidden');
          if (btn) btn.classList.add('active');
          if (input) {
            input.value = '';
            input.focus();
          }
        }
      }

      function hideConstraintInput() {
        // Keep area visible if there are chips
        const chips = document.querySelectorAll('.constraint-chip');
        if (chips.length === 0) {
          const area = document.getElementById('constraintsArea');
          const btn = document.getElementById('banBtn');
          if (area) area.classList.add('hidden');
          if (btn) btn.classList.remove('active');
        }
      }

      function handleConstraintInputKey(event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          addConstraintFromInput();
        } else if (event.key === 'Escape') {
          hideConstraintInput();
        }
      }

      function addConstraintFromInput() {
        const input = document.getElementById('constraintInput');
        if (!input) return;

        const word = input.value.trim().toLowerCase();

        if (!word) {
          hideConstraintInput();
          return;
        }

        if (word.length < 2) {
          showToast('Mínim 2 caràcters', 'warning');
          return;
        }

        if (bannedWords.includes(word)) {
          showToast('"' + word + '" ja està prohibida', 'warning');
          hideConstraintInput();
          return;
        }

        bannedWords.push(word);
        hideConstraintInput();

        google.script.run
          .withSuccessHandler(function() {
            renderBannedWordsList();
            renderConstraintChips();
            showToast('"' + word + '" afegit', 'ban');
          })
          .withFailureHandler(function(err) {
            bannedWords.pop(); // Rollback
            showToast('Error afegint paraula', 'error');
          })
          .saveBannedWords(bannedWords);
      }

      // ═══════════════════════════════════════════════════════════
      // v4.0 SPRINT 2: TOOLTIP SELECCIÓ (Ban from chat)
      // ═══════════════════════════════════════════════════════════

      let selectedWordToBan = '';

      function initBanTooltip() {
        const chatHistory = document.getElementById('chatHistory');
        if (!chatHistory) return;

        // v14.8: Detectar selecció de text al xat amb registre per cleanup
        registerListener(chatHistory, 'mouseup', handleTextSelection);
        registerListener(document, 'mousedown', hideBanTooltip);
      }

      function handleTextSelection(e) {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();

        // Només mostrar si és una paraula vàlida (1-30 chars, sense espais)
        if (selectedText && selectedText.length >= 2 && selectedText.length <= 30 && !/\s/.test(selectedText)) {
          // Verificar que la selecció és dins d'un missatge de la IA
          const anchorNode = selection.anchorNode;
          if (anchorNode) {
            const msgElement = anchorNode.parentElement.closest('.msg.ai, .msg.assistant');
            if (msgElement) {
              showBanTooltip(selectedText, e.clientX, e.clientY);
              return;
            }
          }
        }
        hideBanTooltip();
      }

      function showBanTooltip(word, x, y) {
        const tooltip = document.getElementById('banTooltip');
        const wordDisplay = document.getElementById('banTooltipWord');

        if (!tooltip || !wordDisplay) return;

        // Ja està prohibida?
        if (bannedWords.includes(word.toLowerCase())) {
          return; // No mostrar tooltip per paraules ja prohibides
        }

        selectedWordToBan = word;
        wordDisplay.textContent = '"' + word + '"';

        // Posicionar tooltip (amb offset per no tapar selecció)
        const offsetX = 10;
        const offsetY = -40;
        tooltip.style.left = Math.min(x + offsetX, window.innerWidth - 180) + 'px';
        tooltip.style.top = Math.max(y + offsetY, 10) + 'px';
        tooltip.classList.add('visible');
      }

      function hideBanTooltip() {
        const tooltip = document.getElementById('banTooltip');
        if (tooltip) {
          tooltip.classList.remove('visible');
        }
        selectedWordToBan = '';
      }

      function banSelectedWord() {
        if (!selectedWordToBan) return;

        const word = selectedWordToBan;
        hideBanTooltip();

        // Afegir a banned words
        if (bannedWords.includes(word.toLowerCase())) {
          showToast('"' + word + '" ja està prohibida', 'warning');
          return;
        }

        bannedWords.push(word.toLowerCase());

        google.script.run
          .withSuccessHandler(function() {
            renderBannedWordsList();
            renderConstraintChips();
            showToast('"' + word + '" afegit - la IA ja no l\'usarà', 'ban');
          })
          .withFailureHandler(function(err) {
            bannedWords.pop(); // Rollback
            showToast('Error afegint paraula', 'error');
          })
          .saveBannedWords(bannedWords);
      }

      // ═══════════════════════════════════════════════════════════
      // v4.0 SPRINT 3: NL AUTO-BAN (Processar paraules detectades)
      // ═══════════════════════════════════════════════════════════

      function processAutoBan(words) {
        if (!words || words.length === 0) return;

        const newWords = [];
        for (const word of words) {
          const lowerWord = word.toLowerCase();
          if (!bannedWords.includes(lowerWord)) {
            bannedWords.push(lowerWord);
            newWords.push(word);
          }
        }

        if (newWords.length === 0) return;

        // Save to backend
        google.script.run
          .withSuccessHandler(function() {
            renderBannedWordsList();
            renderConstraintChips();
            // Show feedback
            if (newWords.length === 1) {
              showToast('"' + newWords[0] + '" afegit automàticament', 'ban');
            } else {
              showToast(newWords.length + ' paraules afegides automàticament', 'ban');
            }
          })
          .withFailureHandler(function(err) {
            // Rollback
            for (const word of newWords) {
              const idx = bannedWords.indexOf(word.toLowerCase());
              if (idx > -1) bannedWords.splice(idx, 1);
            }
            console.error('Error saving auto-banned words:', err);
          })
          .saveBannedWords(bannedWords);
      }

      // v3.3: escapeHtml definida més avall a la secció Preview Mode

      function addBannedWord() {
        const input = document.getElementById('newBannedWord');
        const word = input.value.trim();

        if (!word) return;
        if (bannedWords.includes(word.toLowerCase())) {
          alert('Aquesta paraula ja esta a la llista.');
          return;
        }

        bannedWords.push(word.toLowerCase());
        input.value = '';

        // v4.1: Optimistic UI - render immediately, save in background
        renderBannedWordsList();

        google.script.run
          .withSuccessHandler(function() {
            showToast('"' + word + '" afegit', 'ban');
          })
          .withFailureHandler(function(err) {
            bannedWords.pop(); // Rollback
            renderBannedWordsList();
            showToast('Error: ' + err.message, 'error');
          })
          .saveBannedWords(bannedWords);
      }

      function removeBannedWord(index) {
        const removed = bannedWords.splice(index, 1)[0];

        // v4.1: Optimistic UI - render immediately, save in background
        renderBannedWordsList();

        google.script.run
          .withSuccessHandler(function() {
            showToast('"' + removed + '" eliminat', 'success');
          })
          .withFailureHandler(function(err) {
            bannedWords.splice(index, 0, removed); // Rollback
            renderBannedWordsList();
            showToast('Error: ' + err.message, 'error');
          })
          .saveBannedWords(bannedWords);
      }

      function addToBannedFromChat(word) {
        if (!word || bannedWords.includes(word.toLowerCase())) return;

        bannedWords.push(word.toLowerCase());

        // v4.1: Optimistic UI - render immediately, save in background
        renderBannedWordsList();
        renderConstraintChips();

        google.script.run
          .withSuccessHandler(function() {
            showToast('"' + word + '" afegit', 'ban');
          })
          .withFailureHandler(function(err) {
            bannedWords.pop(); // Rollback
            renderBannedWordsList();
            renderConstraintChips();
            console.error('Error adding banned word:', err);
          })
          .saveBannedWords(bannedWords);
      }

      // ═══════════════════════════════════════════════════════════
      // PREVIEW MODE (v3.2) - Visual Diff Engine
      // ═══════════════════════════════════════════════════════════

      /**
       * Computes HTML diff between two texts using word-level comparison
       * Returns HTML with <del> and <ins> tags
       * v14.4: Trunca context si el canvi és petit (poques paraules)
       */
      function computeDiffHtml(original, proposed) {
        if (!original && !proposed) return '';
        if (!original) return '<ins class="diff-ins">' + escapeHtml(proposed) + '</ins>';
        if (!proposed) return '<del class="diff-del">' + escapeHtml(original) + '</del>';

        // Tokenize by words (keeping punctuation attached)
        const originalWords = original.split(/(\s+)/);
        const proposedWords = proposed.split(/(\s+)/);

        // Simple LCS-based diff
        const diff = computeWordDiff(originalWords, proposedWords);

        // v14.4: Truncar si el canvi és petit i el text és llarg
        const truncatedDiff = truncateDiffContext(diff);

        return renderDiff(truncatedDiff);
      }

      /**
       * v14.4: Trunca el context del diff si el canvi és petit
       * Mostra només N paraules abans i després dels canvis
       *
       * @param {Array} diff - Array de {type: 'eq'|'del'|'ins', text: string}
       * @returns {Array} - Diff truncat amb ellipsis si cal
       */
      function truncateDiffContext(diff) {
        const CONTEXT_WORDS = 5;  // Paraules a mostrar abans/després
        const MIN_TOTAL_FOR_TRUNCATE = 20;  // Mínim de tokens per considerar truncar
        const MAX_CHANGED_WORDS = 10;  // Màxim de paraules canviades per truncar

        // Comptar tokens i canvis
        const totalTokens = diff.length;
        let changedCount = 0;
        let firstChangeIdx = -1;
        let lastChangeIdx = -1;

        for (let i = 0; i < diff.length; i++) {
          if (diff[i].type !== 'eq') {
            changedCount++;
            if (firstChangeIdx === -1) firstChangeIdx = i;
            lastChangeIdx = i;
          }
        }

        // No truncar si:
        // - No hi ha canvis
        // - El text és curt
        // - Hi ha molts canvis (no és un canvi petit)
        if (firstChangeIdx === -1 ||
            totalTokens < MIN_TOTAL_FOR_TRUNCATE ||
            changedCount > MAX_CHANGED_WORDS) {
          return diff;
        }

        // Calcular rang a mantenir (amb context)
        // Comptem només tokens no-espai per context
        let contextBefore = 0;
        let startIdx = firstChangeIdx;
        for (let i = firstChangeIdx - 1; i >= 0 && contextBefore < CONTEXT_WORDS; i--) {
          startIdx = i;
          if (diff[i].text.trim()) contextBefore++;
        }

        let contextAfter = 0;
        let endIdx = lastChangeIdx;
        for (let i = lastChangeIdx + 1; i < diff.length && contextAfter < CONTEXT_WORDS; i++) {
          endIdx = i;
          if (diff[i].text.trim()) contextAfter++;
        }

        // Si no truncarem prou, no val la pena
        const wouldRemove = startIdx + (diff.length - endIdx - 1);
        if (wouldRemove < 8) {
          return diff;
        }

        // Construir diff truncat
        const truncated = [];

        // Afegir ellipsis al principi si truncem
        if (startIdx > 0) {
          truncated.push({ type: 'ellipsis', text: '… ' });
        }

        // Afegir tokens del rang
        for (let i = startIdx; i <= endIdx; i++) {
          truncated.push(diff[i]);
        }

        // Afegir ellipsis al final si truncem
        if (endIdx < diff.length - 1) {
          truncated.push({ type: 'ellipsis', text: ' …' });
        }

        return truncated;
      }

      /**
       * Compute word-level diff using simple comparison
       */
      function computeWordDiff(oldWords, newWords) {
        const result = [];
        let i = 0, j = 0;

        while (i < oldWords.length || j < newWords.length) {
          if (i >= oldWords.length) {
            // Rest of new words are insertions
            result.push({ type: 'ins', text: newWords[j] });
            j++;
          } else if (j >= newWords.length) {
            // Rest of old words are deletions
            result.push({ type: 'del', text: oldWords[i] });
            i++;
          } else if (oldWords[i] === newWords[j]) {
            // Match
            result.push({ type: 'eq', text: oldWords[i] });
            i++;
            j++;
          } else {
            // Look ahead for potential match
            const lookAheadOld = oldWords.slice(i, i + 5).indexOf(newWords[j]);
            const lookAheadNew = newWords.slice(j, j + 5).indexOf(oldWords[i]);

            if (lookAheadOld !== -1 && (lookAheadNew === -1 || lookAheadOld <= lookAheadNew)) {
              // Delete old words until match
              for (let k = 0; k < lookAheadOld; k++) {
                result.push({ type: 'del', text: oldWords[i + k] });
              }
              i += lookAheadOld;
            } else if (lookAheadNew !== -1) {
              // Insert new words until match
              for (let k = 0; k < lookAheadNew; k++) {
                result.push({ type: 'ins', text: newWords[j + k] });
              }
              j += lookAheadNew;
            } else {
              // No match found - treat as replace
              result.push({ type: 'del', text: oldWords[i] });
              result.push({ type: 'ins', text: newWords[j] });
              i++;
              j++;
            }
          }
        }

        return result;
      }

      /**
       * Render diff array to HTML
       * v14.4: Afegit suport per tipus 'ellipsis'
       * v14.7: Espai entre del i ins per millorar llegibilitat
       */
      function renderDiff(diff) {
        let html = '';
        let currentType = null;
        let buffer = '';
        let lastFlushedType = null;

        for (const item of diff) {
          // v14.4: Gestionar ellipsis separadament (no s'agrupa)
          if (item.type === 'ellipsis') {
            // Flush buffer primer
            if (buffer) {
              html += renderDiffBuffer(currentType, buffer);
              lastFlushedType = currentType;
              buffer = '';
              currentType = null;
            }
            html += '<span class="diff-ellipsis">' + escapeHtml(item.text) + '</span>';
            lastFlushedType = 'ellipsis';
            continue;
          }

          if (item.type !== currentType) {
            // Flush buffer
            if (buffer) {
              html += renderDiffBuffer(currentType, buffer);
              lastFlushedType = currentType;
              buffer = '';
            }
            // v14.7: Afegir espai entre del→ins per separar original de proposta
            if (lastFlushedType === 'del' && item.type === 'ins') {
              html += ' ';
            }
            currentType = item.type;
          }
          buffer += item.text;
        }

        // Flush remaining buffer
        if (buffer) {
          html += renderDiffBuffer(currentType, buffer);
        }

        return html;
      }

      /**
       * v14.4: Helper per renderitzar buffer de diff
       */
      function renderDiffBuffer(type, buffer) {
        if (type === 'del') {
          return '<del class="diff-del">' + escapeHtml(buffer) + '</del>';
        } else if (type === 'ins') {
          return '<ins class="diff-ins">' + escapeHtml(buffer) + '</ins>';
        } else {
          // Text inalterat - verd clar
          return '<span class="diff-context">' + escapeHtml(buffer) + '</span>';
        }
      }

      /**
       * Escape HTML special characters
       */
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      /**
       * Show preview panel with proposed changes
       */
      function showPreviewPanel(changes, aiResponse, docSnapshot) {
        pendingPreviewChanges = changes;
        pendingDocSnapshot = docSnapshot || null; // v3.3: Guardar snapshot

        // Remove existing preview panel
        hidePreviewPanel();

        // Build preview HTML
        let changesHtml = '';
        for (const change of changes) {
          const diffHtml = computeDiffHtml(change.originalText, change.proposedText);
          changesHtml += `
            <div class="preview-change">
              <div class="preview-location">Paràgraf ${parseInt(change.targetId) + 1}</div>
              <div class="preview-diff">${diffHtml}</div>
            </div>
          `;
        }

        const previewPanel = document.createElement('div');
        previewPanel.id = 'previewPanel';
        previewPanel.className = 'preview-panel';
        previewPanel.innerHTML = `
          <div class="preview-header">
            ${icon('eye', 'i--accent')}
            <span>Previsualització de Canvis</span>
          </div>
          <div class="preview-content">
            ${changesHtml}
          </div>
          <div class="preview-actions">
            <button class="btn btn-cancel" onclick="cancelPreview()">
              ${icon('x', 'i--error i--sm')} Cancel·lar
            </button>
            <button class="btn btn-apply" onclick="applyPreviewedChanges()">
              ${icon('check', 'i--success i--sm')} Aplicar
            </button>
          </div>
        `;

        // Add to chat history
        const container = document.getElementById('chatHistory');
        container.appendChild(previewPanel);
        container.scrollTop = container.scrollHeight;

        // Add AI response bubble
        if (aiResponse) {
          addBubble('ai', aiResponse);
        }
      }

      /**
       * Hide preview panel
       */
      function hidePreviewPanel() {
        const existing = document.getElementById('previewPanel');
        if (existing) existing.remove();
      }

      /**
       * Apply the previewed changes
       */
      function applyPreviewedChanges() {
        if (!pendingPreviewChanges || pendingPreviewChanges.length === 0) {
          showToast('No hi ha canvis pendents', 'error');
          return;
        }

        const panel = document.getElementById('previewPanel');
        if (panel) panel.classList.add('applying');

        // v3.3: Timeout de seguretat (15 segons)
        const timeoutId = setTimeout(function() {
          const p = document.getElementById('previewPanel');
          if (p) p.classList.remove('applying');
          addBubble('error', icon('clock', 'i--warning') + ' Timeout: L\'operació ha trigat massa. Torna-ho a provar.');
        }, 15000);

        google.script.run
          .withSuccessHandler(function(res) {
            clearTimeout(timeoutId);
            hidePreviewPanel();
            pendingPreviewChanges = null;
            pendingDocSnapshot = null; // v3.3: Clear snapshot

            if (res.ok) {
              addBubble('system', icon('checkCircle', 'i--success') + ' He aplicat ' + res.applied + ' canvi' + (res.applied !== 1 ? 's' : '') + '.');

              // Show undo bar for reverting
              if (res.undoSnapshots && res.undoSnapshots.length > 0) {
                pendingUndo = res.undoSnapshots[0];
                showUndoBar();
              }
            } else {
              addBubble('error', 'Error: ' + (res.error || 'Error desconegut'));
            }
          })
          .withFailureHandler(function(err) {
            clearTimeout(timeoutId);
            const panel = document.getElementById('previewPanel');
            if (panel) panel.classList.remove('applying');
            addBubble('error', 'Error: ' + err.message);
          })
          .applyPendingChanges(pendingPreviewChanges, pendingDocSnapshot);
      }

      /**
       * Cancel preview and discard changes
       */
      function cancelPreview() {
        pendingPreviewChanges = null;
        pendingDocSnapshot = null; // v3.3: Clear snapshot
        hidePreviewPanel();
        addBubble('system', icon('undo', 'i--default') + ' Cancel·lat');
      }

      function clearKnowledgeFileAndRetry() {
        google.script.run
          .withSuccessHandler(function() {
            showToast('Fitxer esborrat. Torna a enviar el missatge.', 'success');
            updateKnowledgeFileDisplay();
          })
          .withFailureHandler(function(err) {
            showToast('Error: ' + err.message, 'error');
          })
          .clearKnowledgeFile();
      }

      function showToast(message, type) {
        // Create a simple toast notification with icon support
        const toast = document.createElement('div');
        toast.style.cssText = 'position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); ' +
          'background: var(--bg-tertiary); color: var(--text-primary); padding: 8px 16px; ' +
          'border-radius: var(--radius-md); font-size: 12px; box-shadow: var(--shadow-md); ' +
          'z-index: 1000; animation: msgAppear 0.3s ease; display: flex; align-items: center; gap: 6px;';

        // Add icon based on type
        let iconHtml = '';
        if (type === 'success') iconHtml = icon('checkCircle', 'i--success');
        else if (type === 'error') iconHtml = icon('xCircle', 'i--error');
        else if (type === 'warning') iconHtml = icon('alertTriangle', 'i--warning');
        else if (type === 'ban') iconHtml = icon('ban', 'i--error');
        else if (type === 'info') iconHtml = icon('info', 'i--accent');
        else if (type === 'undo') iconHtml = icon('undo', 'i--default');

        toast.innerHTML = iconHtml + '<span>' + message + '</span>';
        document.body.appendChild(toast);

        setTimeout(function() {
          toast.style.opacity = '0';
          toast.style.transition = 'opacity 0.3s';
          setTimeout(function() { toast.remove(); }, 300);
        }, 2000);
      }

      // ═══════════════════════════════════════════════════════════
      // DOCUMENT SKELETON (v2.9) + CONTEXT HINTS (v2.5)
      // ═══════════════════════════════════════════════════════════

      let currentSkeleton = null;
      const HINT_SHOWN_KEY = 'docmile-structure-hint-shown';

      /**
       * Check and show one-time structure hint in chat (v2.5)
       */
      function checkAndShowStructureHint() {
        // Only show once per session
        if (sessionStorage.getItem(HINT_SHOWN_KEY)) return;

        google.script.run
          .withSuccessHandler(function(summary) {
            if (summary && summary.has_suggestions && summary.visual_headings > 0) {
              // Mark as shown
              sessionStorage.setItem(HINT_SHOWN_KEY, 'true');
              // Show hint in chat
              addBubble('system', icon('lightbulb', 'i--warning') + ' He detectat ' + summary.visual_headings +
                ' títols sense format. Pots arreglar-ho a Estructura > Auto-Structure.');
            }
          })
          .getContextSummary();
      }

      // ═══════════════════════════════════════════════════════════
      // TABLES PANEL (v6.0 - Table Management)
      // ═══════════════════════════════════════════════════════════

      let currentTables = [];
      let tablesLastScanTime = null;

      /**
       * Scans the document for tables and updates the panel
       */
      function scanDocumentTables() {
        const tablesList = document.getElementById('tablesList');
        const statTables = document.getElementById('statTables');
        const statTableRows = document.getElementById('statTableRows');
        const statTableCols = document.getElementById('statTableCols');
        const tablesMeta = document.getElementById('tablesMeta');

        // Show loading state
        tablesList.innerHTML = '<div class="tables-empty"><span class="tables-empty-icon">' + icon('loader', 'i--muted') + '</span><span>Escanejant taules...</span></div>';

        google.script.run
          .withSuccessHandler(function(result) {
            tablesLastScanTime = new Date();

            if (result && result.tables && result.tables.length > 0) {
              currentTables = result.tables;

              // Calculate stats
              let totalRows = 0;
              let maxCols = 0;
              result.tables.forEach(function(t) {
                totalRows += t.rows || 0;
                if ((t.cols || 0) > maxCols) maxCols = t.cols;
              });

              statTables.textContent = result.tables.length;
              statTableRows.textContent = totalRows;
              statTableCols.textContent = maxCols;
              tablesMeta.innerHTML = '<span class="meta-item">Escanejat: ' + tablesLastScanTime.toLocaleTimeString('ca-ES', { hour: '2-digit', minute: '2-digit' }) + '</span>';

              // Render table list
              renderTablesList(result.tables);
            } else {
              currentTables = [];
              statTables.textContent = '0';
              statTableRows.textContent = '0';
              statTableCols.textContent = '0';
              tablesMeta.innerHTML = '<span class="meta-item">Escanejat: ' + new Date().toLocaleTimeString('ca-ES', { hour: '2-digit', minute: '2-digit' }) + '</span>';
              tablesList.innerHTML = '<div class="tables-empty"><span class="tables-empty-icon i i--xl i--muted"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/></svg></span><span>Cap taula detectada</span><span class="tables-empty-hint">Utilitza "Nova Taula" o "Generar Taula" per crear-ne una</span></div>';
            }
          })
          .withFailureHandler(function(err) {
            tablesList.innerHTML = '<div class="tables-empty"><span class="tables-empty-icon">' + icon('xCircle', 'i--error') + '</span><span>Error: ' + err.message + '</span></div>';
          })
          .scanTablesInDocument();
      }

      /**
       * Renders the list of tables in the panel
       */
      function renderTablesList(tables) {
        const tablesList = document.getElementById('tablesList');

        if (!tables || tables.length === 0) {
          tablesList.innerHTML = '<div class="tables-empty"><span class="tables-empty-icon i i--xl i--muted"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/></svg></span><span>Cap taula detectada</span></div>';
          return;
        }

        let html = '';
        tables.forEach(function(table, index) {
          const preview = table.preview || (table.headers ? table.headers.join(' | ') : 'Taula sense capçalera');
          html += '<div class="table-card" onclick="goToTable(' + index + ')">';
          html += '  <div class="table-card-header">';
          html += '    <div class="table-card-title">' + icon('table', 'i--accent i--sm') + ' Taula ' + (index + 1) + '</div>';
          html += '    <div class="table-card-meta">' + (table.rows || 0) + ' files × ' + (table.cols || 0) + ' col</div>';
          html += '  </div>';
          html += '  <div class="table-card-preview">' + escapeHtml(preview.substring(0, 80)) + (preview.length > 80 ? '...' : '') + '</div>';
          html += '  <div class="table-card-actions">';
          html += '    <button class="table-card-btn" onclick="event.stopPropagation(); addRowToTable(' + index + ')">' + icon('plus', 'i--sm') + ' Fila</button>';
          html += '    <button class="table-card-btn" onclick="event.stopPropagation(); editTableWithAI(' + index + ')">' + icon('wand', 'i--sm') + ' Editar IA</button>';
          html += '  </div>';
          html += '</div>';
        });

        tablesList.innerHTML = html;
      }

      /**
       * Navigate to a specific table in the document
       */
      function goToTable(tableIndex) {
        if (!currentTables || !currentTables[tableIndex]) return;

        const table = currentTables[tableIndex];
        google.script.run
          .withSuccessHandler(function() {
            // Scroll success - maybe highlight briefly
          })
          .withFailureHandler(function(err) {
            addBubble('error', 'No s\'ha pogut navegar a la taula: ' + err.message);
          })
          .scrollToTableByIndex(tableIndex);
      }

      /**
       * Add a row to a specific table
       */
      function addRowToTable(tableIndex) {
        if (!currentTables || !currentTables[tableIndex]) return;

        const table = currentTables[tableIndex];
        const numCols = table.cols || 2;

        // Create empty row with same number of columns
        const emptyRow = new Array(numCols).fill('');

        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              addBubble('system', icon('check', 'i--success') + ' Fila afegida a la Taula ' + (tableIndex + 1));
              scanDocumentTables(); // Refresh
            } else {
              addBubble('error', 'Error afegint fila: ' + (result.error || 'Error desconegut'));
            }
          })
          .withFailureHandler(function(err) {
            addBubble('error', 'Error afegint fila: ' + err.message);
          })
          .addRowToTable(tableIndex, emptyRow);
      }

      /**
       * Opens AI editing for a specific table
       */
      function editTableWithAI(tableIndex) {
        if (!currentTables || !currentTables[tableIndex]) return;

        // Switch to chat tab with a prefilled command
        switchTab('chat');

        const input = document.getElementById('userInput');
        if (input) {
          input.value = 'Edita la taula ' + (tableIndex + 1) + ': ';
          input.focus();
          input.setSelectionRange(input.value.length, input.value.length);
        }
      }

      /**
       * Insert an empty table at cursor position
       */
      function insertEmptyTable() {
        const rows = 3;
        const cols = 3;

        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              addBubble('system', icon('check', 'i--success') + ' Taula buida inserida (' + rows + '×' + cols + ')');
              scanDocumentTables(); // Refresh
            } else {
              addBubble('error', 'Error inserint taula: ' + (result.error || 'Error desconegut'));
            }
          })
          .withFailureHandler(function(err) {
            addBubble('error', 'Error inserint taula: ' + err.message);
          })
          .insertEmptyTable(rows, cols);
      }

      /**
       * Generate a table using AI based on description
       */
      function generateTableWithAI() {
        const input = document.getElementById('tablesAiInput');
        const description = input.value.trim();

        if (!description) {
          addBubble('error', 'Escriu una descripció de la taula que vols crear');
          return;
        }

        const includeHeaders = document.getElementById('tablesAiHeaders').checked;
        const numRows = parseInt(document.getElementById('tablesAiRows').value) || 5;

        // Show loading
        const btn = document.querySelector('.tables-ai-btn');
        const originalText = btn.innerHTML;
        btn.innerHTML = icon('loader', 'i--default') + ' Generant...';
        btn.disabled = true;

        // Build the command for AI
        const command = 'Genera una taula amb ' + numRows + ' files' +
          (includeHeaders ? ' i capçaleres' : '') +
          ': ' + description;

        // Use the chat system to process
        google.script.run
          .withSuccessHandler(function(result) {
            btn.innerHTML = originalText;
            btn.disabled = false;

            if (result && result.success) {
              input.value = '';
              addBubble('system', icon('check', 'i--success') + ' Taula generada correctament');
              scanDocumentTables(); // Refresh
            } else {
              addBubble('error', 'Error generant taula: ' + (result.error || 'Error desconegut'));
            }
          })
          .withFailureHandler(function(err) {
            btn.innerHTML = originalText;
            btn.disabled = false;
            addBubble('error', 'Error generant taula: ' + err.message);
          })
          .generateTableFromDescription(description, numRows, includeHeaders);
      }

      // ═══════════════════════════════════════════════════════════
      // STRUCTURE PANEL (v3.9)
      // ═══════════════════════════════════════════════════════════

      let currentStructure = null;
      let lastScanTime = null;

      function refreshStructure() {
        const statsChars = document.getElementById('statChars');
        const statsParagraphs = document.getElementById('statParagraphs');
        const statsHeadings = document.getElementById('statHeadings');
        const metaEl = document.getElementById('structureMeta');
        const outlineTree = document.getElementById('outlineTree');
        const entitiesGrid = document.getElementById('entitiesGrid');

        // Show loading state
        outlineTree.innerHTML = '<div class="outline-empty"><span class="outline-empty-icon">' + icon('loader', 'i--muted') + '</span><span>Escanejant document...</span></div>';

        google.script.run
          .withSuccessHandler(function(skeleton) {
            currentStructure = skeleton;
            lastScanTime = new Date();

            if (skeleton && skeleton.stats) {
              // Update stats (backend usa total_chars i paragraph_count)
              statsChars.textContent = formatNumber(skeleton.stats.total_chars || skeleton.stats.chars || 0);
              statsParagraphs.textContent = skeleton.stats.paragraph_count || skeleton.stats.paragraphs || 0;

              const headings = skeleton.structure.filter(function(item) {
                return item.type !== 'SECTION' && item.type !== 'WARNING';
              }).length;
              statsHeadings.textContent = headings;

              // Update meta
              metaEl.innerHTML = '<span class="meta-item">Escanejat en ' + skeleton.stats.scan_time_ms + 'ms</span>';

              // Render outline tree
              renderOutlineTree(skeleton);

              // Render entities
              renderEntities(skeleton);

              // Check for suggestions
              checkStructureSuggestions(skeleton);
            } else if (skeleton && skeleton.error) {
              outlineTree.innerHTML = '<div class="outline-empty"><span class="outline-empty-icon">' + icon('alertTriangle', 'i--warning') + '</span><span>' + skeleton.error + '</span></div>';
            } else {
              statsChars.textContent = '0';
              statsParagraphs.textContent = '0';
              statsHeadings.textContent = '0';
              outlineTree.innerHTML = '<div class="outline-empty"><span class="outline-empty-icon">' + icon('file', 'i--muted') + '</span><span>Document buit</span></div>';
            }
          })
          .withFailureHandler(function(err) {
            outlineTree.innerHTML = '<div class="outline-empty"><span class="outline-empty-icon">' + icon('xCircle', 'i--error') + '</span><span>Error: ' + err.message + '</span></div>';
          })
          .getDocSkeleton();
      }

      function formatNumber(num) {
        if (num >= 1000) {
          return (num / 1000).toFixed(1) + 'k';
        }
        return num.toString();
      }

      function renderOutlineTree(skeleton) {
        const outlineTree = document.getElementById('outlineTree');

        if (!skeleton || !skeleton.structure || skeleton.structure.length === 0) {
          outlineTree.innerHTML = '<div class="outline-empty"><span class="outline-empty-icon">' + icon('file', 'i--muted') + '</span><span>Cap estructura detectada</span></div>';
          return;
        }

        let html = '';
        let currentDepth = 0;

        skeleton.structure.forEach(function(item, idx) {
          // Determine depth based on type
          let depth = 0;
          let typeClass = '';
          let typeLabel = '';

          if (item.type === 'TITLE') {
            depth = 0;
            typeClass = 'h1';
            typeLabel = 'Títol';
          } else if (item.type === 'SUBTITLE') {
            depth = 0;
            typeClass = 'h2';
            typeLabel = 'Subtítol';
          } else if (item.type === 'HEADING_1' || item.type === 'H1') {
            depth = 1;
            typeClass = 'h1';
            typeLabel = 'Títol 1';
          } else if (item.type === 'HEADING_2' || item.type === 'H2') {
            depth = 2;
            typeClass = 'h2';
            typeLabel = 'Títol 2';
          } else if (item.type === 'HEADING_3' || item.type === 'H3') {
            depth = 3;
            typeClass = 'h3';
            typeLabel = 'Títol 3';
          } else {
            // Paràgrafs normals (SECTION, BOLD, P, etc.)
            depth = Math.min(currentDepth + 1, 3);
            typeClass = 'p';
            typeLabel = 'Normal';
          }

          currentDepth = depth;

          // Backend retorna 'text' per headings i 'preview' per seccions
          const textContent = item.text || item.preview || '';
          const isLong = textContent.length > 50;
          const previewStart = textContent.substring(0, 35) + (isLong ? '...' : '');
          // Segona línia: mostrar les últimes paraules fins al punt final
          const previewEnd = isLong ? textContent.substring(textContent.length - 25).trim() : '';
          // Backend retorna 'index', no 'idx'
          const itemIndex = item.index !== undefined ? item.index : idx;

          html += '<div class="outline-item" data-depth="' + depth + '" data-idx="' + itemIndex + '">';
          html += '<span class="outline-type ' + typeClass + '" onclick="event.stopPropagation(); showStylePicker(' + itemIndex + ', this)" title="Canviar estil">' + typeLabel + '</span>';
          html += '<div class="outline-text-wrap" onclick="scrollToElement(' + itemIndex + ')">';
          html += '<span class="outline-text">' + escapeHtml(previewStart) + '</span>';
          if (previewEnd) {
            html += '<span class="outline-text-end">' + escapeHtml(previewEnd) + '</span>';
          }
          html += '</div>';
          html += '<span class="outline-id">¶' + itemIndex + '</span>';
          html += '</div>';
        });

        outlineTree.innerHTML = html;
      }

      function renderEntities(skeleton) {
        const entitiesGrid = document.getElementById('entitiesGrid');
        const entitiesSection = document.getElementById('entitiesSection');

        if (!skeleton || !skeleton.entities || Object.keys(skeleton.entities).length === 0) {
          entitiesSection.style.display = 'none';
          return;
        }

        entitiesSection.style.display = 'block';

        const entityIconNames = {
          dates: 'calendar',
          amounts: 'dollarSign',
          percentages: 'percent',
          numbers: 'hash',
          emails: 'mail',
          urls: 'link'
        };

        let html = '';

        for (const [type, items] of Object.entries(skeleton.entities)) {
          if (items && items.length > 0) {
            const iconName = entityIconNames[type] || 'tag';
            html += '<div class="entity-tag">';
            html += '<span class="entity-icon">' + icon(iconName, 'i--accent i--sm') + '</span>';
            html += '<span class="entity-count">' + items.length + '</span>';
            html += '<span>' + type + '</span>';
            html += '</div>';
          }
        }

        entitiesGrid.innerHTML = html || '<span style="color: var(--text-muted); font-size: 11px;">Cap entitat detectada</span>';
      }

      function checkStructureSuggestions(skeleton) {
        const suggestionEl = document.getElementById('structureSuggestion');
        const suggestionText = document.getElementById('suggestionText');

        if (!skeleton || !skeleton.structure) {
          suggestionEl.classList.add('hidden');
          return;
        }

        // Count native vs visual headings
        let nativeHeadings = 0;
        let visualHeadings = 0;

        skeleton.structure.forEach(function(item) {
          if (item.type === 'HEADING_1' || item.type === 'HEADING_2' || item.type === 'HEADING_3') {
            nativeHeadings++;
          } else if (item.type === 'BOLD_HEADER') {
            visualHeadings++;
          }
        });

        // Suggest if there are visual headings but few native ones
        if (visualHeadings > 0 && nativeHeadings < visualHeadings) {
          suggestionText.textContent = 'Hi ha ' + visualHeadings + ' títols visuals que podrien ser headings natius. Usa Auto-Structure per millorar l\'accessibilitat.';
          suggestionEl.classList.remove('hidden');
        } else {
          suggestionEl.classList.add('hidden');
        }
      }

      function applySuggestion() {
        runAutoStructure();
        document.getElementById('structureSuggestion').classList.add('hidden');
      }

      function dismissSuggestion() {
        document.getElementById('structureSuggestion').classList.add('hidden');
      }

      function filterOutline() {
        const searchValue = document.getElementById('structureSearch').value.toLowerCase();
        const items = document.querySelectorAll('.outline-item');

        items.forEach(function(item) {
          const text = item.querySelector('.outline-text').textContent.toLowerCase();
          if (text.includes(searchValue) || searchValue === '') {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
      }

      // ═══════════════════════════════════════════════════════════
      // STYLE PICKER - Canviar estil de paràgraf
      // ═══════════════════════════════════════════════════════════

      var activeStylePicker = null;

      function showStylePicker(paraIndex, targetEl) {
        // Tancar picker anterior si existeix
        hideStylePicker();

        const styles = [
          { label: 'Títol 1', value: 'HEADING1', class: 'h1' },
          { label: 'Títol 2', value: 'HEADING2', class: 'h2' },
          { label: 'Títol 3', value: 'HEADING3', class: 'h3' },
          { label: 'Normal', value: 'NORMAL', class: 'p' }
        ];

        const picker = document.createElement('div');
        picker.className = 'style-picker';
        picker.innerHTML = styles.map(function(s) {
          return '<div class="style-picker-option ' + s.class + '" onclick="changeParaStyle(' + paraIndex + ', \'' + s.value + '\')">' + s.label + '</div>';
        }).join('');

        // Posicionar sota l'element
        const rect = targetEl.getBoundingClientRect();
        picker.style.position = 'fixed';
        picker.style.left = rect.left + 'px';
        picker.style.top = (rect.bottom + 4) + 'px';
        picker.style.zIndex = '9999';

        document.body.appendChild(picker);
        activeStylePicker = picker;

        // Tancar al clicar fora
        setTimeout(function() {
          document.addEventListener('click', hideStylePicker, { once: true });
        }, 10);
      }

      function hideStylePicker() {
        if (activeStylePicker) {
          activeStylePicker.remove();
          activeStylePicker = null;
        }
      }

      function changeParaStyle(paraIndex, newStyle) {
        hideStylePicker();
        showToast('Canviant estil...', 'info');

        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              showToast('Estil canviat correctament', 'success');
              refreshStructure(); // Refrescar outline
            } else {
              showToast('Error: ' + (result ? result.error : 'Desconegut'), 'error');
            }
          })
          .withFailureHandler(function(err) {
            showToast('Error: ' + err.message, 'error');
          })
          .setParagraphHeading(paraIndex, newStyle);
      }

      function scrollToElement(idx) {
        // Highlight UI instantly (before backend call)
        const items = document.querySelectorAll('.outline-item');
        items.forEach(function(item) {
          item.classList.remove('active');
          if (item.dataset.idx == idx) {
            item.classList.add('active');
          }
        });

        // Then scroll in document
        google.script.run.scrollToParagraph(idx);
      }

      // ═══════════════════════════════════════════════════════════════
      // v10.3: REWRITE PREVIEW FUNCTIONS
      // ═══════════════════════════════════════════════════════════════

      /**
       * Accepta i aplica el rewrite pendent
       */
      function acceptRewrite() {
        if (!window._pendingRewrite) {
          showToast('No hi ha rewrite pendent', 'warning');
          return;
        }

        const { blocks, is_selection } = window._pendingRewrite;

        // Desactivar botons mentre s'aplica
        document.querySelectorAll('.rewrite-preview-actions button').forEach(btn => {
          btn.disabled = true;
        });

        showToast('Aplicant canvis...', 'info');

        google.script.run
          .withSuccessHandler(function(result) {
            if (result.ok) {
              showToast('Document reescrit correctament', 'success');
              // Eliminar la nota de preview
              const lastReviewNote = document.querySelector('.chat-bubble.review-note:last-of-type');
              if (lastReviewNote) {
                lastReviewNote.innerHTML = '<span>' + icon('check', 'i--sm i--success') + ' Canvis aplicats</span>';
              }
            } else {
              showToast(result.error || 'Error aplicant rewrite', 'error');
            }
            window._pendingRewrite = null;
          })
          .withFailureHandler(function(err) {
            showToast('Error: ' + err.message, 'error');
            // Re-activar botons
            document.querySelectorAll('.rewrite-preview-actions button').forEach(btn => {
              btn.disabled = false;
            });
          })
          .applyPendingRewrite(blocks, is_selection);
      }

      /**
       * Cancel·la el rewrite pendent
       */
      function cancelRewrite() {
        window._pendingRewrite = null;
        showToast('Rewrite cancel·lat', 'info');

        // Actualitzar la nota de preview
        const lastReviewNote = document.querySelector('.chat-bubble.review-note:last-of-type');
        if (lastReviewNote) {
          lastReviewNote.innerHTML = '<span>' + icon('x', 'i--sm i--muted') + ' Canvis descartats</span>';
        }
      }

      /**
       * Mostra les diferències entre l'original i el proposat
       */
      function showRewriteDiff() {
        if (!window._pendingRewrite) {
          showToast('No hi ha rewrite pendent', 'warning');
          return;
        }

        // v10.3.1: Evitar múltiples modals - tancar existent primer
        const existingModal = document.querySelector('.diff-modal');
        if (existingModal) {
          existingModal.remove();
        }

        const { original_text, proposed_text } = window._pendingRewrite;

        // Crear modal de diferències
        const diffModal = document.createElement('div');
        diffModal.className = 'diff-modal';
        diffModal.innerHTML = `
          <div class="diff-modal-content">
            <div class="diff-header">
              <h3>Diferències</h3>
              <button onclick="this.closest('.diff-modal').remove()" class="btn-close-diff">${icon('x', 'i--sm')}</button>
            </div>
            <div class="diff-columns">
              <div class="diff-column diff-original">
                <h4>Original</h4>
                <pre>${escapeHtml(original_text || '(buit)')}</pre>
              </div>
              <div class="diff-column diff-proposed">
                <h4>Proposat</h4>
                <pre>${escapeHtml(proposed_text || '(buit)')}</pre>
              </div>
            </div>
          </div>
        `;

        document.body.appendChild(diffModal);

        // Tancar amb click fora
        diffModal.addEventListener('click', function(e) {
          if (e.target === diffModal) {
            diffModal.remove();
          }
        });
      }

      /**
       * Scroll to the last edited paragraph in the document
       * v9.3: Prioritzar bodyIndex (índex real) sobre elementId (pot desincronitzar-se)
       * v9.4: Animació "respira" a l'ull mentre es processa
       * Auto-clear del highlight després de 2.5 segons
       */
      function scrollToLastEdit(btn) {
        // v9.4: Activar animació de respiració
        if (btn) btn.classList.add('breathing');

        function stopBreathing() {
          if (btn) btn.classList.remove('breathing');
        }

        google.script.run
          .withSuccessHandler(function(lastEdit) {
            if (!lastEdit) {
              stopBreathing();
              showToast('No hi ha edició recent', 'info');
              return;
            }

            // v9.3: Prioritzar bodyIndex (més fiable) sobre elementId
            var mode, value;
            if (lastEdit.bodyIndex !== undefined && lastEdit.bodyIndex >= 0) {
              mode = 'bodyIndex';
              value = lastEdit.bodyIndex;
            } else if (lastEdit.targetId !== undefined && lastEdit.targetId !== null) {
              mode = 'elementId';
              value = parseInt(lastEdit.targetId, 10);
            } else {
              stopBreathing();
              showToast('No hi ha edició recent', 'info');
              return;
            }

            google.script.run
              .withSuccessHandler(function(result) {
                stopBreathing();
                if (result.success) {
                  // Auto-clear highlight after 2.5s
                  setTimeout(function() {
                    google.script.run.clearHighlight();
                  }, 2500);
                } else {
                  showToast(result.error || 'Element no trobat', 'info');
                }
              })
              .withFailureHandler(function(err) {
                stopBreathing();
                showToast('Error navegant al document', 'error');
              })
              .highlightElement({ mode: mode, value: value });
          })
          .withFailureHandler(function(err) {
            stopBreathing();
            showToast('Error navegant', 'error');
          })
          .loadLastEdit();
      }

      // Legacy function alias for compatibility - redirects to new function
      function refreshSkeleton() {
        refreshStructure();
      }

      function renderSkeletonPreview(skeleton) {
        const previewEl = document.getElementById('skeletonPreview');
        const suggestionEl = document.getElementById('skeletonSuggestion');

        if (!skeleton || !skeleton.structure || skeleton.structure.length === 0) {
          previewEl.innerHTML = '<div class="skeleton-item">Cap estructura detectada</div>';
          previewEl.classList.remove('hidden');
          if (suggestionEl) suggestionEl.classList.add('hidden');
          return;
        }

        // Count types for suggestions
        let nativeHeadings = 0;
        let visualHeadings = 0;
        let sections = 0;

        let html = '';
        let currentIndent = 0;

        skeleton.structure.forEach(function(item, idx) {
          if (item.type === 'SECTION') {
            sections++;
            const indentClass = currentIndent > 0 ? ' indent-' + Math.min(currentIndent, 3) : '';
            html += '<div class="skeleton-item section' + indentClass + '">';
            html += '<span class="skeleton-badge section">§</span>';
            html += item.preview.substring(0, 45) + (item.preview.length > 45 ? '...' : '');
            html += '</div>';
            if (item.entities && item.entities.length > 0) {
              html += '<div class="skeleton-entities">└─ ' + item.entities.slice(0, 3).join(', ') + '</div>';
            }
          } else if (item.type === 'WARNING') {
            html += '<div class="skeleton-item" style="color: var(--warning);">' + icon('alertTriangle', 'i--sm i--warning') + ' ' + item.text + '</div>';
          } else {
            // Heading types
            const isVisual = (item.type === 'VISUAL_H' || item.type === 'BOLD_H');
            if (isVisual) {
              visualHeadings++;
            } else {
              nativeHeadings++;
            }

            // Calculate indent based on heading level
            if (item.type === 'H1' || item.type === 'TITLE') currentIndent = 1;
            else if (item.type === 'H2' || item.type === 'SUBTITLE') currentIndent = 2;
            else if (item.type === 'H3') currentIndent = 3;
            else if (isVisual) currentIndent = Math.min(currentIndent + 1, 3);

            const indentClass = currentIndent > 1 ? ' indent-' + (currentIndent - 1) : '';
            const badgeClass = isVisual ? 'visual' : 'heading';
            const itemIcon = isVisual ? icon('zap', 'i--sm i--warning') : icon('pin', 'i--sm i--accent');
            const badgeText = item.type.replace('_H', '').replace('HEADING', 'H');

            html += '<div class="skeleton-item heading' + indentClass + '">';
            html += '<span class="skeleton-badge ' + badgeClass + '">' + badgeText + '</span>';
            html += itemIcon + ' ' + item.text.substring(0, 40) + (item.text.length > 40 ? '...' : '');
            html += '</div>';
          }
        });

        previewEl.innerHTML = html;
        previewEl.classList.remove('hidden');

        // Show suggestion if visual headings but no native
        if (suggestionEl) {
          if (nativeHeadings === 0 && visualHeadings > 0) {
            suggestionEl.innerHTML =
              '<span class="suggestion-text">' + icon('zap', 'i--sm i--warning') + ' Detectats ' + visualHeadings + ' títols sense format natiu</span>' +
              '<button class="suggestion-btn" onclick="runAutoStructure()">Auto-Structure</button>';
            suggestionEl.classList.remove('hidden');
          } else {
            suggestionEl.classList.add('hidden');
          }
        }
      }

      function runAutoStructure() {
        showToast('Aplicant Auto-Structure...', 'info');

        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success) {
              if (result.converted > 0) {
                showToast(result.converted + ' títols convertits a H2', 'success');
                // Refresh structure to show new headings
                setTimeout(refreshStructure, 500);
              } else {
                showToast('Cap canvi necessari - estructura correcta', 'info');
              }
            } else {
              showToast('Error: ' + (result ? result.error : 'Unknown'), 'error');
            }
          })
          .withFailureHandler(function(err) {
            showToast('Error: ' + err.message, 'error');
          })
          .applyAutoStructure();
      }

      // ═══════════════════════════════════════════════════════════
      // REVERT LAST EDIT (v2.6)
      // ═══════════════════════════════════════════════════════════

      function revertLastEdit(btn) {
        // Disable button to prevent double-click
        btn.disabled = true;
        btn.innerHTML = '<svg class="spinner" width="10" height="10" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" opacity="0.3"/></svg>';

        google.script.run
          .withSuccessHandler(function(res) {
            if (res.success) {
              // Update the badge to show reverted
              const badge = btn.parentElement;
              badge.innerHTML = '<span style="color: var(--warning);">' + icon('undo', 'i--warning i--sm') + ' Canvi desfet</span>';
              badge.style.background = 'rgba(249, 171, 0, 0.1)';
              badge.style.borderColor = 'var(--warning)';
              badge.style.color = 'var(--warning)';

              // Add system message
              addBubble('system', icon('undo', 'i--sm i--accent') + ' Desfet!');
            } else {
              btn.disabled = false;
              btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>Desfer';
              alert('No s\'ha pogut desfer: ' + (res.error || 'Error desconegut'));
            }
          })
          .withFailureHandler(function(err) {
            btn.disabled = false;
            btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>Desfer';
            alert('Error: ' + err.message);
          })
          .revertLastEdit();
      }

      // ═══════════════════════════════════════════════════════════
      // EDIT HISTORY (v3.0 Event Sourcing)
      // ═══════════════════════════════════════════════════════════

      let editHistory = [];

      function refreshHistory() {
        const statusEl = document.getElementById('historyStatus');
        const listEl = document.getElementById('historyList');

        statusEl.textContent = 'Carregant...';
        listEl.innerHTML = '<div class="history-empty">Carregant historial...</div>';

        google.script.run
          .withSuccessHandler(function(result) {
            if (result && result.success && result.history) {
              editHistory = result.history;
              const activeCount = editHistory.filter(function(e) { return !e.is_reverted; }).length;
              statusEl.textContent = activeCount + ' edicions actives';
              renderHistoryList();
            } else if (result && result.error) {
              statusEl.textContent = 'Error';
              listEl.innerHTML = '<div class="history-empty" style="color: var(--error);">' + result.error + '</div>';
            } else {
              statusEl.textContent = 'Sense historial';
              listEl.innerHTML = '<div class="history-empty">Cap edició registrada</div>';
            }
          })
          .withFailureHandler(function(err) {
            statusEl.textContent = 'Error';
            listEl.innerHTML = '<div class="history-empty" style="color: var(--error);">Error: ' + err.message + '</div>';
          })
          .getEditHistory(10);
      }

      function renderHistoryList() {
        const listEl = document.getElementById('historyList');

        if (!editHistory || editHistory.length === 0) {
          listEl.innerHTML = '<div class="history-empty">Cap edició registrada</div>';
          return;
        }

        const typeIconNames = {
          'UPDATE_BY_ID': 'edit',
          'REWRITE': 'fileText',
          'REVERT': 'undo',
          'AUTO_STRUCTURE': 'wand'
        };

        const typeLabels = {
          'UPDATE_BY_ID': 'Edit',
          'REWRITE': 'Rewrite',
          'REVERT': 'Revert',
          'AUTO_STRUCTURE': 'Auto'
        };

        let html = '';
        editHistory.forEach(function(event) {
          const iconName = typeIconNames[event.event_type] || 'file';
          const typeLabel = typeLabels[event.event_type] || event.event_type;
          const instruction = event.user_instruction || '(Sense instrucció)';
          const timeAgo = formatTimeAgo(new Date(event.created_at));
          const isReverted = event.is_reverted;

          html += '<div class="history-item' + (isReverted ? ' reverted' : '') + '" data-id="' + event.id + '">';
          html += '<span class="history-icon">' + icon(iconName, 'i--default') + '</span>';
          html += '<div class="content">';
          html += '<div class="instruction" title="' + escapeHtml(instruction) + '">' + escapeHtml(instruction.substring(0, 50)) + (instruction.length > 50 ? '...' : '') + '</div>';
          html += '<div class="meta">';
          html += '<span class="type-badge">' + typeLabel + '</span>';
          html += '<span>' + timeAgo + '</span>';
          if (event.target_id !== null && event.target_id !== undefined) {
            html += '<span>¶' + event.target_id + '</span>';
          }
          html += '</div></div>';

          if (!isReverted && event.event_type !== 'REVERT') {
            html += '<button class="revert-action" onclick="event.stopPropagation(); revertHistoryItem(\'' + event.id + '\')">' + icon('undo', 'i--sm') + ' Desfer</button>';
          }

          html += '</div>';
        });

        listEl.innerHTML = html;
      }

      function formatTimeAgo(date) {
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Ara';
        if (diffMins < 60) return diffMins + ' min';
        if (diffHours < 24) return diffHours + 'h';
        if (diffDays < 7) return diffDays + 'd';
        return date.toLocaleDateString('ca-ES', { day: 'numeric', month: 'short' });
      }

      function revertHistoryItem(eventId) {
        const item = document.querySelector('.history-item[data-id="' + eventId + '"]');
        if (!item) return;

        const btn = item.querySelector('.revert-action');
        if (btn) {
          btn.disabled = true;
          btn.textContent = '...';
        }

        google.script.run
          .withSuccessHandler(function(res) {
            if (res && res.success) {
              showToast('Edició desfeta', 'undo');
              // Refresh the history list
              refreshHistory();
              // Add system message to chat
              addBubble('system', icon('undo', 'i--default') + ' Edició desfeta');
            } else {
              if (btn) {
                btn.disabled = false;
                btn.innerHTML = icon('undo', 'i--sm') + ' Desfer';
              }
              showToast(res ? res.error : 'Error desconegut', 'error');
            }
          })
          .withFailureHandler(function(err) {
            if (btn) {
              btn.disabled = false;
              btn.innerHTML = icon('undo', 'i--sm') + ' Desfer';
            }
            showToast('Error: ' + err.message, 'error');
          })
          .revertEditById(eventId);
      }
    </script>

    <!-- v4.0: Ban Tooltip (Sprint 2) -->
    <div id="banTooltip" class="ban-tooltip">
      <span class="ban-tooltip-word" id="banTooltipWord"></span>
      <button class="ban-tooltip-btn" onclick="banSelectedWord()">
        <span class="i i--error i--sm"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg></span> No usis això
      </button>
    </div>
  </body>
</html>
