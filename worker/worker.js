/**
 * SIDECAR CORE API v2.8 - Banned Expressions & Hybrid Validator
 *
 * v2.8 features:
 * - NEW: Banned Expressions (negative_constraints)
 * - NEW: Hybrid Validator (local regex + LLM retry)
 * - NEW: Pre-validation warning for input containing banned words
 *
 * v2.7 features (preserved):
 * - "Motor d'Enginyeria" system prompt (Lovable-style)
 * - Mandatory "thought" field (Chain of Thought)
 * - Retry loop for invalid JSON (1 retry with feedback)
 *
 * v2.6.x features (preserved):
 * - Mode selector (auto | edit | chat)
 * - lastEdit memory, revert button, pinned_prefs
 */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UTILITY FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * v2.8: Check if text contains any banned words
 * Returns array of found banned words, or empty array if clean
 */
function findBannedWords(text, bannedWords) {
  if (!bannedWords || !Array.isArray(bannedWords) || bannedWords.length === 0) {
    return [];
  }

  const found = [];
  const lowerText = text.toLowerCase();

  for (const word of bannedWords) {
    if (!word) continue;
    const lowerWord = word.toLowerCase();
    // Use word boundary matching to avoid partial matches
    const regex = new RegExp('\\b' + escapeRegex(lowerWord) + '\\b', 'i');
    if (regex.test(lowerText)) {
      found.push(word);
    }
  }

  return found;
}

/**
 * Escape special regex characters
 */
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * v2.8: Extract all text from a parsed response for validation
 */
function getOutputText(parsedResponse) {
  if (!parsedResponse) return '';

  let text = '';

  // Chat response
  if (parsedResponse.chat_response) {
    text += ' ' + parsedResponse.chat_response;
  }

  // Change summary
  if (parsedResponse.change_summary) {
    text += ' ' + parsedResponse.change_summary;
  }

  // Updates (UPDATE_BY_ID mode)
  if (parsedResponse.updates && typeof parsedResponse.updates === 'object') {
    for (const value of Object.values(parsedResponse.updates)) {
      if (typeof value === 'string') {
        text += ' ' + value;
      }
    }
  }

  // Blocks (REWRITE mode)
  if (parsedResponse.blocks && Array.isArray(parsedResponse.blocks)) {
    for (const block of parsedResponse.blocks) {
      if (block.text) {
        text += ' ' + block.text;
      }
    }
  }

  return text;
}

async function hashKey(licenseKey) {
  const msgBuffer = new TextEncoder().encode(licenseKey);
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function useCredits(env, licenseHash, docMetadata) {
  const supabaseResp = await fetch(`${env.SUPABASE_URL}/rest/v1/rpc/use_license_credits`, {
    method: 'POST',
    headers: {
      'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
      'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      p_license_key_hash: licenseHash,
      p_cost: 1,
      p_operation: 'chat_v24',
      p_metadata: docMetadata || {}
    })
  });
  return supabaseResp.json();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SYSTEM PROMPT v3 - "Document Engineering Engine" (Lovable-style)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function buildSystemPrompt(hasSelection, hasFile, styleGuide, strictMode, negativeConstraints) {
  let prompt = `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
IDENTITAT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Ets SideCar, un MOTOR D'ENGINYERIA DOCUMENTAL.
NO ets un xatbot passiu. Ets un AGENT D'EXECUCI√ì que transforma intencions en operacions at√≤miques.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
PROTOCOL D'EXECUCI√ì (Chain of Thought - OBLIGATORI)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ABANS de generar el JSON, ANALITZA internament i escriu el teu raonament al camp "thought":

1. INTENCI√ì ‚Üí Qu√® vol l'usuari? (Editar | Crear | Consultar)
2. LOCALITZACI√ì ‚Üí On afecta? (Selecci√≥ activa: ${hasSelection ? 'S√ç - apunta a text espec√≠fic' : 'NO - document complet'})
3. ESTRAT√àGIA ‚Üí Quina √©s la M√çNIMA operaci√≥ necess√†ria?

El camp "thought" √©s OBLIGATORI en TOTES les respostes.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CONTEXT ACTUAL
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
- Selecci√≥ activa: ${hasSelection ? 'S√ç (l\'usuari ha seleccionat text espec√≠fic)' : 'NO'}
- Fitxer de coneixement: ${hasFile ? 'S√ç (usa\'l com a font)' : 'NO'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
MODES D'OPERACI√ì
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

[MODE CONSULTOR] ‚Üí "CHAT_ONLY"
Quan: Preguntes, opinions, an√†lisi, explicacions, resums informatius.
Acci√≥: Respon al xat. NO toques el document.

[MODE ENGINYER] ‚Üí "UPDATE_BY_ID"
Quan: L'usuari demana CANVIS (millora, tradueix, corregeix, canvia, escur√ßa, amplia).
Acci√≥: Edita NOM√âS els par√†grafs afectats via {{ID}}. Cirurgia, no reempla√ßament.

[MODE ARQUITECTE] ‚Üí "REWRITE"
Quan: L'usuari demana CREAR contingut NOU (escriu un email, genera una llista, crea des de zero).
Acci√≥: Genera estructura nova amb blocks tipats.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
GESTI√ì DE CONTINU√èTAT (CR√çTIC)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Si l'usuari diu "una altra", "aquesta no m'agrada", "canvia-la", "no", "diferent":
‚Üí Es refereix al CANVI ANTERIOR. Proposa una alternativa DIFERENT.
‚Üí MAI tornis a una versi√≥ ja rebutjada.
‚Üí MAI preguntis "un altre qu√®?" si tens context d'un canvi recent.

Exemples:
- "canvia X per Y" ‚Üí ho fas ‚Üí "una altra" = alternativa a Y, diferent de X i Y
- "millora-ho" ‚Üí ho fas ‚Üí "no m'agrada" = nova versi√≥, diferent de l'anterior

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
DIRECTIVES D'ESTIL
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
- Sigues AUDA√á: "millora-ho" = millores substancials, no cosm√®tiques
- Preserva format Markdown (**negreta**, *cursiva*) en edicions
- Respon en l'IDIOMA de l'usuari
- Si tens dubtes ‚Üí PREGUNTA abans d'editar

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FORMAT JSON (OBLIGATORI - SENSE TEXT EXTRA)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

**CHAT_ONLY:**
{
  "thought": "[An√†lisi: intenci√≥ + localitzaci√≥ + estrat√®gia]",
  "mode": "CHAT_ONLY",
  "chat_response": "Resposta al xat",
  "change_summary": "Consulta resolta"
}

**UPDATE_BY_ID:** (el text ve marcat amb {{ID}})
{
  "thought": "[An√†lisi: intenci√≥ + localitzaci√≥ + estrat√®gia]",
  "mode": "UPDATE_BY_ID",
  "updates": {
    "0": "Text nou pel par√†graf 0",
    "3": "Text nou pel par√†graf 3"
  },
  "change_summary": "Descripci√≥ breu dels canvis"
}

**REWRITE:**
{
  "thought": "[An√†lisi: intenci√≥ + localitzaci√≥ + estrat√®gia]",
  "mode": "REWRITE",
  "blocks": [
    { "type": "HEADING_1", "text": "T√≠tol" },
    { "type": "PARAGRAPH", "text": "Contingut" },
    { "type": "BULLET_LIST", "text": "Element de llista" }
  ],
  "change_summary": "Descripci√≥ del contingut generat"
}

Tipus de blocks: HEADING_1, HEADING_2, HEADING_3, PARAGRAPH, BULLET_LIST, NUMBERED_LIST
`;

  // Style guide
  if (styleGuide && styleGuide.trim()) {
    prompt += `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
GUIA D'ESTIL PERSONALITZADA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${styleGuide}
`;
  }

  // Strict mode
  if (strictMode) {
    prompt += `
‚ö†Ô∏è MODE ESTRICTE ACTIU: Respon NOM√âS amb informaci√≥ verificable del context/fitxer. NO inventis dades.
`;
  }

  // v2.8: Negative constraints (banned words)
  if (negativeConstraints && Array.isArray(negativeConstraints) && negativeConstraints.length > 0) {
    prompt += `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚õî PARAULES PROHIBIDES (CR√çTIC - MAI USAR)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
L'usuari ha prohibit EXPRESSAMENT les seg√ºents paraules/frases.
NO les utilitzis MAI en cap circumst√†ncia, ni en edicions ni en respostes.
Si el text original les cont√©, substitueix-les per sin√≤nims adequats.

LLISTA NEGRA: ${negativeConstraints.join(', ')}

Si alguna d'aquestes paraules apareix al text que est√†s editant, REEMPLA√áA-LA autom√†ticament.
`;
  }

  return prompt;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SAFE JSON PARSER - Never crashes, always returns something
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function safeParseJSON(rawText) {
  // Step 1: Try direct parse
  try {
    return JSON.parse(rawText);
  } catch (e) {
    // Continue to extraction
  }

  // Step 2: Try to extract first {...} block (model sometimes adds text around JSON)
  try {
    const match = rawText.match(/\{[\s\S]*\}/);
    if (match) {
      return JSON.parse(match[0]);
    }
  } catch (e) {
    // Continue to fallback
  }

  // Step 3: Return null to signal failure
  return null;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RESPONSE PARSER AND VALIDATOR - Robust normalization
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function parseAndValidate(rawText) {
  // Try to parse JSON safely
  let parsed = safeParseJSON(rawText);

  // If JSON fails completely, treat as chat response
  if (!parsed || typeof parsed !== 'object') {
    return {
      mode: "CHAT_ONLY",
      chat_response: rawText || "No he pogut processar la resposta.",
      change_summary: "Resposta de text lliure"
    };
  }

  // ‚îÄ‚îÄ‚îÄ NORMALIZE MODE ‚îÄ‚îÄ‚îÄ
  // Accept various formats and normalize to our 3 valid modes
  const rawMode = (parsed.mode || parsed.operation || '').toString().toUpperCase().trim();

  // Map all possible values to our valid modes
  const modeMap = {
    // Valid modes
    'CHAT_ONLY': 'CHAT_ONLY',
    'UPDATE_BY_ID': 'UPDATE_BY_ID',
    'REWRITE': 'REWRITE',
    // Common variations ‚Üí CHAT_ONLY
    'CHAT': 'CHAT_ONLY',
    'NO_OP': 'CHAT_ONLY',
    'NOOP': 'CHAT_ONLY',
    'EXPLAIN': 'CHAT_ONLY',
    'ANSWER': 'CHAT_ONLY',
    'RESPONSE': 'CHAT_ONLY',
    // Common variations ‚Üí UPDATE_BY_ID
    'UPDATE': 'UPDATE_BY_ID',
    'EDIT': 'UPDATE_BY_ID',
    'MODIFY': 'UPDATE_BY_ID',
    'CHANGE': 'UPDATE_BY_ID',
    // Common variations ‚Üí REWRITE
    'INSERT': 'REWRITE',
    'INSERT_AFTER': 'REWRITE',
    'INSERT_BEFORE': 'REWRITE',
    'CREATE': 'REWRITE',
    'GENERATE': 'REWRITE'
  };

  parsed.mode = modeMap[rawMode] || 'CHAT_ONLY';  // DEFAULT: CHAT_ONLY (safe)

  // ‚îÄ‚îÄ‚îÄ VALIDATE UPDATE_BY_ID ‚îÄ‚îÄ‚îÄ
  if (parsed.mode === 'UPDATE_BY_ID') {
    if (!parsed.updates || typeof parsed.updates !== 'object' || Object.keys(parsed.updates).length === 0) {
      // No valid updates ‚Üí convert to CHAT
      parsed.mode = 'CHAT_ONLY';
      parsed.chat_response = parsed.change_summary || parsed.userMessage || "No s'han trobat canvis a aplicar.";
    }
  }

  // ‚îÄ‚îÄ‚îÄ VALIDATE REWRITE ‚îÄ‚îÄ‚îÄ
  if (parsed.mode === 'REWRITE') {
    if (!parsed.blocks || !Array.isArray(parsed.blocks) || parsed.blocks.length === 0) {
      // No valid blocks ‚Üí convert to CHAT
      parsed.mode = 'CHAT_ONLY';
      parsed.chat_response = parsed.change_summary || parsed.userMessage || "No s'ha pogut generar contingut nou.";
    }
  }

  // ‚îÄ‚îÄ‚îÄ GUARANTEE chat_response FOR CHAT_ONLY ‚îÄ‚îÄ‚îÄ
  if (parsed.mode === 'CHAT_ONLY') {
    // Try multiple fields to find a response
    parsed.chat_response = parsed.chat_response
      || parsed.userMessage
      || parsed.message
      || parsed.response
      || parsed.change_summary
      || parsed.explanation
      || parsed.newText  // Sometimes model puts chat in wrong field
      || "Entesos. Qu√® m√©s puc fer per tu?";  // Ultimate fallback
  }

  // ‚îÄ‚îÄ‚îÄ GUARANTEE change_summary ‚îÄ‚îÄ‚îÄ
  if (!parsed.change_summary) {
    parsed.change_summary = parsed.userMessage || parsed.reason || "Operaci√≥ completada.";
  }

  // ‚îÄ‚îÄ‚îÄ GUARANTEE thought (v2.7 - Chain of Thought) ‚îÄ‚îÄ‚îÄ
  if (!parsed.thought) {
    // Generate a default thought based on the mode
    const modeThoughts = {
      'CHAT_ONLY': 'Intenci√≥: consulta. Estrat√®gia: respondre sense editar.',
      'UPDATE_BY_ID': 'Intenci√≥: edici√≥. Estrat√®gia: modificar par√†grafs espec√≠fics.',
      'REWRITE': 'Intenci√≥: creaci√≥. Estrat√®gia: generar contingut nou.'
    };
    parsed.thought = modeThoughts[parsed.mode] || 'Processant petici√≥.';
  }

  return parsed;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN ENTRY POINT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export default {
  async fetch(request, env) {
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, apikey",
    };

    if (request.method === "OPTIONS") return new Response(null, { headers: corsHeaders });
    if (request.method !== "POST") return new Response("Method not allowed", { status: 405, headers: corsHeaders });

    try {
      const body = await request.json();

      // Route to appropriate handler
      if (body.action === 'upload_file') {
        return await handleFileUpload(body, env, corsHeaders);
      }
      if (body.action === 'get_receipts') {
        return await handleGetReceipts(body, env, corsHeaders);
      }
      if (body.action === 'save_receipt') {
        return await handleSaveReceipt(body, env, corsHeaders);
      }
      if (body.action === 'delete_receipt') {
        return await handleDeleteReceipt(body, env, corsHeaders);
      }

      // Default: Chat handler
      return await handleChat(body, env, corsHeaders);

    } catch (err) {
      return new Response(JSON.stringify({ status: "error", error_code: err.message }),
        { status: 500, headers: corsHeaders });
    }
  }
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHAT HANDLER - v2.4 with Conversational Memory
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function handleChat(body, env, corsHeaders) {
  const {
    license_key,
    text,
    user_instruction,
    doc_metadata,
    style_guide,
    strict_mode,
    knowledge_file_uri,
    knowledge_file_mime,
    has_selection,
    chat_history,  // Conversational memory
    last_edit,     // v2.6: Last edit memory for "una altra" cases
    user_mode,     // v2.6.2: User-selected mode (auto | edit | chat)
    negative_constraints  // v2.8: Banned words/phrases
  } = body;

  if (!license_key) throw new Error("missing_license");
  if (!text) throw new Error("missing_text");

  // 1. License validation and credit usage
  const licenseHash = await hashKey(license_key);
  const creditsResult = await useCredits(env, licenseHash, doc_metadata);

  // 2. Build system prompt (context-driven)
  const systemPrompt = buildSystemPrompt(
    has_selection || false,
    !!knowledge_file_uri,
    style_guide,
    strict_mode,
    negative_constraints  // v2.8: Banned words
  );

  // 3. Build contents array with chat history (MEMORY)
  const contents = [];

  // Add user preferences FIRST (before history, so model has context)
  if (body.pinned_prefs) {
    contents.push({
      role: 'user',
      parts: [{
        text: `Prefer√®ncies de l'usuari per aquest document:\n${JSON.stringify(body.pinned_prefs, null, 2)}`
      }]
    });
    // Model acknowledges preferences
    contents.push({
      role: 'model',
      parts: [{
        text: 'Ent√®s, tindr√© en compte aquestes prefer√®ncies.'
      }]
    });
  }

  // v2.6: Add last edit memory (for "una altra", "canvia-la", etc.)
  if (last_edit && last_edit.targetId !== undefined) {
    contents.push({
      role: 'user',
      parts: [{
        text: `√öLTIM CANVI FET (mem√≤ria per si l'usuari demana alternatives):
- ID del par√†graf: {{${last_edit.targetId}}}
- Text ORIGINAL (abans del canvi): "${last_edit.originalText}"
- Text ACTUAL (despr√©s del canvi): "${last_edit.currentText}"`
      }]
    });
    contents.push({
      role: 'model',
      parts: [{
        text: 'Ent√®s, recordo aquest canvi. Si l\'usuari diu "una altra", "canvia-la", "no m\'agrada", etc., proposar√© una alternativa per al mateix fragment.'
      }]
    });
  }

  // Add previous conversation history
  if (chat_history && Array.isArray(chat_history)) {
    chat_history.forEach(msg => {
      if (msg.role && msg.text) {
        contents.push({
          role: msg.role,  // 'user' or 'model'
          parts: [{ text: msg.text }]
        });
      }
    });
  }

  // Build current context message
  const instruction = user_instruction || "Processa el text";
  let currentMessage = `CONTEXT F√çSIC:
- Text Seleccionat: ${has_selection ? 'S√ç' : 'NO'}
- Document ID: ${doc_metadata?.doc_id || 'unknown'}

TEXT ACTUAL DEL DOCUMENT:
${text}

INSTRUCCI√ì DE L'USUARI:
"${instruction}"`;

  // Add current message with optional file
  const userParts = [];

  if (knowledge_file_uri) {
    userParts.push({
      fileData: {
        fileUri: knowledge_file_uri,
        mimeType: knowledge_file_mime || "application/pdf"
      }
    });
  }

  userParts.push({ text: currentMessage });
  contents.push({ role: 'user', parts: userParts });

  // 4. Call Gemini with retry loop (v2.7 + v2.8 banned word validation)
  const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${env.GEMINI_API_KEY}`;

  let parsedResponse = null;
  let retryCount = 0;
  const MAX_RETRIES = 2;  // v2.8: Increased to allow for banned word retry
  let currentContents = [...contents];
  let bannedWordRetry = false;

  while (retryCount <= MAX_RETRIES) {
    const geminiResp = await fetch(geminiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: currentContents,
        system_instruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          temperature: retryCount === 0 ? 0.4 : 0.2  // Lower temp on retry for more deterministic output
        }
      })
    });

    if (!geminiResp.ok) throw new Error("gemini_error: " + await geminiResp.text());
    const geminiData = await geminiResp.json();

    const rawResponse = geminiData.candidates[0].content.parts[0].text;

    // Try to parse JSON
    const directParse = safeParseJSON(rawResponse);

    if (directParse !== null) {
      // Valid JSON - now check for banned words (v2.8)
      parsedResponse = parseAndValidate(rawResponse);

      // v2.8: Validate output doesn't contain banned words
      if (negative_constraints && negative_constraints.length > 0) {
        const outputText = getOutputText(parsedResponse);
        const foundBanned = findBannedWords(outputText, negative_constraints);

        if (foundBanned.length > 0 && !bannedWordRetry && retryCount < MAX_RETRIES) {
          // Banned words found - retry with specific feedback
          bannedWordRetry = true;
          retryCount++;
          currentContents = [...contents];
          currentContents.push({
            role: 'model',
            parts: [{ text: rawResponse }]
          });
          currentContents.push({
            role: 'user',
            parts: [{
              text: `ERROR: La teva resposta cont√© paraules PROHIBIDES: "${foundBanned.join('", "')}".
Aquestes paraules estan a la LLISTA NEGRA de l'usuari i MAI s'han d'usar.
REESCRIU la resposta substituint aquestes paraules per sin√≤nims acceptables.`
            }]
          });
          continue;  // Retry
        }
      }

      // All validations passed
      break;
    } else if (retryCount < MAX_RETRIES) {
      // Invalid JSON - retry with error feedback
      retryCount++;
      currentContents = [...contents];
      currentContents.push({
        role: 'model',
        parts: [{ text: rawResponse }]
      });
      currentContents.push({
        role: 'user',
        parts: [{
          text: 'ERROR: La teva resposta no era JSON v√†lid. Torna a intentar-ho amb NOM√âS el JSON, sense text extra. Recorda el format: { "thought": "...", "mode": "...", ... }'
        }]
      });
    } else {
      // Max retries reached - use fallback
      parsedResponse = parseAndValidate(rawResponse);
      break;
    }
  }

  // 5.1 Mode enforcement (v2.6.2)
  const effectiveMode = user_mode || 'auto';
  if (effectiveMode === 'chat') {
    // Force CHAT_ONLY: Never edit, convert any edit response to chat
    if (parsedResponse.mode !== 'CHAT_ONLY') {
      parsedResponse = {
        mode: 'CHAT_ONLY',
        chat_response: parsedResponse.change_summary || parsedResponse.chat_response || "Entesos.",
        change_summary: "Mode xat actiu - no s'ha editat el document"
      };
    }
  } else if (effectiveMode === 'edit') {
    // Force EDIT: If AI chose CHAT_ONLY but user wants edit, keep as-is but flag it
    // (We can't force an edit if AI didn't provide one, so we just note it)
    if (parsedResponse.mode === 'CHAT_ONLY' && has_selection) {
      // AI chose chat but user has selection and wants edit - add hint
      parsedResponse.chat_response = (parsedResponse.chat_response || "") +
        "\n\nüí° Tip: Si vols que editi el text seleccionat, reformula la instrucci√≥.";
    }
  }
  // 'auto' mode: no override, AI decides

  // 6. Return response
  return new Response(JSON.stringify({
    status: "ok",
    data: parsedResponse,
    credits_remaining: creditsResult.credits_remaining || 0,
    _debug: {
      version: "2.8",
      has_selection: has_selection,
      history_length: chat_history?.length || 0,
      has_last_edit: !!last_edit,
      user_mode: effectiveMode,
      retries: retryCount,
      banned_word_retry: bannedWordRetry,
      negative_constraints_count: negative_constraints?.length || 0,
      thought: parsedResponse.thought
    }
  }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FILE UPLOAD HANDLER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function handleFileUpload(body, env, corsHeaders) {
  const { file_data, mime_type, file_name, filename, license_key } = body;
  const finalFileName = file_name || filename;

  if (!license_key) throw new Error("missing_license");
  if (!file_data) throw new Error("missing_file_data");
  if (!mime_type) throw new Error("missing_mime_type");

  // Decode Base64 to bytes
  const binaryString = atob(file_data);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }

  const numBytes = bytes.length;
  const displayName = finalFileName || `sidecar_file_${Date.now()}`;

  // Step 1: Start resumable upload
  const startUploadUrl = `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${env.GEMINI_API_KEY}`;

  const startResp = await fetch(startUploadUrl, {
    method: 'POST',
    headers: {
      'X-Goog-Upload-Protocol': 'resumable',
      'X-Goog-Upload-Command': 'start',
      'X-Goog-Upload-Header-Content-Length': numBytes.toString(),
      'X-Goog-Upload-Header-Content-Type': mime_type,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      file: { displayName: displayName }
    })
  });

  if (!startResp.ok) {
    const errText = await startResp.text();
    throw new Error("file_api_start_error: " + errText);
  }

  const uploadUrl = startResp.headers.get('X-Goog-Upload-URL');
  if (!uploadUrl) {
    throw new Error("file_api_no_upload_url");
  }

  // Step 2: Upload bytes
  const uploadResp = await fetch(uploadUrl, {
    method: 'POST',
    headers: {
      'X-Goog-Upload-Command': 'upload, finalize',
      'X-Goog-Upload-Offset': '0',
      'Content-Length': numBytes.toString()
    },
    body: bytes
  });

  if (!uploadResp.ok) {
    const errText = await uploadResp.text();
    throw new Error("file_api_upload_error: " + errText);
  }

  const fileInfo = await uploadResp.json();

  return new Response(JSON.stringify({
    status: "ok",
    file_uri: fileInfo.file?.uri || null,
    file_name: fileInfo.file?.displayName || displayName,
    file_state: fileInfo.file?.state || "PROCESSING",
    mime_type: fileInfo.file?.mimeType || mime_type
  }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RECEIPTS HANDLERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function handleGetReceipts(body, env, corsHeaders) {
  const { license_key } = body;

  if (!license_key) throw new Error("missing_license");

  const licenseHash = await hashKey(license_key);

  const response = await fetch(
    `${env.SUPABASE_URL}/rest/v1/user_receipts?license_key_hash=eq.${licenseHash}&order=created_at.desc`,
    {
      method: 'GET',
      headers: {
        'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
        'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
        'Content-Type': 'application/json'
      }
    }
  );

  if (!response.ok) {
    throw new Error("supabase_error: " + await response.text());
  }

  const receipts = await response.json();

  return new Response(JSON.stringify({
    status: "ok",
    receipts: receipts.map(r => ({
      id: r.id,
      label: r.label,
      instruction: r.instruction,
      icon: r.icon
    }))
  }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
}

async function handleSaveReceipt(body, env, corsHeaders) {
  const { license_key, label, instruction, icon } = body;

  if (!license_key) throw new Error("missing_license");
  if (!label || !label.trim()) throw new Error("missing_label");
  if (!instruction || !instruction.trim()) throw new Error("missing_instruction");

  const licenseHash = await hashKey(license_key);

  const response = await fetch(
    `${env.SUPABASE_URL}/rest/v1/user_receipts`,
    {
      method: 'POST',
      headers: {
        'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
        'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      body: JSON.stringify({
        license_key_hash: licenseHash,
        label: label.trim(),
        instruction: instruction.trim(),
        icon: icon || '‚ö°'
      })
    }
  );

  if (!response.ok) {
    throw new Error("supabase_error: " + await response.text());
  }

  const [newReceipt] = await response.json();

  return new Response(JSON.stringify({
    status: "ok",
    receipt: {
      id: newReceipt.id,
      label: newReceipt.label,
      instruction: newReceipt.instruction,
      icon: newReceipt.icon
    }
  }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
}

async function handleDeleteReceipt(body, env, corsHeaders) {
  const { license_key, receipt_id } = body;

  if (!license_key) throw new Error("missing_license");
  if (!receipt_id) throw new Error("missing_receipt_id");

  const licenseHash = await hashKey(license_key);

  const response = await fetch(
    `${env.SUPABASE_URL}/rest/v1/user_receipts?id=eq.${receipt_id}&license_key_hash=eq.${licenseHash}`,
    {
      method: 'DELETE',
      headers: {
        'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
        'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
        'Content-Type': 'application/json'
      }
    }
  );

  if (!response.ok) {
    throw new Error("supabase_error: " + await response.text());
  }

  return new Response(JSON.stringify({
    status: "ok",
    deleted: true
  }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
}
